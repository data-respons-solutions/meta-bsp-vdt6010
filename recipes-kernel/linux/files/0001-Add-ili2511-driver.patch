From a8ef9447892eb4696a4b67b88074da85032fdc55 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mikko=20Salom=C3=A4ki?= <ms@datarespons.se>
Date: Tue, 21 May 2019 10:59:28 +0200
Subject: [PATCH] Add ili2511 driver

---
 drivers/input/touchscreen/Kconfig                |    6 +
 drivers/input/touchscreen/Makefile               |    2 +
 drivers/input/touchscreen/ilitek_main.c          | 2424 ++++++++++++++++++++
 drivers/input/touchscreen/ilitek_platform_init.c |  444 ++++
 drivers/input/touchscreen/ilitek_tool.c          | 2602 ++++++++++++++++++++++
 drivers/input/touchscreen/ilitek_ts.h            |  492 ++++
 drivers/input/touchscreen/ilitek_update.c        |  942 ++++++++
 7 files changed, 6912 insertions(+)
 create mode 100755 drivers/input/touchscreen/ilitek_main.c
 create mode 100755 drivers/input/touchscreen/ilitek_platform_init.c
 create mode 100755 drivers/input/touchscreen/ilitek_tool.c
 create mode 100755 drivers/input/touchscreen/ilitek_ts.h
 create mode 100755 drivers/input/touchscreen/ilitek_update.c

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 14931da02921..91a94f498bb4 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -382,6 +382,12 @@ config TOUCHSCREEN_ILI210X
 	  To compile this driver as a module, choose M here: the
 	  module will be called ili210x.
 
+config TOUCHSCREEN_ILI2511
+	tristate "ILI2511 touchscreens"
+	depends on I2C
+       help
+         For ILI2511 I2C touchscreen.
+
 config TOUCHSCREEN_IPROC
 	tristate "IPROC touch panel driver support"
 	depends on ARCH_BCM_IPROC || COMPILE_TEST
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index d9a53317f05a..09a502411cc9 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -103,3 +103,5 @@ obj-$(CONFIG_TOUCHSCREEN_CT36X_WLD)	+= vtl/
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
 obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
+ili2511-y := ilitek_main.o ilitek_platform_init.o ilitek_update.o ilitek_tool.o
+obj-$(CONFIG_TOUCHSCREEN_ILI2511)	+= ili2511.o
\ No newline at end of file
diff --git a/drivers/input/touchscreen/ilitek_main.c b/drivers/input/touchscreen/ilitek_main.c
new file mode 100755
index 000000000000..2af7c03e4df6
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_main.c
@@ -0,0 +1,2424 @@
+/*
+ * ILITEK Touch IC driver
+ *
+ * Copyright (C) 2011 ILI Technology Corporation.
+ *
+ * Author: Jijie Wang <jijie_wang@ilitek.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA.
+ * 
+ */
+
+#include "ilitek_ts.h"
+char ilitek_driver_information[] = {DERVER_VERSION_MAJOR, DERVER_VERSION_MINOR, CUSTOMER_ID, MODULE_ID, PLATFORM_ID, PLATFORM_MODULE, ENGINEER_ID};
+int ilitek_log_level_value = ILITEK_DEFAULT_LOG_LEVEL;
+static bool ilitek_repeat_start = true;
+static bool ilitek_exit_report = false;
+
+
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+extern struct tpd_device *tpd;
+#ifdef ILITEK_ENABLE_DMA
+static unsigned char *I2CDMABuf_va = NULL;
+static dma_addr_t I2CDMABuf_pa = 0;
+#endif
+#endif
+
+#ifdef ILITEK_TUNING_MESSAGE
+static struct sock * ilitek_netlink_sock;
+bool ilitek_debug_flag = false;
+static void ilitek_udp_reply(int pid,int seq,void *payload,int size)
+{
+	struct sk_buff	*skb;
+	struct nlmsghdr	*nlh;
+	int		len = NLMSG_SPACE(size);
+	void		*data;
+	int ret;
+
+	tp_log_debug("udp_reply\n");
+	skb = alloc_skb(len, GFP_ATOMIC);
+	if (!skb) {
+		tp_log_info("alloc skb error\n");
+		return;
+	}
+	//tp_log_info("ilitek udp_reply\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+	nlh= nlmsg_put(skb, pid, seq, 0, size, 0);
+#else
+	nlh= NLMSG_PUT(skb, pid, seq, 0, size);
+#endif
+	nlh->nlmsg_flags = 0;
+	data=NLMSG_DATA(nlh);
+	memcpy(data, payload, size);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+	NETLINK_CB(skb).portid = 0;		  /* from kernel */
+#else
+	NETLINK_CB(skb).pid = 0;		 /* from kernel */
+#endif
+	NETLINK_CB(skb).dst_group = 0;  /* unicast */
+	ret=netlink_unicast(ilitek_netlink_sock, skb, pid, MSG_DONTWAIT);
+	if (ret <0) {
+		tp_log_err("ilitek send failed\n");
+		return;
+	}
+	return;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+	nlmsg_failure:			/* Used by NLMSG_PUT */
+		if (skb) {
+			kfree_skb(skb);
+		}
+#endif
+}
+
+/* Receive messages from netlink socket. */
+static u_int ilitek_pid = 100, ilitek_seq = 23/*, sid*/;
+static void udp_receive(struct sk_buff  *skb)
+{
+  	int count = 0, ret = 0, i = 0;
+	uint8_t * data;
+	struct nlmsghdr *nlh;
+	nlh = (struct nlmsghdr *)skb->data;
+	ilitek_pid  = 100;//NETLINK_CREDS(skb)->pid;
+	//uid  = NETLINK_CREDS(skb)->uid;
+	//sid  = NETLINK_CB(skb).sid;
+	ilitek_seq  = 23;//nlh->nlmsg_seq;
+	data = (uint8_t *)NLMSG_DATA(nlh);
+	count = nlmsg_len(nlh);
+	if(!strcmp(data,"Open!")) {
+		tp_log_info("data is :%s\n",(char *)data);
+		ilitek_data->operation_protection = true;
+		ilitek_udp_reply(ilitek_pid, ilitek_seq, data, sizeof("Open!"));
+	}
+	else if(!strcmp(data,"Close!")) {
+		tp_log_info("data is :%s\n",(char *)data);
+		ilitek_data->operation_protection = false;
+	}
+	tp_log_debug("count = %d  data[count -3] = %d data[count -2] = %c\n", count, data[count -3], data[count -2]);
+	for (i = 0; i < count; i++) {
+		//tp_log_info("data[%d] = 0x%x\n", i, data[i]);
+	}
+	if (data[count -2] == 'I' && (count == 20 || count == 52) && data[0] == 0x77 && data[1] == 0x77) {
+		
+		tp_log_debug("IOCTL_WRITE CMD = %d\n", data[2]);
+		switch (data[2]) {
+			case 13:
+				//ilitek_irq_enable();
+				tp_log_info("ilitek_irq_enable. do nothing\n");
+				break;
+			case 12:
+				//ilitek_irq_disable();
+				tp_log_info("ilitek_irq_disable. do nothing\n");
+				break;
+			case 19:
+				ilitek_reset(200);
+				break;
+#ifdef ILITEK_TUNING_MESSAGE
+			case 21:
+				tp_log_info("ilitek The ilitek_debug_flag = %d.\n", data[3]);
+				if (data[3] == 0) {
+					ilitek_debug_flag = false;
+				}
+				else if (data[3] == 1) {
+					ilitek_debug_flag = true;
+				}
+				break;
+#endif
+			case 15:
+				if (data[3] == 0) {
+					ilitek_irq_disable();
+					tp_log_debug("ilitek_irq_disable.\n");
+				}
+				else {
+					ilitek_irq_enable();
+					tp_log_debug("ilitek_irq_enable.\n");
+				}
+				break;
+			case 16:
+				ilitek_data->operation_protection = data[3];
+				tp_log_info("ilitek_data->operation_protection = %d\n", ilitek_data->operation_protection);
+				break;
+			case 8:
+				tp_log_info("get driver version\n");
+				ilitek_udp_reply(ilitek_pid, ilitek_seq, ilitek_driver_information, 7);
+				break;
+			case 18:
+				tp_log_debug("firmware update write 33 bytes data\n");
+				ret = ilitek_i2c_write(&data[3], 33);
+				if (ret < 0) {
+					tp_log_err("i2c write error, ret %d, addr %x \n", ret,ilitek_data->client->addr);
+				}
+				if (ret < 0) {
+					data[0] = 1;
+				}
+				else {
+					data[0] = 0;
+				}
+				ilitek_udp_reply(ilitek_pid, ilitek_seq, data, 1);
+				return;
+				break;
+				default:
+					return;
+		}
+	}
+	else if (data[count -2] == 'W') {
+		ret = ilitek_i2c_write(data, count -2);
+		if(ret < 0){
+			tp_log_err("i2c write error, ret %d, addr %x \n", ret,ilitek_data->client->addr);
+		}
+		if (ret < 0) {
+			data[0] = 1;
+		}
+		else {
+			data[0] = 0;
+		}
+		ilitek_udp_reply(ilitek_pid, ilitek_seq, data, 1);
+	}
+	else if (data[count -2] == 'R') {
+		ret = ilitek_i2c_read(data, count - 2);
+		if(ret < 0){
+			tp_log_err("i2c read error, ret %d, addr %x \n", ret,ilitek_data->client->addr);
+		}
+		if (ret < 0) {
+			data[count - 2] = 1;
+		}
+		else {
+			data[count - 2] = 0;
+		}
+		ilitek_udp_reply(ilitek_pid, ilitek_seq, data, count - 1);
+	}
+	return ;
+}
+#endif
+
+#ifdef ILITEK_GESTURE
+static ssize_t ilitek_gesture_show(struct device *dev,
+	struct device_attribute *attr, char *buf) {
+	if (ilitek_data->enable_gesture) {
+		return sprintf(buf, "gesture: on\n");
+	}
+	else {
+		return sprintf(buf, "gesture: off\n");
+	}
+}
+static ssize_t ilitek_gesture_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size) {
+	if (buf[0]) {
+		ilitek_data->enable_gesture = true;
+	}
+	else {
+		ilitek_data->enable_gesture = false;
+	}
+	return size;
+}
+static DEVICE_ATTR(gesture, 0664, ilitek_gesture_show, ilitek_gesture_store);
+#endif
+
+#ifdef ILITEK_GLOVE
+static int ilitek_into_glovemode(bool glovemode) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+	tp_log_info("enter....... glovemode = %d\n", glovemode);
+	cmd[0] = 0x06;
+	if (glovemode) {
+		cmd[1] = 0x01;
+	}
+	else {
+		cmd[1] = 0x00;
+	}
+	mutex_lock(&ilitek_data->ilitek_mutex);
+	ret = ilitek_i2c_write(cmd, 2);
+	mutex_unlock(&ilitek_data->ilitek_mutex);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,ilitek_into_glovemode %d err ret %d\n", glovemode, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static ssize_t ilitek_glove_show(struct device *dev,
+	struct device_attribute *attr, char *buf) {
+	if (ilitek_data->enable_glove) {
+		return sprintf(buf, "glove: on\n");
+	}
+	else {
+		return sprintf(buf, "glove: off\n");
+	}
+}
+
+static ssize_t ilitek_glove_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size) {
+	if (buf[0]) {
+		ilitek_data->enable_glove = true;
+	}
+	else {
+		ilitek_data->enable_glove = false;
+	}
+	ilitek_into_glovemode(ilitek_data->enable_glove);
+	return size;
+}
+static DEVICE_ATTR(glove, 0664, ilitek_glove_show, ilitek_glove_store);
+#endif
+
+static ssize_t ilitek_firmware_version_show(struct device *dev,
+	struct device_attribute *attr, char *buf) {
+	int ret = 0;
+	tp_log_info("\n");
+	ilitek_irq_disable();
+	ret = ilitek_read_tp_info();
+	ilitek_irq_enable();
+	if (ret < 0) {
+		tp_log_err("ilitek_read_tp_info err ret = %d\n", ret);
+		return sprintf(buf, "ilitek firmware version read error ret = %d\n", ret);
+	}
+	else {
+		return sprintf(buf, "ilitek firmware version is %d.%d.%d.%d.%d.%d.%d.%d\n", ilitek_data->firmware_ver[0], ilitek_data->firmware_ver[1],
+			ilitek_data->firmware_ver[2], ilitek_data->firmware_ver[3], ilitek_data->firmware_ver[4], ilitek_data->firmware_ver[5],
+			ilitek_data->firmware_ver[6], ilitek_data->firmware_ver[7]);
+	}
+}
+
+static DEVICE_ATTR(firmware_version, 0664, ilitek_firmware_version_show, NULL);
+
+static struct attribute *ilitek_sysfs_attrs_ctrl[] = {
+	&dev_attr_firmware_version.attr,
+#ifdef ILITEK_GESTURE
+	&dev_attr_gesture.attr,
+#endif
+#ifdef ILITEK_GLOVE
+	&dev_attr_glove.attr,
+#endif
+	NULL
+};
+static struct attribute_group ilitek_attribute_group[] = {
+	{.attrs = ilitek_sysfs_attrs_ctrl },
+};
+
+
+
+
+#ifdef ILITEK_CHARGER_DETECTION
+static void ilitek_read_file(char *pFilePath, u8 *pBuf, u16 nLength) {
+	struct file *pFile = NULL;
+	mm_segment_t old_fs;
+	ssize_t nReadBytes = 0;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+
+	pFile = filp_open(pFilePath, O_RDONLY, 0);
+	if (IS_ERR(pFile)) {
+		tp_log_err("Open file failed: %s\n", pFilePath);
+		return;
+	}
+
+	pFile->f_op->llseek(pFile, 0, SEEK_SET);
+	nReadBytes = pFile->f_op->read(pFile, pBuf, nLength, &pFile->f_pos);
+	tp_log_info("Read %d bytes!\n", (int)nReadBytes);
+
+	set_fs(old_fs);
+	filp_close(pFile, NULL);
+	return;
+}
+
+static int ilitek_into_chargemode(bool chargemode) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+	tp_log_info("enter....... chargemode = %d\n", chargemode);
+	cmd[0] = 0xBE;
+	if (chargemode) {
+		cmd[1] = 0x01;
+	}
+	else {
+		cmd[1] = 0x00;
+	}
+	mutex_lock(&ilitek_data->ilitek_mutex);
+	ret = ilitek_i2c_write(cmd, 2);
+	mutex_unlock(&ilitek_data->ilitek_mutex);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,ilitek_into_chargemode %d err ret %d\n", chargemode, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static void ilitek_charge_check(struct work_struct *work) {
+	static int charge_mode = 0; 
+    u8 ChargerStatus[20] = {0};
+	tp_log_info("enter.......\n");
+	if(ilitek_data->operation_protection){
+		tp_log_info("ilitek charger ilitek_data->operation_protection is true SO not check\n");
+		goto ilitek_charge_check_out;
+	}
+	if(ilitek_data->charge_check){
+		ilitek_read_file(POWER_SUPPLY_BATTERY_STATUS_PATCH, ChargerStatus, 20);
+		tp_log_info("Battery Status : %s\n", ChargerStatus);
+		if (strstr(ChargerStatus, "Charging") != NULL || strstr(ChargerStatus, "Full") != NULL || strstr(ChargerStatus, "Fully charged") != NULL) {
+			if (charge_mode != 1) {
+				ilitek_into_chargemode(true); // charger plug-in
+				charge_mode = 1;
+			}
+		}
+		else { // Not charging
+			if (charge_mode != 2) {
+				ilitek_into_chargemode(false); // charger plug-out
+				charge_mode = 2;
+			}
+		}
+	}
+	else{
+		tp_log_info("charger not need check ilitek_data->esd_check is false!!!\n");
+		goto ilitek_charge_check_out;
+	}
+	
+ilitek_charge_check_out:
+	ilitek_data->charge_check = true;
+	queue_delayed_work(ilitek_data->charge_wq, &ilitek_data->charge_work, ilitek_data->charge_delay);
+	return;
+}
+#endif
+
+#ifdef ILITEK_ESD_PROTECTION
+static void ilitek_esd_check(struct work_struct *work) {
+	int i = 0;	
+	unsigned char buf[4]={0};
+	tp_log_info("enter.......\n");
+	if(ilitek_data->operation_protection){
+		tp_log_info("ilitek esd ilitek_data->operation_protection is true so not check\n");
+		goto ilitek_esd_check_out;
+	}
+	mutex_lock(&ilitek_data->ilitek_mutex);
+	buf[0] = ILITEK_TP_CMD_GET_PROTOCOL_VERSION;
+	if(ilitek_data->esd_check){
+		for (i = 0; i < 3; i++) {
+			if(ilitek_i2c_write_and_read(buf, 1, 0, buf, 2) < 0){
+				tp_log_err("ilitek esd  i2c communication error \n");
+				if ( i == 2) {
+					tp_log_err("esd i2c communication failed three times reset now\n");
+					break;
+				}
+			}
+			else {
+				if (buf[0] == 0x03) {
+					tp_log_info("esd ilitek_ts_send_cmd successful, response ok\n");
+						goto ilitek_esd_check_out;
+				}
+				else {
+					tp_log_err("esd ilitek_ts_send_cmd successful, response failed\n");
+					if ( i == 2) {
+						tp_log_err("esd ilitek_ts_send_cmd successful, response failed three times reset now\n");
+						break;
+					}
+				}
+			}
+		}
+	}
+	else{
+		tp_log_info("esd not need check ilitek_data->esd_check is false!!!\n");
+		goto ilitek_esd_check_out;
+	}
+	
+	ilitek_reset(200);
+ilitek_esd_check_out:	
+	mutex_unlock(&ilitek_data->ilitek_mutex);
+	ilitek_data->esd_check = true;
+	queue_delayed_work(ilitek_data->esd_wq, &ilitek_data->esd_work, ilitek_data->esd_delay);
+	return;
+}
+#endif
+
+static DECLARE_WAIT_QUEUE_HEAD(waiter);
+
+void ilitek_irq_enable(void) {
+    unsigned long irqflag = 0;
+	spin_lock_irqsave(&ilitek_data->irq_lock, irqflag);
+	if (!(ilitek_data->irq_status)) {
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+		mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#else
+        enable_irq(ilitek_data->client->irq);
+#endif
+		ilitek_data->irq_status = true;
+		tp_log_debug("\n");
+	}
+	spin_unlock_irqrestore(&ilitek_data->irq_lock, irqflag);
+}
+
+void ilitek_irq_disable(void) {
+    unsigned long irqflag = 0;
+	spin_lock_irqsave(&ilitek_data->irq_lock, irqflag);
+	if ((ilitek_data->irq_status)) {
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+		mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#else
+        disable_irq(ilitek_data->client->irq);
+#endif
+		ilitek_data->irq_status = false;
+		tp_log_info("\n");
+	}
+	spin_unlock_irqrestore(&ilitek_data->irq_lock, irqflag);
+}
+
+#ifdef ILITEK_ENABLE_DMA
+static int ilitek_dma_i2c_read(struct i2c_client *client, unsigned char *buf, int len) {
+	int i = 0, err = 0;
+
+	if(len < 8) {
+
+		client->ext_flag = client->ext_flag & (~I2C_DMA_FLAG);
+		//client->addr = client->addr & I2C_MASK_FLAG;	
+
+		return i2c_master_recv(client, buf, len);
+	}
+	else {
+
+		client->ext_flag = client->ext_flag | I2C_DMA_FLAG;
+		//client->addr = (client->addr & I2C_MASK_FLAG) | I2C_DMA_FLAG;
+
+		err = i2c_master_recv(client, (unsigned char *)I2CDMABuf_pa, len);
+		
+		if(err < 0) {
+			return err;
+		}
+
+		for(i = 0; i < len; i++) {
+			buf[i] = I2CDMABuf_va[i];
+		}
+
+		return err;
+	}
+}
+
+static int ilitek_dma_i2c_write(struct i2c_client *client, unsigned char *pbt_buf, int dw_len) {
+	int i = 0;
+	//for(i = 0 ; i < dw_len; i++) {
+	//	I2CDMABuf_va[i] = pbt_buf[i];
+	//}
+
+	if(dw_len <= 8) {
+		
+		client->ext_flag = client->ext_flag & (~I2C_DMA_FLAG);
+		//client->addr = client->addr & I2C_MASK_FLAG;
+		
+		return i2c_master_send(client, pbt_buf, dw_len);
+	}
+	else {
+		for(i = 0 ; i < dw_len; i++) {
+		I2CDMABuf_va[i] = pbt_buf[i];
+	}
+
+		client->ext_flag = client->ext_flag | I2C_DMA_FLAG;
+		//client->addr = (client->addr & I2C_MASK_FLAG) | I2C_DMA_FLAG;
+	
+		return i2c_master_send(client, (unsigned char *)I2CDMABuf_pa, dw_len);
+	}
+}
+#endif
+
+int ilitek_i2c_transfer(struct i2c_msg *msgs, int cnt)
+{
+	int ret = 0;
+	struct i2c_client * client = ilitek_data->client;
+	int count=ILITEK_I2C_RETRY_COUNT;
+#ifdef ILITEK_ENABLE_DMA
+	int i = 0; 
+	for (i = 0; i < cnt; i++) {
+		while(count >= 0) {
+			count-= 1;
+			msgs[i].ext_flag = 0;
+			if(msgs[i].flags == I2C_M_RD) {
+				ret = ilitek_dma_i2c_read(client, msgs[i].buf, msgs[i].len);
+			}
+			else if(msgs[i].flags == 0) {
+				ret = ilitek_dma_i2c_write(client, msgs[i].buf, msgs[i].len);
+			}
+			if(ret<0) {
+				tp_log_err("ilitek i2c transfer err\n");
+				mdelay(20);
+				continue;
+			}
+			break;
+		}
+	}
+#else
+#if ILITEK_PLAT == ILITEK_PLAT_ROCKCHIP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+	int i = 0;
+	for (i = 0; i < cnt; i++) {
+		msgs[i].scl_rate = 400000;
+	}
+#endif
+#endif
+	while(count >= 0) {
+		count-= 1;
+		ret = i2c_transfer(client->adapter, msgs, cnt);
+		if(ret < 0){
+			tp_log_err("ilitek_i2c_transfer err\n");
+			mdelay(20);
+			continue;
+		}
+		break;
+	}
+#endif
+	return ret;
+}
+
+int ilitek_i2c_write(uint8_t * cmd, int length)
+{
+	int ret = 0;
+	struct i2c_client * client = ilitek_data->client;
+	struct i2c_msg msgs[] = {
+		{.addr = client->addr, .flags = 0, .len = length, .buf = cmd,}
+	};
+
+	ret = ilitek_i2c_transfer(msgs, 1);
+	if(ret < 0) {
+		tp_log_err("%s, i2c write error, ret %d\n", __func__, ret);
+	}
+	return ret;
+}
+
+int ilitek_i2c_read(uint8_t *data, int length)
+{
+	int ret = 0;
+	struct i2c_client * client = ilitek_data->client;
+	struct i2c_msg msgs_ret[] = {
+		{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf = data,}
+	};
+
+
+	ret = ilitek_i2c_transfer(msgs_ret, 1);
+	if(ret < 0) {
+		tp_log_err("%s, i2c read error, ret %d\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+int ilitek_i2c_write_and_read(uint8_t *cmd,
+		int write_len, int delay, uint8_t *data, int read_len)
+{
+	int ret = 0;
+	struct i2c_client * client = ilitek_data->client;
+	struct i2c_msg msgs_send[] = {
+		{.addr = client->addr, .flags = 0, .len = write_len, .buf = cmd,},
+		{.addr = client->addr, .flags = I2C_M_RD, .len = read_len, .buf = data,}
+	};
+	struct i2c_msg msgs_receive[] = {
+		{.addr = client->addr, .flags = I2C_M_RD, .len = read_len, .buf = data,}
+	};
+	if (ilitek_repeat_start) {
+		if (read_len == 0) {
+			if (write_len > 0) {
+				ret = ilitek_i2c_transfer(msgs_send, 1);
+				if(ret < 0) {
+					tp_log_err("%s, i2c write error, ret = %d\n", __func__, ret);
+				}
+			}
+			if(delay > 0) {
+				mdelay(delay);
+			}
+		}
+		else if (write_len == 0) {
+			if(read_len > 0){
+				ret = ilitek_i2c_transfer(msgs_receive, 1);
+				if(ret < 0) {
+					tp_log_err("%s, i2c read error, ret = %d\n", __func__, ret);
+				}
+				if(delay > 0) {
+					mdelay(delay);
+				}
+			}
+		}
+		else if (delay > 0) {
+			if (write_len > 0) {
+				ret = ilitek_i2c_transfer(msgs_send, 1);
+				if(ret < 0) {
+					tp_log_err("%s, i2c write error, ret = %d\n", __func__, ret);
+				}
+			}
+			if(delay > 0) {
+				mdelay(delay);
+			}
+			if(read_len > 0){
+				ret = ilitek_i2c_transfer(msgs_receive, 1);
+				if(ret < 0) {
+					tp_log_err("%s, i2c read error, ret = %d\n", __func__, ret);
+				}
+			}
+		}
+		else {
+			ret = ilitek_i2c_transfer(msgs_send, 2);
+			if(ret < 0) {
+				tp_log_err("%s, i2c repeat start error, ret = %d\n", __func__, ret);
+			}
+		}
+	}
+	else {
+		if (write_len > 0) {
+			ret = ilitek_i2c_transfer(msgs_send, 1);
+			if(ret < 0) {
+				tp_log_err("%s, i2c write error, ret = %d\n", __func__, ret);
+			}
+		}
+		if(delay > 0) {
+			mdelay(delay);
+		}
+		if(read_len > 0){
+			ret = ilitek_i2c_transfer(msgs_receive, 1);
+			if(ret < 0) {
+				tp_log_err("%s, i2c read error, ret = %d\n", __func__, ret);
+			}
+		}
+	}
+	return ret;
+}
+
+int ilitek_poll_int(void) 
+{
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD	
+	return mt_get_gpio_in(ILITEK_IRQ_GPIO);
+#else
+	return gpio_get_value(ilitek_data->irq_gpio);
+#endif
+}
+
+void ilitek_reset(int delay) {
+	tp_log_info("delay = %d\n", delay);
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+		mt_set_gpio_mode(ILITEK_RESET_GPIO, GPIO_CTP_RST_PIN_M_GPIO);
+        mt_set_gpio_dir(ILITEK_RESET_GPIO, GPIO_DIR_OUT);
+        mt_set_gpio_out(ILITEK_RESET_GPIO, GPIO_OUT_ONE); 
+		mdelay(10);
+		
+		mt_set_gpio_mode(ILITEK_RESET_GPIO, GPIO_CTP_RST_PIN_M_GPIO);
+        mt_set_gpio_dir(ILITEK_RESET_GPIO, GPIO_DIR_OUT);
+        mt_set_gpio_out(ILITEK_RESET_GPIO, GPIO_OUT_ZERO); 
+		mdelay(10);
+		
+		mt_set_gpio_mode(ILITEK_RESET_GPIO, GPIO_CTP_RST_PIN_M_GPIO);
+        mt_set_gpio_dir(ILITEK_RESET_GPIO, GPIO_DIR_OUT);
+        mt_set_gpio_out(ILITEK_RESET_GPIO, GPIO_OUT_ONE); 
+		mdelay(delay);
+		
+#else
+	
+	if (ilitek_data->reset_gpio > 0) {
+	#if ILITEK_PLAT != ILITEK_PLAT_MTK
+		gpio_direction_output(ilitek_data->reset_gpio,1);
+		mdelay(10);
+		gpio_direction_output(ilitek_data->reset_gpio,0);
+		mdelay(10);
+		gpio_direction_output(ilitek_data->reset_gpio,1);
+		mdelay(delay);
+	#else	
+		tpd_gpio_output(ilitek_data->reset_gpio, 1);
+		mdelay(10); 
+		tpd_gpio_output(ilitek_data->reset_gpio, 0);
+		mdelay(10);
+		tpd_gpio_output(ilitek_data->reset_gpio, 1);
+		mdelay(delay);
+	#endif
+	}
+	else {
+		tp_log_err("reset pin is invalid\n");
+	}
+#endif	
+	return;
+}
+
+#if ILITEK_PLAT != ILITEK_PLAT_ALLWIN
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+void ilitek_regulator_release(void) {
+	if (ilitek_data->vdd) {
+		regulator_put(ilitek_data->vdd);
+	}	
+	if (ilitek_data->vdd_i2c) {
+		regulator_put(ilitek_data->vdd_i2c);
+	}
+}
+#endif
+#endif
+int ilitek_free_gpio(void) {
+
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	if (gpio_is_valid(ilitek_data->reset_gpio)) {
+		tp_log_info("reset_gpio is valid so free\n");
+		gpio_free(ilitek_data->reset_gpio);
+	}
+	if (gpio_is_valid(ilitek_data->irq_gpio)) {
+		tp_log_info("irq_gpio is valid so free\n");
+		gpio_free(ilitek_data->irq_gpio);
+	}
+#endif
+
+	return 0;
+}
+
+
+static int ilitek_set_input_param(void)
+{
+	int ret = 0;
+	int i = 0;
+	struct input_dev *input = ilitek_data->input_dev;
+	tp_log_debug("ilitek_set_input_param\n");
+#ifdef ILITEK_USE_MTK_INPUT_DEV
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	if (tpd_dts_data.use_tpd_button) {
+		for (i = 0; i < tpd_dts_data.tpd_key_num; i ++) {
+			input_set_capability(input, EV_KEY, tpd_dts_data.tpd_key_local[i]);
+		}
+	}
+#endif
+#else
+	__set_bit(INPUT_PROP_DIRECT, input->propbit);
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	
+#if !ILITEK_ROTATE_FLAG
+	#ifdef ILITEK_USE_LCM_RESOLUTION
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, TOUCH_SCREEN_X_MAX, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, TOUCH_SCREEN_Y_MAX, 0, 0);
+	#else
+	input_set_abs_params(input, ABS_MT_POSITION_X, ilitek_data->screen_min_x, ilitek_data->screen_max_x, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, ilitek_data->screen_min_y, ilitek_data->screen_max_y, 0, 0);
+	#endif
+#else
+	#ifdef ILITEK_USE_LCM_RESOLUTION
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, TOUCH_SCREEN_Y_MAX, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, TOUCH_SCREEN_X_MAX, 0, 0);
+	#else
+	input_set_abs_params(input, ABS_MT_POSITION_X, ilitek_data->screen_min_y, ilitek_data->screen_max_y, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, ilitek_data->screen_min_x, ilitek_data->screen_max_x, 0, 0);
+	#endif
+#endif
+	input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+
+
+	input->name = ILITEK_TS_NAME;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &(ilitek_data->client)->dev;
+#endif
+
+#ifdef ILITEK_TOUCH_PROTOCOL_B
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+		input_mt_init_slots(input, ilitek_data->max_tp, INPUT_MT_DIRECT);
+	#else
+		input_mt_init_slots(input, ilitek_data->max_tp);
+	#endif
+#endif
+	input_set_abs_params(input, ABS_MT_TRACKING_ID, 0, ilitek_data->max_tp, 0, 0);
+#ifdef ILITEK_REPORT_PRESSURE
+	input_set_abs_params(input, ABS_MT_PRESSURE, 0, 255, 0, 0);
+#endif
+	
+	for(i = 0; i < ilitek_data->keycount; i++) {
+		set_bit(ilitek_data->keyinfo[i].id & KEY_MAX, input->keybit);
+	}
+	
+#ifdef ILITEK_GESTURE
+	input_set_capability(input, EV_KEY, KEY_POWER);
+	input_set_capability(input, EV_KEY, KEY_W);
+	input_set_capability(input, EV_KEY, KEY_O);
+	input_set_capability(input, EV_KEY, KEY_C);
+	input_set_capability(input, EV_KEY, KEY_E);
+	input_set_capability(input, EV_KEY, KEY_M);
+#endif
+
+#ifndef ILITEK_USE_MTK_INPUT_DEV
+	ret = input_register_device(ilitek_data->input_dev);
+	if (ret) {
+		tp_log_err("register input device, error\n");
+	}
+#endif
+	return ret;
+}
+
+static int ilitek_touch_down(int id, int x, int y, int pressure) {
+	struct input_dev *input = ilitek_data->input_dev;
+	if ( y != 17000) {
+	
+#if defined(ILITEK_USE_MTK_INPUT_DEV) || defined(ILITEK_USE_LCM_RESOLUTION)
+	x = (x - ilitek_data->screen_min_x) * TOUCH_SCREEN_X_MAX / (ilitek_data->screen_max_x - ilitek_data->screen_min_x);
+	y = (y - ilitek_data->screen_min_y) * TOUCH_SCREEN_Y_MAX / (ilitek_data->screen_max_y - ilitek_data->screen_min_y);
+#endif
+	}
+	input_report_key(input, BTN_TOUCH, 1);
+#ifdef ILITEK_TOUCH_PROTOCOL_B
+	input_mt_slot(input, id);
+	input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+#endif
+#if !ILITEK_ROTATE_FLAG
+	input_event(input, EV_ABS, ABS_MT_POSITION_X, x);
+	input_event(input, EV_ABS, ABS_MT_POSITION_Y, y);
+#else
+	input_event(input, EV_ABS, ABS_MT_POSITION_X, y);
+	input_event(input, EV_ABS, ABS_MT_POSITION_Y, x);
+#endif
+	input_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, 128);
+#ifdef ILITEK_REPORT_PRESSURE
+	input_event(input, EV_ABS, ABS_MT_PRESSURE, pressure);
+#endif
+#ifndef ILITEK_TOUCH_PROTOCOL_B
+	//input_event(input, EV_ABS, ABS_MT_TRACKING_ID, id);
+	input_mt_sync(input);
+#endif
+
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+#ifdef CONFIG_MTK_BOOT
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	if (tpd_dts_data.use_tpd_button) {
+		if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+		{	
+			tpd_button(x, y, 1);	
+			tp_log_debug("tpd_button(x, y, 1) = tpd_button(%d, %d, 1)\n", x, y);
+		}
+	}
+#endif
+#endif
+#endif
+	return 0;
+}
+
+
+
+static int ilitek_touch_release(int id) {
+	struct input_dev *input = ilitek_data->input_dev;
+#ifdef ILITEK_TOUCH_PROTOCOL_B
+	if(ilitek_data->touch_flag[id] == 1) {
+		tp_log_debug("release point id = %d\n", id);
+		input_mt_slot(input, id);
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+	}
+#else
+	input_report_key(input, BTN_TOUCH, 0);
+	input_mt_sync(input);
+#endif
+	ilitek_data->touch_flag[id] = 0;
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+#ifdef CONFIG_MTK_BOOT
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	if (tpd_dts_data.use_tpd_button) {
+		if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+		{	
+			tpd_button(0, 0, 0);	
+			tp_log_debug("tpd_button(x, y, 0) = tpd_button(%d, %d, 0)\n", 0, 0);
+		}
+	}
+#endif
+#endif
+#endif
+
+	return 0;
+}
+
+
+
+static int ilitek_touch_release_all_point(void) {
+	struct input_dev *input = ilitek_data->input_dev;
+	int i = 0;
+#ifdef ILITEK_TOUCH_PROTOCOL_B
+	input_report_key(input, BTN_TOUCH, 0);
+	for(i = 0; i < ilitek_data->max_tp; i++)
+	{
+		ilitek_touch_release(i);
+	}
+#else
+	for(i = 0; i < ilitek_data->max_tp; i++)
+	{
+		ilitek_data->touch_flag[i] = 0;
+	}
+	ilitek_touch_release(0);
+#endif
+	input_sync(input);
+	return 0;
+}
+
+static int ilitek_check_key_down(int x, int y) {
+	int j = 0;
+	for(j = 0; j < ilitek_data->keycount; j++){
+		if((x >= ilitek_data->keyinfo[j].x && x <= ilitek_data->keyinfo[j].x + ilitek_data->key_xlen) &&
+			(y >= ilitek_data->keyinfo[j].y && y <= ilitek_data->keyinfo[j].y + ilitek_data->key_ylen)) {
+			#if ILITEK_PLAT != ILITEK_PLAT_MTK
+			input_report_key(ilitek_data->input_dev,  ilitek_data->keyinfo[j].id, 1);
+			#else
+				#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+				if (tpd_dts_data.use_tpd_button) {
+					x = tpd_dts_data.tpd_key_dim_local[j].key_x;
+					y = tpd_dts_data.tpd_key_dim_local[j].key_y;
+					tp_log_debug("key index=%x, tpd_dts_data.tpd_key_local[%d]=%d key down\n", j, j, tpd_dts_data.tpd_key_local[j]);
+					ilitek_touch_down(0, x, y, 10);
+				}
+				#else
+					x = touch_key_point_maping_array[j].point_x;
+					y = touch_key_point_maping_array[j].point_y;
+					ilitek_touch_down(0, x, y, 10);
+				#endif
+			#endif
+			ilitek_data->keyinfo[j].status = 1;
+			ilitek_data->touch_key_hold_press = true;
+			ilitek_data->is_touched = true;
+			tp_log_debug("Key, Keydown ID=%d, X=%d, Y=%d, key_status=%d\n",
+				ilitek_data->keyinfo[j].id ,x ,y , ilitek_data->keyinfo[j].status);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int ilitek_check_key_release(int x, int y, int check_point) {
+	int j = 0;
+	for (j = 0; j < ilitek_data->keycount; j++) {
+		if (check_point) {
+			if ((ilitek_data->keyinfo[j].status == 1) && (x < ilitek_data->keyinfo[j].x ||
+				x > ilitek_data->keyinfo[j].x + ilitek_data->key_xlen || y < ilitek_data->keyinfo[j].y ||
+				y > ilitek_data->keyinfo[j].y + ilitek_data->key_ylen)) {
+				#if ILITEK_PLAT != ILITEK_PLAT_MTK
+					input_report_key(ilitek_data->input_dev,  ilitek_data->keyinfo[j].id, 0);
+				#else
+					#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+					if (tpd_dts_data.use_tpd_button) {
+						tp_log_debug("key index=%x, tpd_dts_data.tpd_key_local[%d]=%d key up\n", j, j, tpd_dts_data.tpd_key_local[j]);
+						ilitek_touch_release(0);
+					}
+					#else
+						ilitek_touch_release(0);
+					#endif
+				#endif
+				ilitek_data->keyinfo[j].status = 0;
+				ilitek_data->touch_key_hold_press = false;
+				tp_log_debug("Key, Keyout ID=%d, X=%d, Y=%d, key_status=%d\n",
+					ilitek_data->keyinfo[j].id, x , y, ilitek_data->keyinfo[j].status);
+				break;
+			}
+		}
+		else {
+			if ((ilitek_data->keyinfo[j].status == 1)) {
+			#if ILITEK_PLAT != ILITEK_PLAT_MTK
+				input_report_key(ilitek_data->input_dev,  ilitek_data->keyinfo[j].id, 0);
+			#else
+				#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+					if (tpd_dts_data.use_tpd_button) {
+						tp_log_debug("key index=%x, tpd_dts_data.tpd_key_local[%d]=%d key up\n", j, j, tpd_dts_data.tpd_key_local[j]);
+						ilitek_touch_release(0);
+					}
+				#else
+					ilitek_touch_release(0);
+				#endif
+			#endif
+				ilitek_data->keyinfo[j].status = 0;
+				ilitek_data->touch_key_hold_press = false;
+				tp_log_debug("Key, Keyout ID=%d, X=%d, Y=%d, key_status=%d\n",
+					ilitek_data->keyinfo[j].id, x , y, ilitek_data->keyinfo[j].status);
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef ILITEK_GESTURE
+#if ILITEK_GESTURE == ILITEK_DOUBLE_CLICK_WAKEUP
+
+static struct timeval   start_event_time;
+int event_spacing = 0;
+static unsigned char finger_state = 0;    //0,1,2,3,4
+static int start_x = 0;
+static int start_y = 0;
+static int current_x = 0;
+static int current_y = 0;
+#define ABSSUB(a, b) ((a > b) ? (a - b) : (b - a))
+
+#define DOUBLE_CLICK_DISTANCE						1000
+#define DOUBLE_CLICK_ONE_CLICK_USED_TIME			800
+#define DOUBLE_CLICK_NO_TOUCH_TIME					1000
+#define DOUBLE_CLICK_TOTAL_USED_TIME				(DOUBLE_CLICK_NO_TOUCH_TIME + (DOUBLE_CLICK_ONE_CLICK_USED_TIME * 2))
+
+static int ilitek_get_time_diff (struct timeval *past_time) {
+    struct  timeval   time_now;
+    int diff_milliseconds = 0;
+    do_gettimeofday(&time_now);
+    diff_milliseconds += (time_now.tv_sec - past_time->tv_sec)*1000;
+	
+    if (time_now.tv_usec < past_time->tv_usec) {
+        diff_milliseconds -= 1000;
+        diff_milliseconds += (1000 * 1000 + time_now.tv_usec - past_time->tv_usec) / 1000;
+    }
+    else {
+        diff_milliseconds += (time_now.tv_usec - past_time->tv_usec) / 1000;
+    }
+
+    if (diff_milliseconds < (-10000)) {
+        diff_milliseconds = 10000;
+    }
+	//tp_log_info("diff_milliseconds = %d\n", diff_milliseconds);
+    return diff_milliseconds;
+}
+
+static int ilitek_double_click_touch(int x,int y,char finger_state,int finger_id) {
+	tp_log_info("start finger_state = %d\n", finger_state);
+	if (finger_id > 0){
+		finger_state = 0;
+		goto out;
+	}
+	if (finger_state == 0||finger_state == 5) {
+	
+		finger_state = 1;
+		start_x = x;
+		start_y = y;
+		current_x = 0;
+		current_y = 0;
+		event_spacing = 0;
+		do_gettimeofday(&start_event_time);
+	}
+	else if (finger_state == 1) {
+		event_spacing = ilitek_get_time_diff(&start_event_time);
+		if (event_spacing > DOUBLE_CLICK_ONE_CLICK_USED_TIME) {
+			finger_state = 4;
+		}
+	}
+	else if (finger_state == 2) {
+		finger_state = 3;
+		current_x = x;
+		current_y = y;
+		event_spacing = ilitek_get_time_diff(&start_event_time);
+		if (event_spacing > (DOUBLE_CLICK_ONE_CLICK_USED_TIME + DOUBLE_CLICK_NO_TOUCH_TIME)) {
+			finger_state = 0;
+		}
+	}
+	else if (finger_state == 3) {
+		current_x = x;
+		current_y = y;
+		event_spacing = ilitek_get_time_diff(&start_event_time);							   	  
+		if (event_spacing > DOUBLE_CLICK_TOTAL_USED_TIME) {
+			start_x = current_x;
+			start_y = current_y;
+			finger_state = 4;
+		}
+	}
+out:
+	tp_log_info("finger_state = %d event_spacing = %d\n", finger_state, event_spacing);
+	return finger_state;
+}
+
+static int ilitek_double_click_release(char finger_state){
+	tp_log_info("start finger_state = %d\n", finger_state);
+	if (finger_state == 1) {
+		finger_state = 2;
+		event_spacing = ilitek_get_time_diff(&start_event_time);
+		if (event_spacing > DOUBLE_CLICK_ONE_CLICK_USED_TIME) {
+			finger_state = 0;
+		}	
+	}
+	if (finger_state == 3) {
+		event_spacing = ilitek_get_time_diff(&start_event_time);
+		if ((event_spacing < DOUBLE_CLICK_TOTAL_USED_TIME && event_spacing > 50) && (ABSSUB(current_x, start_x) < DOUBLE_CLICK_DISTANCE) && ((ABSSUB(current_y, start_y) < DOUBLE_CLICK_DISTANCE))) {
+			finger_state = 5;
+			goto out;
+		}
+		else {
+			finger_state = 0;
+		}
+	}
+	else if (finger_state == 4) {
+		finger_state = 0;
+	}
+out:
+	tp_log_info("finger_state = %d event_spacing = %d\n", finger_state, event_spacing);
+	return finger_state;
+}
+
+#endif
+#endif
+static int ilitek_read_data_and_report_3XX(void) {
+	int ret = 0;
+	int packet = 0;
+	int report_max_point = 6;
+	int release_point = 0;
+	int tp_status = 0;
+	int i = 0;
+	int x = 0;
+	int y = 0;
+	struct input_dev *input = ilitek_data->input_dev;
+	unsigned char buf[64]={0};
+	buf[0] = ILITEK_TP_CMD_GET_TOUCH_INFORMATION;
+	ret = ilitek_i2c_write_and_read(buf, 1, 0, buf, 31);
+	if (ret < 0) {
+		tp_log_err("get touch information err\n");
+		if (ilitek_data->is_touched) {
+			ilitek_touch_release_all_point();
+		}
+		return ret;
+	}
+	packet = buf[0];
+	if (packet == 2) {
+		ret = ilitek_i2c_read(buf+31, 20);
+		if (ret < 0) {
+			tp_log_err("get touch information packet 2 err\n");
+			if (ilitek_data->is_touched) {
+				ilitek_touch_release_all_point();
+			}
+			return ret;
+		}
+		report_max_point = 10;
+	}
+#ifdef ILITEK_TUNING_MESSAGE
+	if (ilitek_debug_flag) {
+		ilitek_udp_reply(ilitek_pid, ilitek_seq, buf, sizeof(buf));
+	}
+#endif
+#ifdef ILITEK_TUNING_NODE
+	if (ilitek_data->debug_node_open) {
+		if (buf[0] == 0xDB) {
+			for (i = 0; i < 1000; i++) {
+				if (ilitek_data->send_data) {
+					break;
+				}
+				else {
+					if (i % 5 == 0) {
+						tp_log_info("i = %d\n", i);
+					}
+					//mdelay(1);
+					udelay(100);
+				}
+			}
+			mutex_lock(&ilitek_data->ilitek_debug_mutex);
+			memcpy(ilitek_data->debug_buf, buf, 64);
+			//ilitek_data->debug_buf[ilitek_data->debug_buf[1]] = '\0';
+			ilitek_data->have_data = true;
+			ilitek_data->send_data = false;
+			mutex_unlock(&ilitek_data->ilitek_debug_mutex);
+			wake_up(&(ilitek_data->inq));
+		}
+	}
+#endif
+	if (buf[1] == 0x5F || buf[0] == 0xDB) {
+		tp_log_debug("debug message return\n");
+		return 0;
+	}
+	for (i = 0; i < report_max_point; i++) {
+		tp_status = buf[i*5+1] >> 7;
+		tp_log_debug("ilitek tp_status = %d buf[i*5+1] = 0x%X\n", tp_status, buf[i*5+1]);
+		if (tp_status) {
+			ilitek_data->touch_flag[i] = 1;
+			x = ((buf[i*5+1] & 0x3F) << 8) + buf[i*5+2];
+			y = (buf[i*5+3] << 8) + buf[i*5+4];
+			tp_log_debug("ilitek x = %d y = %d\n", x, y);
+			if (ilitek_data->system_suspend) {
+				tp_log_info("system is suspend not report point\n");
+				#ifdef ILITEK_GESTURE
+				#if ILITEK_GESTURE == ILITEK_DOUBLE_CLICK_WAKEUP
+					finger_state = ilitek_double_click_touch(x, y, finger_state, i);
+				#endif
+				#endif
+			}
+			else {
+				if(!(ilitek_data->is_touched)) {
+					ilitek_check_key_down(x, y);
+				}
+				if (!(ilitek_data->touch_key_hold_press)) {
+					if (x > ilitek_data->screen_max_x || y > ilitek_data->screen_max_y ||
+						x < ilitek_data->screen_min_x || y < ilitek_data->screen_min_y) {
+						tp_log_info("Point (x > screen_max_x || y > screen_max_y) , ID=%02X, X=%d, Y=%d\n", i, x, y); 
+					}
+					else {
+						ilitek_data->is_touched = true;
+						if (ILITEK_REVERT_X) {
+							x = ilitek_data->screen_max_x - x + ilitek_data->screen_min_x;
+						}
+							
+						if (ILITEK_REVERT_Y) {
+							y = ilitek_data->screen_max_y - y + ilitek_data->screen_min_y;
+						}
+						tp_log_debug("Point, ID=%02X, X=%04d, Y=%04d\n",i, x,y); 
+						ilitek_touch_down(i, x, y, 10);
+					}
+				}
+				//if ((ilitek_data->touch_key_hold_press)){
+				//	ilitek_check_key_release(x, y, 1);
+				//}
+			}
+		}
+		else {
+			release_point++;
+			#ifdef ILITEK_TOUCH_PROTOCOL_B
+			ilitek_touch_release(i);
+			#endif
+		}
+	}
+	tp_log_debug("release point counter =  %d packet = %d\n", release_point, packet);
+	if (packet == 0 || release_point == report_max_point) {
+		if (ilitek_data->is_touched) {
+			ilitek_touch_release_all_point();
+		}
+		ilitek_check_key_release(x, y, 0);
+		ilitek_data->is_touched = false;
+		if (ilitek_data->system_suspend) {
+		#ifdef ILITEK_GESTURE
+		#if ILITEK_GESTURE == ILITEK_CLICK_WAKEUP
+			input_report_key(input, KEY_POWER, 1);
+			input_sync(input);
+			input_report_key(input, KEY_POWER, 0);
+			input_sync(input);
+			ilitek_data->system_suspend = false;
+		#elif ILITEK_GESTURE == ILITEK_DOUBLE_CLICK_WAKEUP
+			finger_state = ilitek_double_click_release(finger_state);
+			if (finger_state == 5) {
+				tp_log_info("double click wakeup\n");
+				input_report_key(input, KEY_POWER, 1);
+				input_sync(input);
+				input_report_key(input, KEY_POWER, 0);
+				input_sync(input);
+				ilitek_data->system_suspend = false;
+			}
+		#endif
+		#endif
+		}
+	}
+	input_sync(input);
+	return 0;
+}
+
+
+static int ilitek_read_data_and_report_2120(void) {
+	int ret = 0;
+	int touch_point_num = 0;
+	int release_point = 0;
+	int tp_status = 0;
+	int i = 0;
+	int x = 0;
+	int y = 0;
+	struct input_dev *input = ilitek_data->input_dev;
+	unsigned char buf[64]={0};
+	buf[0] = ILITEK_TP_CMD_GET_TOUCH_INFORMATION;
+	ret = ilitek_i2c_write_and_read(buf, 1, 0, buf, 53);
+	if (ret < 0) {
+		tp_log_err("get touch information err\n");
+		if (ilitek_data->is_touched) {
+			ilitek_touch_release_all_point();
+		}
+		return ret;
+	}
+#ifdef ILITEK_TUNING_MESSAGE
+	if (ilitek_debug_flag) {
+		ilitek_udp_reply(ilitek_pid, ilitek_seq, buf, sizeof(buf));
+	}
+#endif
+	if (buf[1] == 0x5F) {
+		tp_log_debug("debug message return\n");
+		return 0;
+	}
+#ifdef ILITEK_GESTURE
+	if (ilitek_data->system_suspend) {
+		tp_log_info("gesture wake up 0x%x, 0x%x, 0x%x\n", buf[0], buf[1], buf[2]);
+		if (buf[2] == 0x60) {
+			tp_log_info("gesture wake up this is c\n");
+			input_report_key(input, KEY_C, 1);
+			input_sync(input);
+			input_report_key(input, KEY_C, 0);
+			input_sync(input);
+		}
+		else if (buf[2] == 0x62) {
+			tp_log_info("gesture wake up this is e\n");
+			input_report_key(input, KEY_E, 1);
+			input_sync(input);
+			input_report_key(input, KEY_E, 0);
+			input_sync(input);
+		}
+		else if (buf[2] == 0x64) {
+			tp_log_info("gesture wake up this is m\n");
+			input_report_key(input, KEY_M, 1);
+			input_sync(input);
+			input_report_key(input, KEY_M, 0);
+			input_sync(input);
+		}
+		else if (buf[2] == 0x66) {
+			tp_log_info("gesture wake up this is w\n");
+			input_report_key(input, KEY_W, 1);
+			input_sync(input);
+			input_report_key(input, KEY_W, 0);
+			input_sync(input);
+		}
+		else if (buf[2] == 0x68) {
+			tp_log_info("gesture wake up this is o\n");
+			input_report_key(input, KEY_O, 1);
+			input_sync(input);
+			input_report_key(input, KEY_O, 0);
+			input_sync(input);
+		}
+		else if (buf[2] == 0x22) {
+			tp_log_info("gesture wake up this is double click\n");
+			if (false) {
+				input_report_key(input, KEY_O, 1);
+				input_sync(input);
+				input_report_key(input, KEY_O, 0);
+				input_sync(input);
+			}
+		}
+		input_report_key(input, KEY_POWER, 1);
+		input_sync(input);
+		input_report_key(input, KEY_POWER, 0);
+		input_sync(input);
+		return 0;
+	}
+#endif
+	touch_point_num = buf[0];
+	for (i = 0; i < ilitek_data->max_tp; i++) {
+		tp_status = buf[i*5+3] >> 7;	
+		tp_log_debug("ilitek tp_status = %d buf[i*5+3] = 0x%X\n", tp_status, buf[i*5+3]);
+		if (tp_status) {
+			ilitek_data->touch_flag[i] = 1;
+			x = (((int)(buf[i*5+3] & 0x3F) << 8) + buf[i*5+4]);
+			y = (((int)(buf[i*5+5] & 0x3F) << 8) + buf[i*5+6]);
+			tp_log_debug("ilitek x = %d y = %d\n", x, y);
+			if(!(ilitek_data->is_touched)) {
+				ilitek_check_key_down(x, y);
+			}
+			if (!(ilitek_data->touch_key_hold_press)) {
+				if (x > ilitek_data->screen_max_x || y > ilitek_data->screen_max_y ||
+					x < ilitek_data->screen_min_x || y < ilitek_data->screen_min_y) {
+					tp_log_info("Point (x > screen_max_x || y > screen_max_y) , ID=%02X, X=%d, Y=%d\n", i, x, y); 
+				}
+				else {
+					ilitek_data->is_touched = true;
+					if (ILITEK_REVERT_X) {
+						x = ilitek_data->screen_max_x - x + ilitek_data->screen_min_x;
+					}
+						
+					if (ILITEK_REVERT_Y) {
+						y = ilitek_data->screen_max_y - y + ilitek_data->screen_min_y;
+					}
+					tp_log_debug("Point, ID=%02X, X=%04d, Y=%04d\n",i, x,y); 
+					ilitek_touch_down(i, x, y, 10);
+				}
+			}
+			//if ((ilitek_data->touch_key_hold_press)){
+			//	ilitek_check_key_release(x, y, 1);
+			//}
+		}
+		else {
+			release_point++;
+			#ifdef ILITEK_TOUCH_PROTOCOL_B
+			ilitek_touch_release(i);
+			#endif
+		}
+	}
+	tp_log_debug("release point counter =  %d touch_point_num = %d\n", release_point, touch_point_num);
+	if (touch_point_num == 0 || release_point == ilitek_data->max_tp) {
+		if (ilitek_data->is_touched) {
+			ilitek_touch_release_all_point();
+		}
+		ilitek_check_key_release(x, y, 0);
+		ilitek_data->is_touched = false;
+	}
+	input_sync(input);
+	return 0;
+}
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+static void ilitek_i2c_isr(void)
+#else
+static irqreturn_t ilitek_i2c_isr(int irq, void *dev_id)
+#endif
+{
+    unsigned long irqflag = 0;
+	tp_log_debug("\n");
+#ifdef ILITEK_ESD_PROTECTION
+	ilitek_data->esd_check = false;
+#endif
+	if (ilitek_data->firmware_updating) {
+		tp_log_debug("firmware_updating return\n");
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+		return;
+#else
+		return IRQ_HANDLED;
+#endif
+	}
+	ilitek_data->irq_trigger = true;
+	wake_up_interruptible(&waiter);
+	spin_lock_irqsave(&ilitek_data->irq_lock, irqflag);
+	if (ilitek_data->irq_status) {
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+		mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#else
+        disable_irq_nosync(ilitek_data->client->irq);
+#endif
+		ilitek_data->irq_status = false;
+	}
+	spin_unlock_irqrestore(&ilitek_data->irq_lock, irqflag);
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+    return IRQ_HANDLED;
+#endif
+}
+static int ilitek_request_irq(void) {
+	int ret = 0;
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	struct device_node *node;
+#endif
+#endif
+    spin_lock_init(&ilitek_data->irq_lock);
+	ilitek_data->irq_status = true;
+#if ILITEK_PLAT != ILITEK_PLAT_MTK
+	ilitek_data->client->irq  = gpio_to_irq(ilitek_data->irq_gpio);
+#else
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	node = of_find_matching_node(NULL, touch_of_match);
+	if (node) {
+		ilitek_data->client->irq = irq_of_parse_and_map(node, 0);
+	}
+#endif
+#endif
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	mt_set_gpio_mode(ILITEK_IRQ_GPIO, GPIO_CTP_EINT_PIN_M_EINT);
+    mt_set_gpio_dir(ILITEK_IRQ_GPIO, GPIO_DIR_IN);
+    mt_set_gpio_pull_enable(ILITEK_IRQ_GPIO, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_select(ILITEK_IRQ_GPIO, GPIO_PULL_UP);
+
+    mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+    mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE, ilitek_i2c_isr, 1);
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#else
+	tp_log_info("ilitek_data->client->irq = %d\n", ilitek_data->client->irq);
+	if (ilitek_data->client->irq > 0) {
+		//ret = request_irq(ilitek_data->client->irq, ilitek_i2c_isr, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "ilitek_i2c_irq", ilitek_data);
+		ret = request_threaded_irq(ilitek_data->client->irq, NULL,ilitek_i2c_isr, /*IRQF_TRIGGER_FALLING*/ IRQF_TRIGGER_LOW | IRQF_ONESHOT,"ilitek_touch_irq", ilitek_data);
+		if (ret) {
+			tp_log_err("ilitek_request_irq, error\n");
+		}
+	}
+	else {
+		ret = -EINVAL;
+	}
+#endif
+	return ret;
+}
+
+static int ilitek_i2c_process_and_report(void) {
+	int ret = 0;
+	mutex_lock(&ilitek_data->ilitek_mutex);
+	if (ilitek_data->ic_2120) {
+		ret = ilitek_read_data_and_report_2120();
+	}
+	else {
+		ret = ilitek_read_data_and_report_3XX();
+	}
+	mutex_unlock(&ilitek_data->ilitek_mutex);
+	return ret;
+}
+
+#ifdef ILITEK_UPDATE_FW
+static int ilitek_update_thread(void *arg)
+{
+
+	int ret=0;
+	tp_log_info("\n");
+
+	if(kthread_should_stop()){
+		tp_log_info("ilitek_update_thread, stop\n");
+		return -1;
+	}
+	
+	mdelay(100);
+	ilitek_data->firmware_updating = true;
+	ilitek_data->operation_protection = true;
+	ret = ilitek_upgrade_firmware();
+	ret = ilitek_read_tp_info();
+	ilitek_data->operation_protection = false;
+	ilitek_data->firmware_updating = false;
+	ret = ilitek_set_input_param();
+	if (ret) {
+		tp_log_err("register input device, error\n");
+	}
+	ret = ilitek_request_irq();
+	if (ret) {
+		tp_log_err("ilitek_request_irq, error\n");
+	}
+	return ret;
+}
+#endif
+
+static int ilitek_irq_handle_thread(void *arg) {
+	int ret=0;
+	struct sched_param param = { .sched_priority = 4};
+	sched_setscheduler(current, SCHED_RR, &param);	
+	tp_log_info("%s, enter\n", __func__);
+
+	// mainloop
+	while(!kthread_should_stop() && !ilitek_exit_report){
+		set_current_state(TASK_INTERRUPTIBLE);
+		wait_event_interruptible(waiter, ilitek_data->irq_trigger);
+		ilitek_data->irq_trigger = false;
+		set_current_state(TASK_RUNNING);
+		if (ilitek_i2c_process_and_report() < 0){
+			tp_log_err("process error\n");
+		}
+		ilitek_irq_enable();
+	}
+	tp_log_err("%s, exit\n", __func__);
+	tp_log_err("%s, exit\n", __func__);
+	tp_log_err("%s, exit\n", __func__);
+	return ret;
+}
+
+void ilitek_suspend(void) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+	tp_log_info("\n");
+#ifdef ILITEK_ESD_PROTECTION
+	ilitek_data->esd_check = false;
+	cancel_delayed_work_sync(&ilitek_data->esd_work);
+#endif
+
+#ifdef ILITEK_CHARGER_DETECTION
+	ilitek_data->charge_check = false;
+	cancel_delayed_work_sync(&ilitek_data->charge_work);
+#endif
+
+	if (ilitek_data->operation_protection || ilitek_data->firmware_updating) {
+		tp_log_info("operation_protection or firmware_updating return\n");
+		return;
+	}
+	mutex_lock(&ilitek_data->ilitek_mutex);
+	if (ilitek_data->ic_2120) {
+		cmd[0] = 0x01;
+		cmd[1] = 0x00;
+		ret = ilitek_i2c_write(cmd, 2);
+		if(ret < 0){
+			tp_log_err("0x01 0x00 set tp suspend err, ret %d\n", ret);
+		}
+		mdelay(10);
+	#if defined(ILITEK_GESTURE)
+		if (ilitek_data->enable_gesture) {
+			cmd[0] = 0x0A;
+			cmd[1] = 0x01;
+		}
+		else {
+			cmd[0] = ILITEK_TP_CMD_SLEEP_2120;
+			cmd[1] = 0x00;
+		}
+		ret = ilitek_i2c_write(cmd, 2);
+		if(ret < 0){
+			tp_log_err("0x%X 0x%X set tp suspend err, ret %d\n", cmd[0], cmd[1], ret);
+		}
+	#else
+		cmd[0] = ILITEK_TP_CMD_SLEEP_2120;
+		cmd[1] = 0x00;
+		ret = ilitek_i2c_write(cmd, 2);
+		if(ret < 0){
+			tp_log_err("0x02 0x00 set tp suspend err, ret %d\n", ret);
+		}
+	#endif
+	}
+	else {
+	#ifndef ILITEK_GESTURE
+		cmd[0] = ILITEK_TP_CMD_SLEEP;
+		ret = ilitek_i2c_write(cmd, 1);
+		if(ret < 0){
+			tp_log_err("0x30 set tp suspend err, ret %d\n", ret);
+		}
+	#endif
+	}
+#ifndef ILITEK_GESTURE
+	ilitek_irq_disable();
+#endif
+	mutex_unlock(&ilitek_data->ilitek_mutex);
+	ilitek_data->system_suspend = true;
+}
+
+void ilitek_resume(void) {
+	u8 cmd[2] = {0};
+	int ret = 0;
+#ifdef ILITEK_CHARGER_DETECTION
+	u8 ChargerStatus[20] = {0};
+#endif
+	tp_log_info("\n");
+	ilitek_touch_release_all_point();
+	if (ilitek_data->operation_protection || ilitek_data->firmware_updating) {
+		tp_log_info("operation_protection or firmware_updating return\n");
+		return;
+	}
+	mutex_lock(&ilitek_data->ilitek_mutex);
+#ifdef ILITEK_GESTURE
+	ilitek_irq_disable();
+#endif
+	if (ilitek_data->ic_2120) {
+		ilitek_reset(50);
+	}
+	else {
+		ilitek_reset(200);
+	}
+	mutex_unlock(&ilitek_data->ilitek_mutex);
+#ifdef ILITEK_GLOVE
+	if (ilitek_data->enable_gesture) {
+		ilitek_into_glovemode(true);
+	}
+#endif
+	if ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25) {
+		tp_log_info("ILI2511 resume write 0x20\n");
+		cmd[0] = ILITEK_TP_CMD_GET_TP_RESOLUTION;
+		ret = ilitek_i2c_write(cmd, 1);
+		if (ret < 0) {
+			tp_log_err("ILI251X resume write 0x20 err ret = %d\n", ret);
+		}
+	}
+	ilitek_irq_enable();
+	ilitek_data->system_suspend = false;
+	#ifdef ILITEK_GESTURE
+	#if ILITEK_GESTURE == ILITEK_DOUBLE_CLICK_WAKEUP
+		finger_state = 0;
+	#endif
+	#endif
+#ifdef ILITEK_ESD_PROTECTION
+	ilitek_data->esd_check = true;
+	if (ilitek_data->esd_wq) {
+		queue_delayed_work(ilitek_data->esd_wq, &ilitek_data->esd_work, ilitek_data->esd_delay);
+	}
+#endif
+#ifdef ILITEK_CHARGER_DETECTION
+	ilitek_read_file(POWER_SUPPLY_BATTERY_STATUS_PATCH, ChargerStatus, 20);
+	tp_log_info("*** Battery Status : %s ***\n", ChargerStatus);
+	if (strstr(ChargerStatus, "Charging") != NULL || strstr(ChargerStatus, "Full") != NULL || strstr(ChargerStatus, "Fully charged") != NULL) {
+		ilitek_into_chargemode(true); // charger plug-in
+	}
+	else { // Not charging
+		ilitek_into_chargemode(false); // charger plug-out
+	}
+	ilitek_data->charge_check = true;
+	if (ilitek_data->charge_wq) {
+		queue_delayed_work(ilitek_data->charge_wq, &ilitek_data->charge_work, ilitek_data->charge_delay);
+	}
+#endif
+}
+
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+int ilitek_suspend_allwin(struct i2c_client *client, pm_message_t mesg) {
+	ilitek_suspend();
+	return 0;
+}
+int ilitek_resume_allwin(struct i2c_client *client) {
+	ilitek_resume();
+	return 0;
+}
+#endif
+
+#if ILITEK_PLAT != ILITEK_PLAT_MTK
+#ifdef CONFIG_FB
+static int ilitek_fb_notifier_callback(struct notifier_block *self,
+		unsigned long event, void *data) {
+	struct fb_event *ev_data = data;
+	int *blank;
+	tp_log_info("FB EVENT event = %ld\n", event);
+	if (ev_data && ev_data->data && event == FB_EARLY_EVENT_BLANK) {
+		blank = ev_data->data;
+		if (*blank == FB_BLANK_UNBLANK || *blank == FB_BLANK_NORMAL) {
+			ilitek_resume();
+		}
+	}
+
+	if (ev_data && ev_data->data && event == FB_EVENT_BLANK) {
+		blank = ev_data->data;
+		if (*blank == FB_BLANK_POWERDOWN) {
+			ilitek_suspend();
+		}
+	}
+	return 0;
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void ilitek_early_suspend(struct early_suspend *h) {
+	ilitek_suspend();
+}
+
+static void ilitek_late_resume(struct early_suspend *h) {
+	ilitek_resume();
+}
+#endif
+#endif
+
+int ilitek_get_gpio_num(void) {
+	int ret = 0;
+#ifdef ILITEK_GET_GPIO_NUM
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+	tp_log_info("(config_info.wakeup_gpio.gpio) = %d (config_info.int_number) = %d\n", (config_info.wakeup_gpio.gpio), (config_info.int_number));
+	ilitek_data->reset_gpio = (config_info.wakeup_gpio.gpio);
+	ilitek_data->irq_gpio = (config_info.int_number);
+#else
+	#ifdef CONFIG_OF
+	struct device *dev = &(ilitek_data->client->dev);
+	struct device_node *np = dev->of_node;
+	ilitek_data->reset_gpio = of_get_named_gpio(np, "ilitek,reset-gpio", 0);
+	if (ilitek_data->reset_gpio < 0) {
+		tp_log_err("reset_gpio = %d\n", ilitek_data->reset_gpio);
+	}
+	ilitek_data->irq_gpio = of_get_named_gpio(np, "ilitek,irq-gpio", 0);
+	if (ilitek_data->irq_gpio < 0) {
+		tp_log_err("irq_gpio = %d\n", ilitek_data->irq_gpio);
+	}
+	#endif
+#endif
+#else
+	ilitek_data->reset_gpio = ILITEK_RESET_GPIO;
+	ilitek_data->irq_gpio = ILITEK_IRQ_GPIO;
+#endif
+	tp_log_info("reset_gpio = %d irq_gpio = %d\n", ilitek_data->reset_gpio, ilitek_data->irq_gpio);
+	return ret;
+}
+
+int ilitek_request_gpio(void) {
+	int ret = 0;
+	ilitek_get_gpio_num();
+#if ILITEK_PLAT != ILITEK_PLAT_MTK
+	if (ilitek_data->reset_gpio > 0) {
+		ret= gpio_request(ilitek_data->reset_gpio, "ilitek-reset-gpio");
+		if (ret) {
+			tp_log_err("Failed to request reset_gpio so free retry\n");
+			gpio_free(ilitek_data->reset_gpio);
+			ret= gpio_request(ilitek_data->reset_gpio, "ilitek-reset-gpio");
+			if (ret) {
+				tp_log_err("Failed to request reset_gpio \n");
+			}
+		}
+		if (ret) {
+			tp_log_err("Failed to request reset_gpio \n");
+		}
+		else {
+			ret = gpio_direction_output(ilitek_data->reset_gpio, 1);
+			if (ret) {
+				tp_log_err("Failed to direction output rest gpio err\n");
+			}
+		}
+	}
+	if (ilitek_data->irq_gpio > 0) {
+		ret= gpio_request(ilitek_data->irq_gpio, "ilitek-irq-gpio");
+		if (ret) {
+			tp_log_err("Failed to request irq_gpio so free retry\n");
+			gpio_free(ilitek_data->irq_gpio);
+			ret= gpio_request(ilitek_data->irq_gpio, "ilitek-irq-gpio");
+			if (ret) {
+				tp_log_err("Failed to request irq_gpio \n");
+			}
+		}
+		if (ret) {
+			tp_log_err("Failed to request irq_gpio \n");
+		}
+		else {
+			ret = gpio_direction_input(ilitek_data->irq_gpio);
+			if (ret) {
+				tp_log_err("Failed to direction input irq gpio err\n");
+			}
+		}
+	}
+#endif
+	return ret;
+}
+
+
+int	ilitek_power_on(bool status) {
+	int ret = 0;
+	tp_log_info("%s\n", status ? "POWER ON":"POWER OFF");
+#if ILITEK_PLAT != ILITEK_PLAT_ALLWIN
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+	if (status) {
+		if (ilitek_data->vdd) {
+			ret = regulator_enable(ilitek_data->vdd);
+			if (ret < 0) {
+				tp_log_err("regulator_enable vdd fail\n");
+				return -EINVAL;
+			}
+		}	
+		if (ilitek_data->vdd_i2c) {
+			ret = regulator_enable(ilitek_data->vdd_i2c);
+			if (ret < 0) {
+				tp_log_err("regulator_enable vdd_i2c fail\n");
+				return -EINVAL;
+			}
+		}	
+	}
+	else {
+		if (ilitek_data->vdd) {
+			ret = regulator_disable(ilitek_data->vdd);
+			if (ret < 0) {
+				tp_log_err("regulator_enable vdd fail\n");
+				//return -EINVAL;
+			}
+		}	
+		if (ilitek_data->vdd_i2c) {
+			ret = regulator_disable(ilitek_data->vdd_i2c);
+			if (ret < 0) {
+				tp_log_err("regulator_enable vdd_i2c fail\n");
+				//return -EINVAL;
+			}
+		}	
+	}
+#endif
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+//please change for your own platform
+		if (status) {
+			//hwPowerDown(MT6323_POWER_LDO_VGP1,"TP");
+			//hwPowerOn(MT6323_POWER_LDO_VGP1,VOL_3300,"TP");
+			hwPowerOn(PMIC_APP_CAP_TOUCH_VDD, VOL_2800, "TP"); 
+		}else{
+			//hwPowerDown(MT6323_POWER_LDO_VGP1,"TP");
+		}
+#endif
+
+#else
+	input_set_power_enable(&(config_info.input_type), status);
+#endif
+	return ret;
+}
+
+static int ilitek_create_esdandcharge_workqueue(void) {
+#ifdef ILITEK_CHARGER_DETECTION
+	u8 ChargerStatus[20] = {0};
+#endif
+#ifdef ILITEK_ESD_PROTECTION
+	INIT_DELAYED_WORK(&ilitek_data->esd_work, ilitek_esd_check);
+	ilitek_data->esd_wq = create_singlethread_workqueue("ilitek_esd_wq");
+	if (!ilitek_data->esd_wq) {
+		tp_log_err("create workqueue esd work err\n");
+	}
+	else {
+		ilitek_data->esd_check = true;
+		ilitek_data->esd_delay = 2 * HZ;
+		queue_delayed_work(ilitek_data->esd_wq, &ilitek_data->esd_work, ilitek_data->esd_delay);
+	}
+#endif
+	
+#ifdef ILITEK_CHARGER_DETECTION
+	ilitek_read_file(POWER_SUPPLY_BATTERY_STATUS_PATCH, ChargerStatus, 20);
+	tp_log_info("*** Battery Status : %s ***\n", ChargerStatus);
+	if (strstr(ChargerStatus, "Charging") != NULL || strstr(ChargerStatus, "Full") != NULL || strstr(ChargerStatus, "Fully charged") != NULL) {
+		ilitek_into_chargemode(true); // charger plug-in
+	}
+	else { // Not charging
+		ilitek_into_chargemode(false); // charger plug-out
+	}
+	INIT_DELAYED_WORK(&ilitek_data->charge_work, ilitek_charge_check);
+	ilitek_data->charge_wq = create_singlethread_workqueue("ilitek_charge_wq");
+	if (!ilitek_data->charge_wq) {
+		tp_log_err("create workqueue charge work err\n");
+	}
+	else {
+		ilitek_data->charge_check = true;
+		ilitek_data->charge_delay = 2 * HZ;
+		queue_delayed_work(ilitek_data->charge_wq, &ilitek_data->charge_work, ilitek_data->charge_delay);
+	}
+#endif
+	return 0;
+}
+
+static int ilitek_create_sysfsnode (void) {
+	int ret = 0;
+	ilitek_data->ilitek_func_kobj = kobject_create_and_add("touchscreen", NULL) ;
+	if (ilitek_data->ilitek_func_kobj == NULL) {
+		tp_log_err("kobject_create_and_add failed\n");
+	}
+	else {
+		ret = sysfs_create_group(ilitek_data->ilitek_func_kobj, ilitek_attribute_group);
+		if (ret < 0) {
+			tp_log_err("sysfs_create_group failed\n");
+			kobject_put(ilitek_data->ilitek_func_kobj);
+		}
+	}
+	return ret;
+}
+
+static int ilitek_register_resume_suspend(void) {
+	int ret = 0;
+#if ILITEK_PLAT != ILITEK_PLAT_MTK
+#ifdef CONFIG_FB
+	ilitek_data->fb_notif.notifier_call = ilitek_fb_notifier_callback;
+	
+	ret = fb_register_client(&ilitek_data->fb_notif);
+	
+	if (ret) {
+		tp_log_err("Unable to register fb_notifier: %d\n", ret);
+	}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	ilitek_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ilitek_data->early_suspend.suspend = ilitek_early_suspend;
+	ilitek_data->early_suspend.resume = ilitek_late_resume;
+	register_early_suspend(&ilitek_data->early_suspend);
+#endif
+#endif
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+	device_enable_async_suspend(&ilitek_data->client->dev);
+	pm_runtime_set_active(&ilitek_data->client->dev);
+	pm_runtime_get(&ilitek_data->client->dev);
+	pm_runtime_enable(&ilitek_data->client->dev);
+#endif
+	return ret;
+}
+
+static int ilitek_init_netlink(void) {
+#ifdef ILITEK_TUNING_MESSAGE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		struct netlink_kernel_cfg cfg = {
+			.groups = 0,
+			.input	= udp_receive,
+		};
+#endif		
+#endif
+
+#ifdef ILITEK_TUNING_MESSAGE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	ilitek_netlink_sock = netlink_kernel_create(&init_net, 21, &cfg);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+	ilitek_netlink_sock = netlink_kernel_create(&init_net, 21, 0,udp_receive, NULL, THIS_MODULE);
+#else
+	ilitek_netlink_sock = netlink_kernel_create(&init_net, 21, THIS_MODULE, &cfg);
+#endif
+#endif
+	return 0;
+}
+
+int ilitek_read_tp_info(void) {
+	int ret = 0;
+	int i = 0;
+	unsigned char buf[64] = {0};
+	tp_log_info("driver version %d.%d.%d.%d.%d.%d.%d\n", ilitek_driver_information[0], ilitek_driver_information[1],
+		ilitek_driver_information[2], ilitek_driver_information[3], ilitek_driver_information[4],
+		ilitek_driver_information[5], ilitek_driver_information[6]);
+	
+	buf[0] = ILITEK_TP_CMD_GET_KERNEL_VERSION;
+	ret = ilitek_i2c_write_and_read(buf, 1, 5, buf, 5);
+	if (ret < 0) {
+		goto transfer_err;
+	}
+	for (i = 0; i < 5; i++) {
+		ilitek_data->mcu_ver[i] = buf[i];
+	}
+	tp_log_info("MCU KERNEL version:%d.%d.%d.%d.%d\n", buf[0], buf[1], buf[2],buf[3], buf[4]);
+	if ((buf[0] == 0 && buf[1] == 0) || (buf[0] == 0xFF && buf[1] == 0xFF)) {
+		ilitek_data->ic_2120 = true;
+	}
+	else {
+		ilitek_data->ic_2120 = false;
+		#ifdef ILITEK_GESTURE
+		ilitek_data->enable_gesture = true;
+		#endif
+	}
+	if ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25) {
+		ilitek_repeat_start = false;
+		tp_log_info("ILI2511 not support repeat start\n");
+	}
+	tp_log_info("ic_2120 is %d\n", ilitek_data->ic_2120);
+	if (!ilitek_data->ic_2120) {
+		buf[0] = ILITEK_TP_CMD_READ_MODE;
+		ret =ilitek_i2c_write_and_read(buf, 1, 5, buf, 2);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		tp_log_info("ilitek ic. mode =%d , it's %s \n",buf[0],((buf[0] == 0x5A)?"AP MODE":"BL MODE"));
+#ifdef ILITEK_UPDATE_FW
+		if (buf[0] == 0x55) {
+			ilitek_data->force_update = true;
+		}
+#endif
+		buf[0] = ILITEK_TP_CMD_GET_FIRMWARE_VERSION;
+		ret = ilitek_i2c_write_and_read(buf, 1, 5, buf, 8);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		for (i = 0; i < 8; i++) {
+			ilitek_data->firmware_ver[i] = buf[i];
+		}
+		tp_log_info("firmware version:%d.%d.%d.%d.%d.%d.%d.%d\n",
+			buf[0], buf[1], buf[2],buf[3], buf[4], buf[5], buf[6],buf[7]);
+		buf[0] = ILITEK_TP_CMD_GET_PROTOCOL_VERSION;
+		ret = ilitek_i2c_write_and_read(buf, 1, 5, buf, 2);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		ilitek_data->protocol_ver = (((int)buf[0]) << 8) + buf[1];
+		tp_log_info("protocol version: %d.%d  ilitek_data->protocol_ver = 0x%x\n", buf[0], buf[1], ilitek_data->protocol_ver);
+		buf[0] = ILITEK_TP_CMD_GET_SCREEN_RESOLUTION;
+		ret = ilitek_i2c_write_and_read(buf, 1, 5, buf, 8);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		ilitek_data->screen_min_x = buf[0];
+		ilitek_data->screen_min_x+= ((int)buf[1]) * 256;
+		ilitek_data->screen_min_y = buf[2];
+		ilitek_data->screen_min_y+= ((int)buf[3]) * 256;
+		ilitek_data->screen_max_x = buf[4];
+		ilitek_data->screen_max_x+= ((int)buf[5]) * 256;
+		ilitek_data->screen_max_y = buf[6];
+		ilitek_data->screen_max_y+= ((int)buf[7]) * 256;
+		tp_log_info("screen_min_x: %d, screen_min_y: %d screen_max_x: %d, screen_max_y: %d\n",
+			ilitek_data->screen_min_x, ilitek_data->screen_min_y, ilitek_data->screen_max_x, ilitek_data->screen_max_y);
+		buf[0] = ILITEK_TP_CMD_GET_TP_RESOLUTION;
+		ret = ilitek_i2c_write_and_read(buf, 1, 5, buf, 10);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+	
+		ilitek_data->max_tp = buf[6];
+		ilitek_data->max_btn = buf[7];
+		ilitek_data->keycount = buf[8];
+		if (ilitek_data->keycount > 20) {
+			tp_log_info("exception keycount > 20 is %d set keycount = 0\n", ilitek_data->keycount);
+			ilitek_data->keycount = 0;
+		}
+		ilitek_data->tp_max_x = buf[0];
+		ilitek_data->tp_max_x+= ((int)buf[1]) * 256;
+		ilitek_data->tp_max_y = buf[2];
+		ilitek_data->tp_max_y+= ((int)buf[3]) * 256;
+		ilitek_data->x_ch = buf[4];
+		ilitek_data->y_ch = buf[5];
+		if (ilitek_data->keycount > 0) {
+			//get key infotmation
+			buf[0] = ILITEK_TP_CMD_GET_KEY_INFORMATION;
+			ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 29);
+			if (ret < 0) {
+				goto transfer_err;
+			}
+			if (ilitek_data->keycount > 5) {
+				for (i = 0; i < ((ilitek_data->keycount % 5) ? (((ilitek_data->keycount - 5) / 5) + 1) : ((ilitek_data->keycount - 5) / 5)); i++) {
+					tp_log_info("read keyinfo times i = %d\n", i);
+					ret = ilitek_i2c_write_and_read(buf, 0, 10, buf + 29 + 25 * i, 25);
+					if (ret < 0) {
+						goto transfer_err;
+					}
+				}
+			}
+			
+			ilitek_data->key_xlen = (buf[0] << 8) + buf[1];
+			ilitek_data->key_ylen = (buf[2] << 8) + buf[3];
+			tp_log_info("key_xlen: %d, key_ylen: %d\n", ilitek_data->key_xlen, ilitek_data->key_ylen);
+			
+			//print key information
+			for(i = 0; i < ilitek_data->keycount; i++){
+				ilitek_data->keyinfo[i].id = buf[i*5+4]; 
+				ilitek_data->keyinfo[i].x = (buf[i*5+5] << 8) + buf[i*5+6];
+				ilitek_data->keyinfo[i].y = (buf[i*5+7] << 8) + buf[i*5+8];
+				ilitek_data->keyinfo[i].status = 0;
+				tp_log_info("key_id: %d, key_x: %d, key_y: %d, key_status: %d\n",
+					ilitek_data->keyinfo[i].id, ilitek_data->keyinfo[i].x, ilitek_data->keyinfo[i].y, ilitek_data->keyinfo[i].status);
+			}
+		}
+	}
+	else {
+		for (i = 0; i < 3; i++) {
+			buf[0] = ILITEK_TP_CMD_GET_TOUCH_INFORMATION;
+			ilitek_i2c_write_and_read(buf, 1, 10, buf, 3);
+			tp_log_info("ilitek %s, write 0x10 read buf = %X, %X, %X\n", __func__, buf[0], buf[1], buf[2]);
+			if (buf[1] >= 0x80) {
+				tp_log_info("FW is ready  ok ok \n");
+				break;
+			}else {
+				mdelay(5);
+			}
+		}
+		if (i >= 3) {
+#ifdef ILITEK_UPDATE_FW
+			tp_log_err("ilitek wirte 0x10 read data error (< 0x80) so set force_update = true\n");
+			ilitek_data->force_update = true;
+#endif
+		}
+		buf[0] = ILITEK_TP_CMD_READ_DATA_CONTROL_2120;
+		buf[1] = ILITEK_TP_CMD_GET_FIRMWARE_VERSION_2120;
+		ret = ilitek_i2c_write_and_read(buf, 2, 10, buf, 0);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		buf[0] = ILITEK_TP_CMD_GET_FIRMWARE_VERSION_2120;
+		ret = ilitek_i2c_write_and_read(buf, 1, 0, buf, 4);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		tp_log_info(" firmware version:%d.%d.%d.%d\n", buf[0], buf[1], buf[2], buf[3]);
+		ilitek_data->firmware_ver[0] = 0;
+		for(i = 1; i < 4; i++)
+		{
+			ilitek_data->firmware_ver[i] = buf[i - 1];
+			if (ilitek_data->firmware_ver[i] == 0xFF) {
+				tp_log_info("firmware version:[%d] = 0xFF so set 0 \n", i);
+				ilitek_data->firmware_ver[1] = 0;
+				ilitek_data->firmware_ver[2] = 0;
+				ilitek_data->firmware_ver[3] = 0;
+				break;
+			}
+		}
+		
+		buf[0] = ILITEK_TP_CMD_READ_DATA_CONTROL_2120;
+		buf[1] = ILITEK_TP_CMD_GET_PROTOCOL_VERSION_2120;
+		ret = ilitek_i2c_write_and_read(buf, 2, 10, buf, 0);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		
+		buf[0] = ILITEK_TP_CMD_GET_PROTOCOL_VERSION_2120;
+		ret = ilitek_i2c_write_and_read(buf, 1, 0, buf, 2);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		ilitek_data->protocol_ver = (((int)buf[0]) << 8) + buf[1];
+		tp_log_info("protocol version:%d.%d\n", buf[0], buf[1]);
+		
+		buf[0] = ILITEK_TP_CMD_READ_DATA_CONTROL_2120;
+		buf[1] = ILITEK_TP_CMD_GET_TP_RESOLUTION;
+		ret = ilitek_i2c_write_and_read(buf, 2, 10, buf, 0);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		buf[0] = ILITEK_TP_CMD_GET_TP_RESOLUTION;
+		ret = ilitek_i2c_write_and_read(buf, 1, 0, buf, 10);
+		if (ret < 0) {
+			goto transfer_err;
+		}
+		
+		ilitek_data->screen_max_x = buf[2];
+		ilitek_data->screen_max_x+= ((int)buf[3]) * 256;
+		ilitek_data->screen_max_y = buf[4];
+		ilitek_data->screen_max_y+= ((int)buf[5]) * 256;
+		ilitek_data->screen_min_x = buf[0];
+		ilitek_data->screen_min_y = buf[1];
+		ilitek_data->x_ch = buf[6];
+		ilitek_data->y_ch = buf[7];
+		ilitek_data->max_tp = buf[8];
+		ilitek_data->keycount = buf[9];
+		if (ilitek_data->keycount > 20) {
+			tp_log_info("exception keycount > 20 is %d set keycount = 0\n", ilitek_data->keycount);
+			ilitek_data->keycount = 0;
+		}
+		tp_log_info("screen_max_x: %d, screen_max_y: %d, screen_min_x: %d, screen_min_y: %d key_count: %d\n",
+			ilitek_data->screen_max_x, ilitek_data->screen_max_y, ilitek_data->screen_min_x, ilitek_data->screen_min_y, ilitek_data->keycount);
+		if (ilitek_data->keycount > 0) {
+			buf[0] = ILITEK_TP_CMD_READ_DATA_CONTROL_2120;
+			buf[1] = ILITEK_TP_CMD_GET_KEY_INFORMATION;
+			ret = ilitek_i2c_write_and_read(buf, 2, 10, buf, 0);
+			if (ret < 0) {
+				goto transfer_err;
+			}
+			buf[0] = ILITEK_TP_CMD_GET_KEY_INFORMATION;
+			ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 29);
+			if (ret < 0) {
+				tp_log_err("ilitek read ILITEK_TP_CMD_GET_KEY_INFORMATION err\n");
+				goto transfer_err;
+			}
+			if (ilitek_data->keycount > 5) {
+				for (i = 0; i < ((ilitek_data->keycount % 5) ? (((ilitek_data->keycount - 5) / 5) + 1) : ((ilitek_data->keycount - 5) / 5)); i++) {
+					tp_log_info("ilitek i = %d\n", i);
+					ret = ilitek_i2c_write_and_read(buf, 0, 10, buf + 29 + 25 * i, 25);
+					if (ret < 0) {
+						tp_log_err("ilitek read ILITEK_TP_CMD_GET_KEY_INFORMATION err\n");
+						goto transfer_err;
+					}
+				}
+			}
+			
+			ilitek_data->key_xlen = (buf[0] << 8) + buf[1];
+			ilitek_data->key_ylen = (buf[2] << 8) + buf[3];
+			tp_log_info("key_xlen: %d, key_ylen: %d\n", ilitek_data->key_xlen, ilitek_data->key_ylen);
+			
+			//print key information
+			for(i = 0; i < ilitek_data->keycount; i++){
+				ilitek_data->keyinfo[i].id = buf[i*5+4]; 
+				ilitek_data->keyinfo[i].x = (buf[i*5+5] << 8) + buf[i*5+6];
+				ilitek_data->keyinfo[i].y = (buf[i*5+7] << 8) + buf[i*5+8];
+				ilitek_data->keyinfo[i].status = 0;
+				tp_log_info("key_id: %d, key_x: %d, key_y: %d, key_status: %d\n", ilitek_data->keyinfo[i].id,
+					ilitek_data->keyinfo[i].x, ilitek_data->keyinfo[i].y, ilitek_data->keyinfo[i].status);
+			}
+		}
+	}
+	if (ilitek_data->max_tp > 40) {
+		tp_log_info("exception max_tp > 40 is %d set max_tp = 10\n", ilitek_data->max_tp);
+		ilitek_data->max_tp = 10;
+	}
+	tp_log_info("tp_min_x: %d, tp_max_x: %d, tp_min_y: %d, tp_max_y: %d, ch_x: %d, ch_y: %d, max_tp: %d, key_count: %d\n",
+		ilitek_data->tp_min_x, ilitek_data->tp_max_x, ilitek_data->tp_min_y, ilitek_data->tp_max_y, ilitek_data->x_ch,
+		ilitek_data->y_ch, ilitek_data->max_tp, ilitek_data->keycount);
+transfer_err:
+	return ret; 
+}
+#ifdef ILITEK_ENABLE_DMA
+static int ilitek_alloc_dma(void) {
+	tpd->dev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	I2CDMABuf_va = (u8 *)dma_alloc_coherent(&tpd->dev->dev, 4096, &I2CDMABuf_pa, GFP_KERNEL);
+	if(!I2CDMABuf_va) {
+		tp_log_err("ilitek [TPD] tpd->dev->dev dma_alloc_coherent error \n");
+		I2CDMABuf_va = (u8 *)dma_alloc_coherent(NULL, 4096, &I2CDMABuf_pa, GFP_KERNEL);
+		if(!I2CDMABuf_va) {
+			tp_log_err("ilitek [TPD] NULL dma_alloc_coherent error\n");
+			return -1;
+		}
+	}
+	memset(I2CDMABuf_va, 0, 4096);
+
+	//ilitek_data->client->ext_flag |= I2C_DMA_FLAG;
+
+	return 0;
+}
+#endif
+int ilitek_main_probe(struct ilitek_ts_data * ilitek_ts_data) {
+	int ret = 0;
+#if ILITEK_PLAT != ILITEK_PLAT_MTK
+	tp_log_info(" client->addr = 0x%x client->irq = %d\n", ilitek_data->client->addr, ilitek_data->client->irq);
+#endif
+	mutex_init(&ilitek_data->ilitek_mutex);
+#ifdef ILITEK_TUNING_NODE	
+	mutex_init(&ilitek_data->ilitek_debug_mutex);
+#endif
+#ifdef ILITEK_ENABLE_DMA
+	ilitek_alloc_dma();
+#endif
+	ret = ilitek_power_on(true);
+	ret = ilitek_request_gpio();
+	ilitek_reset(200);
+	ret = ilitek_read_tp_info();
+	if (ret < 0) {
+		tp_log_err("init read tp info error so exit\n");
+		goto read_info_err;
+	}
+#ifdef ILITEK_USE_MTK_INPUT_DEV
+	ilitek_data->input_dev = tpd->dev;
+#else
+	ilitek_data->input_dev = input_allocate_device();
+#endif
+	if(NULL == ilitek_data->input_dev){
+		tp_log_err("allocate input device, error\n");
+		goto read_info_err;
+	}
+#ifndef ILITEK_UPDATE_FW
+	ret = ilitek_set_input_param();
+	if (ret) {
+		tp_log_err("register input device, error\n");
+		goto input_register_err;
+	}
+	ret = ilitek_request_irq();
+	if (ret) {
+		tp_log_err("ilitek_request_irq, error\n");
+		goto input_register_err;
+	}
+#endif
+	ilitek_data->irq_thread = kthread_run(ilitek_irq_handle_thread, NULL, "ilitek_irq_thread");
+	if (ilitek_data->irq_thread == (struct task_struct*)ERR_PTR){
+		ilitek_data->irq_thread = NULL;
+		tp_log_err("kthread create ilitek_irq_handle_thread, error\n");
+		goto kthread_run_irq_thread_err;
+	}
+#ifdef ILITEK_UPDATE_FW
+	ilitek_data->update_thread = kthread_run(ilitek_update_thread, NULL, "ilitek_update_thread");
+	if (ilitek_data->update_thread == (struct task_struct*)ERR_PTR){
+		ilitek_data->update_thread = NULL;
+		tp_log_err("kthread create ilitek_update_thread, error\n");
+	}
+#endif
+	ilitek_register_resume_suspend();
+
+	ilitek_create_sysfsnode();
+
+#ifdef ILITEK_TOOL
+	ilitek_create_tool_node();
+#endif
+	ilitek_init_netlink();
+
+	ilitek_create_esdandcharge_workqueue();
+	device_init_wakeup(&ilitek_data->client->dev, 1);
+	return 0;
+kthread_run_irq_thread_err:
+#ifndef ILITEK_UPDATE_FW
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	free_irq(ilitek_data->client->irq, ilitek_data);
+#endif
+input_register_err:
+	input_free_device(ilitek_data->input_dev);
+#endif
+read_info_err:
+#if ILITEK_PLAT != ILITEK_PLAT_ALLWIN
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+	ilitek_regulator_release();
+#endif
+#endif
+	ilitek_free_gpio();
+	kfree(ilitek_data);
+	return -ENODEV;
+}
+
+int ilitek_main_remove(struct ilitek_ts_data * ilitek_data) {
+	tp_log_info("\n");
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	free_irq(ilitek_data->client->irq, ilitek_data);
+#endif
+#ifdef ILITEK_TUNING_MESSAGE
+	netlink_kernel_release(ilitek_netlink_sock);
+#endif
+
+#ifdef CONFIG_FB
+	fb_unregister_client(&ilitek_data->fb_notif);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ilitek_data->early_suspend);
+#endif
+	if(ilitek_data->irq_thread != NULL){
+		tp_log_info("irq_thread\n");
+		ilitek_exit_report = true;
+		ilitek_data->irq_trigger = true;
+		wake_up_interruptible(&waiter);
+		kthread_stop(ilitek_data->irq_thread);
+		ilitek_data->irq_thread = NULL;
+	}
+	if (ilitek_data->input_dev) {
+		input_unregister_device(ilitek_data->input_dev);
+		ilitek_data->input_dev = NULL;
+	}
+#ifdef ILITEK_TOOL
+	ilitek_remove_tool_node();
+#endif
+	if (ilitek_data->ilitek_func_kobj) {
+		sysfs_remove_group(ilitek_data->ilitek_func_kobj, ilitek_attribute_group);
+		kobject_put(ilitek_data->ilitek_func_kobj);
+		ilitek_data->ilitek_func_kobj = NULL;
+	}
+#ifdef ILITEK_ESD_PROTECTION
+		if (ilitek_data->esd_wq) {
+			destroy_workqueue(ilitek_data->esd_wq);
+			ilitek_data->esd_wq = NULL;
+		}
+#endif
+#ifdef ILITEK_CHARGER_DETECTION
+		if (ilitek_data->charge_wq) {
+			destroy_workqueue(ilitek_data->charge_wq);
+			ilitek_data->charge_wq = NULL;
+		}
+#endif
+
+#if ILITEK_PLAT != ILITEK_PLAT_ALLWIN
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+		ilitek_regulator_release();
+#endif
+#endif
+
+	ilitek_free_gpio();
+	kfree(ilitek_data);
+#ifdef ILITEK_ENABLE_DMA
+	if(I2CDMABuf_va) {
+		dma_free_coherent(&tpd->dev->dev, 250, I2CDMABuf_va, I2CDMABuf_pa);
+		
+		I2CDMABuf_va = NULL;
+		I2CDMABuf_pa = 0;
+	
+	}
+	
+	
+#endif
+	return 0;
+}
diff --git a/drivers/input/touchscreen/ilitek_platform_init.c b/drivers/input/touchscreen/ilitek_platform_init.c
new file mode 100755
index 000000000000..e86c95c8ad76
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_platform_init.c
@@ -0,0 +1,444 @@
+/*
+ * ILITEK Touch IC driver
+ *
+ * Copyright (C) 2011 ILI Technology Corporation.
+ *
+ * Author: Jijie Wang <jijie_wang@ilitek.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA.
+ * 
+ */
+
+#include "ilitek_ts.h"
+struct ilitek_ts_data * ilitek_data;
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+
+#define TPD_OK (0)
+extern struct tpd_device *tpd;
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
+static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
+
+struct touch_vitual_key_map_t touch_key_point_maping_array[] = {{key_1},{key_2},{key_3},{key_4}};
+static struct i2c_board_info __initdata ilitek_i2c_tpd={
+    I2C_BOARD_INFO(ILITEK_TS_NAME, 0x41)};
+#endif
+
+
+/* probe function is used for matching and initializing input device */
+static int /*__devinit*/ tpd_probe(struct i2c_client *client, const struct i2c_device_id *id) {
+	int ret = 0;
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+	const char *vdd_name = "vtouch";
+	//    const char *vcc_i2c_name = "vcc_i2c";
+#endif
+
+	tp_log_info("TPD probe\n");   
+
+	if (client == NULL) {
+		tp_log_err("i2c client is NULL\n");
+		return -1;
+	}
+	ilitek_data = kzalloc(sizeof(*ilitek_data), GFP_KERNEL);
+	if (ilitek_data == NULL) {
+		tp_log_err("Alloc GFP_KERNEL memory failed.");
+		return -ENOMEM;
+	}
+	
+	memset(ilitek_data, 0, sizeof(struct ilitek_ts_data));
+	ilitek_data->client = client;
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+	ilitek_data->vdd = regulator_get(tpd->tpd_dev, vdd_name);
+	tpd->reg = ilitek_data->vdd;
+	if (IS_ERR(ilitek_data->vdd)) {
+		tp_log_err("regulator_get vdd fail\n");
+		ilitek_data->vdd = NULL;
+		//return -EINVAL;
+	}
+	else {
+		ret = regulator_set_voltage(ilitek_data->vdd, 2800000, 3300000); 
+		if (ret) {
+		tp_log_err("Could not set to 2800mv.\n");
+		}
+	}
+#endif
+
+	ret = ilitek_main_probe(ilitek_data);
+	if (ret == 0) { // If probe is success, then enable the below flag.
+		tpd_load_status = 1;
+	}    
+
+	tp_log_info("TPD probe done\n");
+
+	return TPD_OK;   
+}
+
+static int tpd_detect(struct i2c_client *client, struct i2c_board_info *info) {
+	strcpy(info->type, TPD_DEVICE);    
+
+	return TPD_OK;
+}
+
+static int /*__devexit*/ tpd_remove(struct i2c_client *client) {   
+	tp_log_info("TPD removed\n");
+
+	return ilitek_main_remove(ilitek_data);
+}
+
+
+/* The I2C device list is used for matching I2C device and I2C device driver. */
+static const struct i2c_device_id tpd_device_id[] = {
+	{ILITEK_TS_NAME, 0},
+	{}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, tpd_device_id);
+
+const struct of_device_id touch_dt_match_table[] = {
+	{ .compatible = "mediatek,cap_touch",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, touch_dt_match_table);
+
+static struct i2c_driver tpd_i2c_driver = {
+
+	.driver = {
+		.name = ILITEK_TS_NAME,
+		.of_match_table = of_match_ptr(touch_dt_match_table),
+	},
+	.probe = tpd_probe,
+	.remove = tpd_remove,
+	.id_table = tpd_device_id,
+	.detect = tpd_detect,
+};
+
+static int tpd_local_init(void) {  
+	tp_log_info("TPD init device driver\n");
+
+	if (i2c_add_driver(&tpd_i2c_driver) != 0)
+	{
+		tp_log_err("Unable to add i2c driver.\n");
+
+		return -1;
+	}
+
+	if (tpd_load_status == 0) 
+	{
+		tp_log_err("Add error touch panel driver.\n");
+
+		i2c_del_driver(&tpd_i2c_driver);
+		return -1;
+	}
+#ifndef NO_USE_MTK_ANDROID_SDK_6_UPWARD	
+	if (tpd_dts_data.use_tpd_button) {
+		tpd_button_setting(tpd_dts_data.tpd_key_num, tpd_dts_data.tpd_key_local,
+		tpd_dts_data.tpd_key_dim_local);
+	}
+#else
+	tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
+#endif
+	tpd_type_cap = 1;
+	tp_log_info("TPD init done\n");
+
+	return TPD_OK; 
+}
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+static void tpd_resume(struct early_suspend *h)
+#else
+static void tpd_resume(struct device *h)
+#endif
+{
+	tp_log_info("TPD wake up\n");
+
+	ilitek_resume();
+
+	tp_log_info("TPD wake up done\n");
+}
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+static void tpd_suspend(struct early_suspend *h) 
+#else
+static void tpd_suspend(struct device *h) 
+#endif
+{
+    tp_log_info("TPD enter sleep\n");
+
+    ilitek_suspend();
+
+    tp_log_info("TPD enter sleep done\n");
+} 
+
+static struct tpd_driver_t tpd_device_driver = {
+    .tpd_device_name = ILITEK_TS_NAME,
+    .tpd_local_init = tpd_local_init,
+    .suspend = tpd_suspend,
+    .resume = tpd_resume,
+	.tpd_have_button = 1,
+	//.tpd_have_button = 0,
+};
+
+static int __init ilitek_touch_driver_init(void) {
+    tp_log_info("touch panel driver init\n");
+        
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+	i2c_register_board_info(2, &ilitek_i2c_tpd, 1);
+#else
+    tpd_get_dts_info();
+#endif
+    if (tpd_driver_add(&tpd_device_driver) < 0) {
+        tp_log_err("TPD add TP driver failed\n");
+    }
+     
+    return 0;
+}
+ 
+static void __exit ilitek_touch_driver_exit(void) {
+    tp_log_info("touch panel driver exit\n");
+    
+    tpd_driver_remove(&tpd_device_driver);
+}
+
+#else
+
+
+/* probe function is used for matching and initializing input device */
+static int /*__devinit*/ ilitek_touch_driver_probe(struct i2c_client *client,
+	const struct i2c_device_id *id) {
+#if ILITEK_PLAT != ILITEK_PLAT_ALLWIN
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+	int ret = 0;
+	const char *vdd_name = "vdd";
+	const char *vcc_i2c_name = "vcc_i2c";
+#endif
+#endif
+	tp_log_info("*** %s ***\n", __func__);
+
+	if (client == NULL) {
+		tp_log_err("i2c client is NULL\n");
+		return -1;
+	}
+	
+    ilitek_data = kzalloc(sizeof(struct ilitek_ts_data), GFP_KERNEL);
+    if (ilitek_data == NULL) {
+        tp_log_err("Alloc GFP_KERNEL memory failed.");
+        return -ENOMEM;
+    }
+	memset(ilitek_data, 0, sizeof(struct ilitek_ts_data));
+	ilitek_data->client = client;
+
+#if ILITEK_PLAT != ILITEK_PLAT_ALLWIN
+#ifdef ILITEK_ENABLE_REGULATOR_POWER_ON
+	ilitek_data->vdd = regulator_get(&client->dev, vdd_name);
+	if (IS_ERR(ilitek_data->vdd)) {
+		tp_log_err("regulator_get vdd fail\n");
+		ilitek_data->vdd = NULL;
+		//return -EINVAL;
+	}
+	else {
+		ret = regulator_set_voltage(ilitek_data->vdd, 2800000, 3300000); 
+		if (ret) {
+			tp_log_err("Could not set to 2800mv.\n");
+		}
+	}
+	ilitek_data->vdd_i2c = regulator_get(&client->dev, vcc_i2c_name);
+	if (IS_ERR(ilitek_data->vdd_i2c)) {
+		tp_log_err("regulator_get vdd_i2c fail\n");
+		ilitek_data->vdd_i2c = NULL;
+		//return -EINVAL;
+	}
+	else {
+		ret = regulator_set_voltage(ilitek_data->vdd_i2c, 1800000, 1800000);  
+		if (ret) {
+			tp_log_err("Could not set to 1800mv.\n");
+		}
+	}
+#endif
+#endif
+	return ilitek_main_probe(ilitek_data);
+}
+
+
+/* remove function is triggered when the input device is removed from input sub-system */
+static int ilitek_touch_driver_remove(struct i2c_client *client)
+{
+	tp_log_info("*** %s ***\n", __func__);
+
+	return ilitek_main_remove(ilitek_data);
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id ilitek_touch_match_table[] = {
+	{ .compatible = "tchip,ilitek",},
+	{},
+};
+#endif
+
+static const struct i2c_device_id ilitek_touch_device_id[] = {
+	{ILITEK_TS_NAME, 0},
+	{}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, ilitek_touch_device_id);
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ilitekts_acpi_id[] = {
+	{ "ILTK0001", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, ilitekts_acpi_id);
+#endif
+
+static struct i2c_driver ilitek_touch_device_driver = {
+	.driver = {
+		.name = ILITEK_TS_NAME,
+		.owner = THIS_MODULE,
+		#ifdef CONFIG_OF
+		.of_match_table = ilitek_touch_match_table,
+		#endif
+		#ifdef CONFIG_ACPI
+		.acpi_match_table = ACPI_PTR(ilitekts_acpi_id),
+		#endif
+	},
+	.probe = ilitek_touch_driver_probe,
+	.remove = ilitek_touch_driver_remove,
+	.id_table = ilitek_touch_device_id,
+};
+
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+
+static const unsigned short normal_i2c[2] = {0x41,I2C_CLIENT_END};
+
+struct ctp_config_info config_info = {	
+	.input_type = CTP_TYPE,	
+	.name = NULL,	
+	.int_number = 0,
+};
+
+static int twi_id = 0;
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+static int exchange_x_y_flag = 0;
+
+static int ctp_get_system_config(void) {   
+	twi_id = config_info.twi_id;
+	screen_max_x = config_info.screen_max_x;
+	screen_max_y = config_info.screen_max_y;
+	tp_log_info("Ilitek: screen_max_x = %d\n",screen_max_x);
+	revert_x_flag = config_info.revert_x_flag;
+	revert_y_flag = config_info.revert_y_flag;
+	exchange_x_y_flag = config_info.exchange_x_y_flag;
+	if( (screen_max_x == 0) || (screen_max_y == 0)){
+		tp_log_err("%s:read config error!\n",__func__);
+		return -1;
+	}
+	return 0;
+}
+
+int ctp_ts_detect(struct i2c_client *client, struct i2c_board_info *info) {
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr) {
+		strlcpy(info->type, ILITEK_TS_NAME, I2C_NAME_SIZE);
+		return 0;
+	}
+	else {
+		return -ENODEV;
+	}
+}
+
+static struct i2c_board_info i2c_info_dev =  {
+	I2C_BOARD_INFO(ILITEK_TS_NAME, 0x41),
+	.platform_data	= NULL,
+};
+
+static int add_ctp_device(void) {
+	struct i2c_adapter *adap;
+
+	//script_parser_fetch("ctp_para", "ctp_twi_id", &twi_id, 1);
+
+	adap = i2c_get_adapter(twi_id);
+	i2c_new_device(adap, &i2c_info_dev);
+
+return 0;
+}
+
+static int ilitek_init_allwin(void) {
+	int ret = 0;
+	if (input_fetch_sysconfig_para(&(config_info.input_type))) {
+		tp_log_err("Ilitek:  ctp_fetch_sysconfig_para err.\n");			
+		return -1;
+	}
+	else {
+		ret = input_init_platform_resource(&(config_info.input_type));
+		if (0 != ret) {
+			tp_log_err("Ilitek: ctp_ops.init_platform_resource err. \n");
+		}
+	}	
+
+	if(config_info.ctp_used == 0) {       
+		tp_log_err("Ilitek: *** if use ctp,please put the sys_config.fex ctp_used set to 1. \n");        
+		return -1;	
+	}
+
+	if(ctp_get_system_config() < 0) {            
+		tp_log_err("Ilitek: %s:read config fail!\n",__func__);            
+		//return ret;    
+	}
+
+	add_ctp_device();
+	ilitek_touch_device_driver.address_list = normal_i2c; 
+	ilitek_touch_device_driver.detect = ctp_ts_detect;
+	//ilitek_touch_device_driver.suspend = ilitek_suspend_allwin;
+	//ilitek_touch_device_driver.resume = ilitek_resume_allwin;
+	return 0;
+}
+#endif
+
+static int __init ilitek_touch_driver_init(void) {
+	int ret;
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+	ret = ilitek_init_allwin();
+	if (ret < 0) {
+	    tp_log_err("ilitek_init_allwin failed.\n");
+	    return -ENODEV;
+	}
+#endif
+	/* register driver */
+	ret = i2c_add_driver(&ilitek_touch_device_driver);
+	if (ret < 0) {
+	    tp_log_err("add touch device driver i2c driver failed.\n");
+	    return -ENODEV;
+	}
+	tp_log_info("add touch device driver i2c driver.\n");
+
+	return ret;
+}
+
+static void __exit ilitek_touch_driver_exit(void) {
+	tp_log_info("remove touch device driver i2c driver.\n");
+
+	i2c_del_driver(&ilitek_touch_device_driver);
+}
+#endif
+module_init(ilitek_touch_driver_init);
+module_exit(ilitek_touch_driver_exit);
+MODULE_AUTHOR("ILITEK");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/ilitek_tool.c b/drivers/input/touchscreen/ilitek_tool.c
new file mode 100755
index 000000000000..0e447f467bc9
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_tool.c
@@ -0,0 +1,2602 @@
+/*
+ * ILITEK Touch IC driver
+ *
+ * Copyright (C) 2011 ILI Technology Corporation.
+ *
+ * Author: Jijie Wang <jijie_wang@ilitek.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA.
+ * 
+ */
+
+#include "ilitek_ts.h"
+#ifdef ILITEK_TOOL
+// device data
+struct dev_data {
+	// device number
+	dev_t devno;
+	// character device
+	struct cdev cdev;
+	// class device
+	struct class *class;
+};
+
+static struct dev_data ilitek_dev;
+static struct proc_dir_entry * ilitek_proc;
+struct proc_dir_entry *ilitek_proc_entry;
+#ifdef ILITEK_TUNING_NODE	
+	static struct proc_dir_entry * ilitek_proc_debug;
+#endif
+static char ilitek_hex_path[256] = "/data/local/tmp/2511dftest.hex";
+
+// define the application command
+#define ILITEK_IOCTL_BASE                       100
+#define ILITEK_IOCTL_I2C_WRITE_DATA             _IOWR(ILITEK_IOCTL_BASE, 0, unsigned char*)
+#define ILITEK_IOCTL_I2C_WRITE_LENGTH           _IOWR(ILITEK_IOCTL_BASE, 1, int)
+#define ILITEK_IOCTL_I2C_READ_DATA              _IOWR(ILITEK_IOCTL_BASE, 2, unsigned char*)
+#define ILITEK_IOCTL_I2C_READ_LENGTH            _IOWR(ILITEK_IOCTL_BASE, 3, int)
+#define ILITEK_IOCTL_USB_WRITE_DATA             _IOWR(ILITEK_IOCTL_BASE, 4, unsigned char*)
+#define ILITEK_IOCTL_USB_WRITE_LENGTH           _IOWR(ILITEK_IOCTL_BASE, 5, int)
+#define ILITEK_IOCTL_USB_READ_DATA              _IOWR(ILITEK_IOCTL_BASE, 6, unsigned char*)
+#define ILITEK_IOCTL_USB_READ_LENGTH            _IOWR(ILITEK_IOCTL_BASE, 7, int)
+
+#define ILITEK_IOCTL_DRIVER_INFORMATION		    _IOWR(ILITEK_IOCTL_BASE, 8, int)
+#define ILITEK_IOCTL_USB_UPDATE_RESOLUTION      _IOWR(ILITEK_IOCTL_BASE, 9, int)
+
+#define ILITEK_IOCTL_I2C_INT_FLAG	            _IOWR(ILITEK_IOCTL_BASE, 10, int)
+#define ILITEK_IOCTL_I2C_UPDATE                 _IOWR(ILITEK_IOCTL_BASE, 11, int)
+#define ILITEK_IOCTL_STOP_READ_DATA             _IOWR(ILITEK_IOCTL_BASE, 12, int)
+#define ILITEK_IOCTL_START_READ_DATA            _IOWR(ILITEK_IOCTL_BASE, 13, int)
+#define ILITEK_IOCTL_GET_INTERFANCE				_IOWR(ILITEK_IOCTL_BASE, 14, int)//default setting is i2c interface
+#define ILITEK_IOCTL_I2C_SWITCH_IRQ				_IOWR(ILITEK_IOCTL_BASE, 15, int)
+
+#define ILITEK_IOCTL_UPDATE_FLAG				_IOWR(ILITEK_IOCTL_BASE, 16, int)
+#define ILITEK_IOCTL_I2C_UPDATE_FW				_IOWR(ILITEK_IOCTL_BASE, 18, int)
+#define ILITEK_IOCTL_RESET						_IOWR(ILITEK_IOCTL_BASE, 19, int)
+#define ILITEK_IOCTL_INT_STATUS						_IOWR(ILITEK_IOCTL_BASE, 20, int)
+#ifdef ILITEK_TUNING_MESSAGE
+extern bool ilitek_debug_flag;
+
+#define ILITEK_IOCTL_DEBUG_SWITCH						_IOWR(ILITEK_IOCTL_BASE, 21, int)
+#endif
+
+
+#ifdef ILITEK_TUNING_NODE	
+	#define ILITEK_IOCTL_DEBUG_NODE_SWITCH						_IOWR(ILITEK_IOCTL_BASE, 65, int)
+#endif
+
+
+
+static int ilitek_file_open(struct inode *inode, struct file *filp) {
+	ilitek_data->operation_protection = true;
+	tp_log_info("operation_protection = %d\n", ilitek_data->operation_protection);
+	return 0;
+}
+static ssize_t ilitek_file_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos) {
+	int ret;
+	unsigned char buffer[512]={0};
+	// check the buffer size whether it exceeds the local buffer size or not
+	if (count > 512) {
+		tp_log_err("buffer exceed 512 bytes\n");
+		//return -1;
+	}
+
+	// copy data from user space
+	ret = copy_from_user(buffer, buf, count-1);
+	if (ret < 0) {
+		tp_log_err("copy data from user space, failed");
+		return -1;
+	}
+
+	if (buffer[count -2] == 'I' && (count == 20 || count == 52) && buffer[0] == 0x77 && buffer[1] == 0x77) {
+		
+		tp_log_info("IOCTL_WRITE CMD = %d\n", buffer[2]);
+		switch (buffer[2]) {
+			case 13:
+				//ilitek_irq_enable();
+				tp_log_info("ilitek_irq_enable. do nothing\n");
+				break;
+			case 12:
+				//ilitek_irq_disable();
+				tp_log_info("ilitek_irq_disable. do nothing\n");
+				break;
+			case 19:
+				ilitek_reset(200);
+				break;
+#ifdef ILITEK_TUNING_MESSAGE
+			case 21:
+				tp_log_info("ilitek The ilitek_debug_flag = %d.\n", buffer[3]);
+				if (buffer[3] == 0) {
+					ilitek_debug_flag = false;
+				}
+				else if (buffer[3] == 1) {
+					ilitek_debug_flag = true;
+				}
+				break;
+#endif
+			case 15:
+				if (buffer[3] == 0) {
+					ilitek_irq_disable();
+					tp_log_info("ilitek_irq_disable.\n");
+				}
+				else {
+					ilitek_irq_enable();
+					tp_log_info("ilitek_irq_enable.\n");
+				}
+				break;
+			case 16:
+				ilitek_data->operation_protection = buffer[3];
+				tp_log_info("ilitek_data->operation_protection = %d\n", ilitek_data->operation_protection);
+				break;
+			case 18:
+				ret = ilitek_i2c_write(&buffer[3], 33);
+				if (ret < 0) {
+					tp_log_err("i2c write error, ret %d, addr %x \n", ret,ilitek_data->client->addr);
+					return ret;
+				}
+				return 0;
+				break;
+				default:
+					return -1;
+		}
+	}
+	if (buffer[count -2] == 'W') {
+		ret = ilitek_i2c_write(buffer, count -2);
+		if(ret < 0){
+			tp_log_err("i2c write error, ret %d, addr %x \n", ret,ilitek_data->client->addr);
+			return ret;
+		}
+	}
+	else if (strcmp(buffer, "dbg_debug") == 0) {
+		ilitek_log_level_value = ILITEK_DEBUG_LOG_LEVEL;
+		tp_log_info("ilitek_log_level_value = %d.\n", ilitek_log_level_value);
+	}
+	else if (strcmp(buffer, "dbg_info") == 0) {
+		ilitek_log_level_value = ILITEK_INFO_LOG_LEVEL;
+		tp_log_info("ilitek_log_level_value = %d.\n", ilitek_log_level_value);
+	}
+	else if (strcmp(buffer, "dbg_err") == 0) {
+		ilitek_log_level_value = ILITEK_ERR_LOG_LEVEL;
+		tp_log_info("ilitek_log_level_value = %d.\n", ilitek_log_level_value);
+	}
+	#ifdef ILITEK_TUNING_MESSAGE
+	else if(strcmp(buffer, "truning_dbg_flag") == 0){
+		ilitek_debug_flag = !ilitek_debug_flag;
+		tp_log_info(" %s debug_flag message(%X).\n", ilitek_debug_flag?"Enabled":"Disabled",ilitek_debug_flag);
+	}
+	#endif
+	else if(strcmp(buffer, "irq_status") == 0){
+		tp_log_info("gpio_get_value(i2c.irq_gpio) = %d.\n", gpio_get_value(ilitek_data->irq_gpio));
+	}
+	else if(strcmp(buffer, "enable") == 0){
+		enable_irq(ilitek_data->client->irq);
+		tp_log_info("irq enable\n");
+	}else if(strcmp(buffer, "disable") == 0){
+		disable_irq(ilitek_data->client->irq);
+		tp_log_info("irq disable\n");
+	}
+	else if(strcmp(buffer, "info") == 0){
+		ilitek_read_tp_info();
+	}
+	else if(strcmp(buffer, "reset") == 0){
+		ilitek_reset(200);
+	}
+	tp_log_debug("ilitek return count = %d\n", (int)count);
+	return count;
+}
+
+/*
+   description
+   ioctl function for character device driver
+   prarmeters
+   inode
+   file node
+   filp
+   file pointer
+   cmd
+   command
+   arg
+   arguments
+   return
+   status
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+static long ilitek_file_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+static int  ilitek_file_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	static unsigned char buffer[64]={0};
+	static int len = 0, i;
+	int ret;
+	// parsing ioctl command
+	switch(cmd){
+		case ILITEK_IOCTL_I2C_WRITE_DATA:
+			ret = copy_from_user(buffer, (unsigned char*)arg, len);
+			if(ret < 0){
+				tp_log_err("copy data from user space, failed\n");
+				return -1;
+			}
+			ret = ilitek_i2c_write(buffer, len);
+			if(ret < 0){
+				tp_log_err("i2c write, failed\n");
+				return -1;
+			}
+			break;
+		case ILITEK_IOCTL_I2C_READ_DATA:
+			ret = ilitek_i2c_read(buffer, len);
+			if(ret < 0){
+				tp_log_err("i2c read, failed\n");
+				return -1;
+			}
+			ret = copy_to_user((unsigned char*)arg, buffer, len);
+			if(ret < 0){
+				tp_log_err("copy data to user space, failed\n");
+				return -1;
+			}
+			break;
+		case ILITEK_IOCTL_I2C_WRITE_LENGTH:
+		case ILITEK_IOCTL_I2C_READ_LENGTH:
+			len = arg;
+			break;
+		case ILITEK_IOCTL_DRIVER_INFORMATION:
+			for (i = 0; i < 7; i++) {
+				buffer[i] = ilitek_driver_information[i];
+			}
+			ret = copy_to_user((unsigned char*)arg, buffer, 7);
+			break;
+		case ILITEK_IOCTL_I2C_UPDATE:
+			break;
+		case ILITEK_IOCTL_I2C_INT_FLAG:
+			buffer[0] = !(gpio_get_value(ilitek_data->irq_gpio));
+			ret = copy_to_user((unsigned char*)arg, buffer, 1);
+			if (ret < 0) {
+				tp_log_err("copy data to user space, failed\n");
+				return -1;
+			}
+			tp_log_debug("ILITEK_IOCTL_I2C_INT_FLAG = %d.\n", buffer[0]);
+			break;
+		case ILITEK_IOCTL_START_READ_DATA:
+			//ilitek_irq_enable();
+			tp_log_info("ILITEK_IOCTL_START_READ_DATA do nothing.\n");
+			break;
+		case ILITEK_IOCTL_STOP_READ_DATA:
+			//ilitek_irq_disable();
+			tp_log_info("ILITEK_IOCTL_STOP_READ_DATA do nothing.\n");
+			break;
+		case ILITEK_IOCTL_RESET:
+			ilitek_reset(200);
+			break;
+		case ILITEK_IOCTL_INT_STATUS:
+			put_user(gpio_get_value(ilitek_data->irq_gpio), (int *)arg);
+			break;	
+	#ifdef ILITEK_TUNING_MESSAGE
+		case ILITEK_IOCTL_DEBUG_SWITCH:
+			ret = copy_from_user(buffer, (unsigned char*)arg, 1);
+			tp_log_info("ilitek The debug_flag = %d.\n", buffer[0]);
+			if (buffer[0] == 0) {
+				ilitek_debug_flag = false;
+			}
+			else if (buffer[0] == 1) {
+				ilitek_debug_flag = true;
+			}
+			break;
+	#endif
+		case ILITEK_IOCTL_I2C_SWITCH_IRQ:
+			ret = copy_from_user(buffer, (unsigned char*)arg, 1);
+			if (buffer[0] == 0)
+			{
+				tp_log_info("ilitek_i2c_irq_disable .  \n");
+				ilitek_irq_disable();
+			}
+			else
+			{
+				tp_log_info("ilitek_i2c_irq_enable. \n");
+				ilitek_irq_enable();
+			}
+			break;
+		case ILITEK_IOCTL_UPDATE_FLAG:
+			ilitek_data->operation_protection = arg;
+			tp_log_info("operation_protection = %d\n", ilitek_data->operation_protection);
+			break;
+		case ILITEK_IOCTL_I2C_UPDATE_FW:
+			ret = copy_from_user(buffer, (unsigned char*)arg, 35);
+			if(ret < 0){
+				tp_log_err("copy data from user space, failed\n");
+				return -1;
+			}
+			ret = ilitek_i2c_write(buffer, buffer[34]);
+			if(ret < 0){
+				tp_log_err("i2c write, failed\n");
+				return -1;
+			}
+			break;
+
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+/*
+   description
+   read function for character device driver
+   prarmeters
+   filp
+   file pointer
+   buf
+   buffer
+   count
+   buffer length
+   f_pos
+   offset
+   return
+   status
+ */
+static ssize_t ilitek_file_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+	unsigned char *tmp;
+	int ret;
+	long rc;
+
+	//tp_log_info("%s enter count = %d\n", __func__, count);
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = kmalloc(count, GFP_KERNEL);
+	if (tmp == NULL)
+		return -ENOMEM;
+
+	ret = ilitek_i2c_read(tmp, count);
+	if (ret < 0) {
+		tp_log_err("i2c read error, ret %d,addr %x \n", ret, ilitek_data->client->addr);
+	}
+	rc = copy_to_user(buf, tmp, count);
+
+	kfree(tmp);
+	return ret > 0 ? count : ret;
+}
+
+
+/*
+   description
+   close function
+   prarmeters
+   inode
+   inode
+   filp
+   file pointer
+   return
+   status
+ */
+static int ilitek_file_close(struct inode *inode, struct file *filp)
+{
+	ilitek_data->operation_protection = false;
+	tp_log_info("operation_protection = %d\n", ilitek_data->operation_protection);
+	return 0;
+}
+
+// declare file operations
+struct file_operations ilitek_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	.unlocked_ioctl = ilitek_file_ioctl,
+#else
+	.ioctl = ilitek_file_ioctl,
+#endif
+	.read = ilitek_file_read,
+	.write = ilitek_file_write,
+	.open = ilitek_file_open,
+	.release = ilitek_file_close,
+};
+
+#ifdef ILITEK_TUNING_NODE	
+static int ilitek_debug_file_open(struct inode *inode, struct file *filp) {
+	tp_log_info("\n");
+	ilitek_data->send_data = true;
+	return 0;
+}
+
+static ssize_t ilitek_debug_file_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos) {
+	unsigned char buffer[512]={0};
+	int ret = 0;
+	tp_log_debug("\n");
+	// check the buffer size whether it exceeds the local buffer size or not
+	if (count > 512) {
+		tp_log_err("buffer exceed 512 bytes\n");
+		//return -1;
+	}
+
+	// copy data from user space
+	ret = copy_from_user(buffer, buf, count-1);
+	if (ret < 0) {
+		tp_log_err("copy data from user space, failed");
+		return -1;
+	}
+	if(strcmp(buffer, "dbg_flag") == 0){
+		ilitek_data->debug_node_open = !ilitek_data->debug_node_open;
+		tp_log_info(" %s debug_flag message(%X).\n", ilitek_data->debug_node_open?"Enabled":"Disabled",ilitek_data->debug_node_open);
+	}
+	return count;
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+static long ilitek_file_debug_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+static int  ilitek_file_debug_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	static unsigned char buffer[64]={0};
+	int ret;
+	// parsing ioctl command
+	switch(cmd){
+		case ILITEK_IOCTL_DEBUG_NODE_SWITCH:
+			ret = copy_from_user(buffer, (unsigned char*)arg, 1);
+			if (ret < 0) {
+				tp_log_err("copy data from user space, failed");
+			}
+			else {
+				tp_log_info("ilitek The debug_flag = %d.\n", buffer[0]);
+				if (buffer[0] == 0) {
+					ilitek_data->debug_node_open = false;
+				}
+				else if (buffer[0] == 1) {
+					ilitek_data->debug_node_open = true;
+				}
+			}
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+
+static unsigned int ilitek_debug_file_poll(struct file *filp, poll_table *wait)
+{
+    unsigned int mask = 0;
+    
+    poll_wait(filp, &ilitek_data->inq,  wait);
+ 
+    
+    if (ilitek_data->have_data)         
+
+    mask |= POLLIN | POLLRDNORM;  /* readable */
+
+
+    return mask;
+}
+
+static loff_t ilitek_debug_file_llseek(struct file *filp, loff_t offset, int whence)
+{ 
+    loff_t newpos;
+	tp_log_debug("\n");
+    switch(whence) {
+      case 0: /* SEEK_SET */
+        newpos = offset;
+        break;
+
+      case 1: /* SEEK_CUR */
+        newpos = filp->f_pos + offset;
+        break;
+
+      case 2: /* SEEK_END */
+        //newpos = MEMDEV_SIZE -1 + offset;
+        break;
+
+      default: /* can't happen */
+        return -EINVAL;
+    }
+    //if ((newpos<0) || (newpos>MEMDEV_SIZE))
+    //    return -EINVAL;
+        
+    filp->f_pos = newpos;
+    return newpos;
+
+}
+
+static ssize_t ilitek_debug_file_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)
+{
+  unsigned long p =  *ppos;
+  unsigned int count = size;
+  unsigned char tmpbuf[64] = {0};
+  size_t ret = 0;
+  while (!ilitek_data->have_data)
+  {
+        if (filp->f_flags & O_NONBLOCK)
+            return -EAGAIN;
+    
+    wait_event_interruptible(ilitek_data->inq,ilitek_data->have_data);
+  }
+  mutex_lock(&ilitek_data->ilitek_debug_mutex);
+  if (!ilitek_data->ic_2120) {
+	  if (ilitek_data->debug_buf[0] == 0xDB && ilitek_data->debug_buf[1] >= 2) {
+		  ilitek_data->debug_buf[ilitek_data->debug_buf[1]] = '\0';
+		  sprintf(tmpbuf, "%s", &ilitek_data->debug_buf[2]);
+	  }
+	  if (copy_to_user(buf, tmpbuf, 64))
+	  {
+	    ret =  - EFAULT;
+	  }
+	  else
+	  {
+	    *ppos += count;
+	    ret = count;
+	   
+	    tp_log_debug("read %d bytes(s) from %ld\n", count, p);
+	  }
+  }
+  else
+  {
+	  if (copy_to_user(buf, ilitek_data->debug_buf, 64))
+	  {
+	    ret =  - EFAULT;
+	  }
+	  else
+	  {
+	    *ppos += count;
+	    ret = count;
+	   
+	    tp_log_debug("read %d bytes(s) from %ld\n", count, p);
+	  }
+  }
+  ilitek_data->have_data = false;
+  ilitek_data->send_data = true;
+  mutex_unlock(&ilitek_data->ilitek_debug_mutex);
+  if (!ilitek_data->ic_2120) {
+  	return (ilitek_data->debug_buf[1] - 2);
+  }
+  else
+  {
+	  return ret;
+  }
+}
+
+/*
+   description
+   close function
+   prarmeters
+   inode
+   inode
+   filp
+   file pointer
+   return
+   status
+ */
+static int ilitek_debug_file_close(struct inode *inode, struct file *filp)
+{
+	tp_log_info("\n");
+	return 0;
+}
+
+// declare file operations
+struct file_operations ilitek_debug_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+		.unlocked_ioctl = ilitek_file_debug_ioctl,
+#else
+		.ioctl = ilitek_file_debug_ioctl,
+#endif
+	.read = ilitek_debug_file_read,
+	.write = ilitek_debug_file_write,
+	.open = ilitek_debug_file_open,
+	.release = ilitek_debug_file_close,
+	.poll = ilitek_debug_file_poll,
+	.llseek = ilitek_debug_file_llseek,
+};
+#endif
+
+static int short_test_result = 0;
+static int open_test_result = 0;
+static int allnode_test_result = 0;
+static int ilitek_short_threshold = 7;
+static int ilitek_open_threshold = 0;//200;
+static int ilitek_allnode_max_threshold = 8500;
+static int ilitek_allnode_min_threshold = 0;//1500;
+static int ilitek_open_txdeltathrehold = 120;
+static int ilitek_open_rxdeltathrehold = 120;
+static int ilitek_allnodetestw1 = 140;
+static int ilitek_allnodetestw2 = 140;
+static int ilitek_allnodemodule= 20;
+static int ilitek_allnodetx= 3;
+
+static int ilitek_printsensortestdata = 1;
+static char sensor_test_data_path[256] = "/data/local/tmp/";
+static char sensor_test_data_path_tmp[256] = "/data/local/tmp/";
+
+static int noisefre_start = 30;
+static int noisefre_end = 120;
+static int noisefre_step = 5;
+static char noisefre_data_path[256] = "/data/local/tmp/";
+static char noisefre_data_path_tmp[256] = "/data/local/tmp/";
+static void ilitek_printf_sensortest_data(int * short_xdata1, int * short_xdata2, int * short_ydata1,
+	int * short_ydata2, int * open_data, int * allnode_data, struct seq_file *m) {
+	int j = 0, len = 0;
+	struct file *filp;
+	mm_segment_t fs;
+	unsigned char buf[128];
+    struct  timeval   time_now;
+	struct rtc_time tm; 
+    do_gettimeofday(&time_now);
+	rtc_time_to_tm(time_now.tv_sec, &tm); 
+	tp_log_info("%d_%d_%d_%d_%d_%d\n", (tm.tm_year + 1900), tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	if (short_test_result == 0 && open_test_result == 0 && allnode_test_result ==0) {
+		len = sprintf(buf, "ilitek_sensortest_%d%02d%02d%02d%02d%02d_pass.csv", (tm.tm_year + 1900), tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	}
+	else {
+		len = sprintf(buf, "ilitek_sensortest_%d%02d%02d%02d%02d%02d_fail.csv", (tm.tm_year + 1900), tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	}
+	for(j = 0; j < 256; j++) {
+		sensor_test_data_path_tmp[j] = sensor_test_data_path[j];
+	}
+	strcat(sensor_test_data_path, buf);
+	tp_log_info("sensor_test_data_path = %s\n", sensor_test_data_path);
+	filp = filp_open(sensor_test_data_path, O_CREAT | O_WRONLY, 0777);
+	if(IS_ERR(filp)) {
+		tp_log_err("save sensor test  File Open Error path = %s\n", sensor_test_data_path);
+	}
+	else {
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+
+		len = sprintf(buf, "short\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		len = sprintf(buf, "short_threshold = %d\n", ilitek_short_threshold);
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		for (j = 0; j < ilitek_data->x_ch; j++) {
+			len = sprintf(buf, "%d,", short_xdata1[j]);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		}
+		len = sprintf(buf, "\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		for (j = 0; j < ilitek_data->x_ch; j++) {
+			len = sprintf(buf, "%d,", short_xdata2[j]);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		}
+		len = sprintf(buf, "\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		if (!(ilitek_data->ic_2120)) {
+			len = sprintf(buf, "\n");
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			for (j = 0; j < ilitek_data->y_ch; j++) {
+				len = sprintf(buf, "%d,", short_ydata1[j]);
+				filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			}
+			len = sprintf(buf, "\n");
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			for (j = 0; j < ilitek_data->y_ch; j++) {
+				len = sprintf(buf, "%d,", short_ydata2[j]);
+				filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			}
+		}
+		
+		len = sprintf(buf, "\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		len = sprintf(buf, "open:\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		len = sprintf(buf, "open_threshold = %d\n", ilitek_open_threshold);
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		if (!(ilitek_data->ic_2120)) {
+			len = sprintf(buf, "open_txdeltathrehold = %d\n", ilitek_open_txdeltathrehold);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			len = sprintf(buf, "open_rxdeltathrehold = %d\n", ilitek_open_rxdeltathrehold);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		}
+		for (j = 0; j < ilitek_data->y_ch * ilitek_data->x_ch; j++) {
+			len = sprintf(buf, "%d,", open_data[j]);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			if((j + 1) % ilitek_data->x_ch == 0) {
+				len = sprintf(buf, "\n");
+				filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			}
+		}
+		len = sprintf(buf, "\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		len = sprintf(buf, "allnode:\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		len = sprintf(buf, "allnode_max_threshold = %d\n", ilitek_allnode_max_threshold);
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		len = sprintf(buf, "allnode_min_threshold = %d\n", ilitek_allnode_min_threshold);
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		if (!(ilitek_data->ic_2120)) {
+			len = sprintf(buf, "allnodetestw1 = %d\n", ilitek_allnodetestw1);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			len = sprintf(buf, "allnodetestw2 = %d\n", ilitek_allnodetestw2);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			len = sprintf(buf, "allnodemodule = %d\n", ilitek_allnodemodule);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			len = sprintf(buf, "allnodetx = %d\n", ilitek_allnodetx);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		}
+		for (j = 0; j < ilitek_data->y_ch * ilitek_data->x_ch; j++) {
+			len = sprintf(buf, "%d,", allnode_data[j]);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			if((j + 1) % ilitek_data->x_ch == 0) {
+				len = sprintf(buf, "\n");
+				filp->f_op->write(filp, buf, len, &(filp->f_pos));
+			}
+		}
+		len = sprintf(buf, "\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+
+		set_fs(fs);
+	}
+	for(j = 0; j < 256; j++) {
+		sensor_test_data_path[j] = sensor_test_data_path_tmp[j];
+	}
+
+	if (ilitek_printsensortestdata) {
+		if (short_test_result == 0 && open_test_result == 0 && allnode_test_result ==0) {
+			printk("pass\n");
+		}
+		else {
+			printk("fail\n");
+		}
+		
+		printk("%s", "\n");
+		printk("%s", "short\n");
+		printk("short_threshold = %d\n", ilitek_short_threshold);
+		
+		for (j = 0; j < ilitek_data->x_ch; j++) {
+			printk("%d,", short_xdata1[j]);
+		}
+		printk("%s", "\n");
+		for (j = 0; j < ilitek_data->x_ch; j++) {
+			printk( "%d,", short_xdata2[j]);
+		}
+		printk( "%s", "\n");
+		if (!(ilitek_data->ic_2120)) {
+			printk( "%s", "\n");
+			for (j = 0; j < ilitek_data->y_ch; j++) {
+				printk( "%d,", short_ydata1[j]);
+			}
+			printk( "%s", "\n");
+			for (j = 0; j < ilitek_data->y_ch; j++) {
+				printk( "%d,", short_ydata2[j]);
+			}
+		}
+		
+		printk( "%s", "\n");
+		printk( "%s", "open:\n");
+		printk( "open_threshold = %d\n", ilitek_open_threshold);
+		if (!(ilitek_data->ic_2120)) {
+			printk( "open_txdeltathrehold = %d\n", ilitek_open_txdeltathrehold);
+			printk( "open_rxdeltathrehold = %d\n", ilitek_open_rxdeltathrehold);
+		}
+		for (j = 0; j < ilitek_data->y_ch * ilitek_data->x_ch; j++) {
+			printk( "%d,", open_data[j]);
+			if((j + 1) % ilitek_data->x_ch == 0) {
+				printk( "%s", "\n");
+			}
+		}
+		printk( "%s", "\n");
+		printk( "%s", "allnode:\n");
+		printk( "allnode_max_threshold = %d\n", ilitek_allnode_max_threshold);
+		printk( "allnode_min_threshold = %d\n", ilitek_allnode_min_threshold);
+		if (!(ilitek_data->ic_2120)) {
+			printk( "allnodetestw1 = %d\n", ilitek_allnodetestw1);
+			printk( "allnodetestw2 = %d\n", ilitek_allnodetestw2);
+			printk( "allnodemodule = %d\n", ilitek_allnodemodule);
+			printk( "allnodetx = %d\n", ilitek_allnodetx);
+		}
+		for (j = 0; j < ilitek_data->y_ch * ilitek_data->x_ch; j++) {
+			printk( "%d,", allnode_data[j]);
+			if((j + 1) % ilitek_data->x_ch == 0) {
+				printk( "%s", "\n");
+			}
+		}
+		printk( "%s", "\n");
+	}
+
+	if (ilitek_printsensortestdata) {
+		if (short_test_result == 0 && open_test_result == 0 && allnode_test_result ==0) {
+			seq_printf(m, "pass\n");
+		}
+		else {
+			seq_printf(m, "fail\n");
+		}
+		seq_printf(m, "%s", "\n");
+		seq_printf(m, "%s", "short\n");
+		seq_printf(m, "short_threshold = %d\n", ilitek_short_threshold);
+		
+		for (j = 0; j < ilitek_data->x_ch; j++) {
+			seq_printf(m, "%d,", short_xdata1[j]);
+		}
+		seq_printf(m, "%s", "\n");
+		for (j = 0; j < ilitek_data->x_ch; j++) {
+			seq_printf(m, "%d,", short_xdata2[j]);
+		}
+		seq_printf(m, "%s", "\n");
+		if (!(ilitek_data->ic_2120)) {
+			seq_printf(m, "%s", "\n");
+			for (j = 0; j < ilitek_data->y_ch; j++) {
+				seq_printf(m, "%d,", short_ydata1[j]);
+			}
+			seq_printf(m, "%s", "\n");
+			for (j = 0; j < ilitek_data->y_ch; j++) {
+				seq_printf(m, "%d,", short_ydata2[j]);
+			}
+		}
+		
+		seq_printf(m, "%s", "\n");
+		seq_printf(m, "%s", "open:\n");
+		seq_printf(m, "open_threshold = %d\n", ilitek_open_threshold);
+		if (!(ilitek_data->ic_2120)) {
+			seq_printf(m, "open_txdeltathrehold = %d\n", ilitek_open_txdeltathrehold);
+			seq_printf(m, "open_rxdeltathrehold = %d\n", ilitek_open_rxdeltathrehold);
+		}
+		for (j = 0; j < ilitek_data->y_ch * ilitek_data->x_ch; j++) {
+			seq_printf(m, "%d,", open_data[j]);
+			if((j + 1) % ilitek_data->x_ch == 0) {
+				seq_printf(m, "%s", "\n");
+			}
+		}
+		seq_printf(m, "%s", "\n");
+		seq_printf(m, "%s", "allnode:\n");
+		seq_printf(m, "allnode_max_threshold = %d\n", ilitek_allnode_max_threshold);
+		seq_printf(m, "allnode_min_threshold = %d\n", ilitek_allnode_min_threshold);
+		if (!(ilitek_data->ic_2120)) {
+			seq_printf(m, "allnodetestw1 = %d\n", ilitek_allnodetestw1);
+			seq_printf(m, "allnodetestw2 = %d\n", ilitek_allnodetestw2);
+			seq_printf(m, "allnodemodule = %d\n", ilitek_allnodemodule);
+			seq_printf(m, "allnodetx = %d\n", ilitek_allnodetx);
+		}
+		for (j = 0; j < ilitek_data->y_ch * ilitek_data->x_ch; j++) {
+			seq_printf(m, "%d,", allnode_data[j]);
+			if((j + 1) % ilitek_data->x_ch == 0) {
+				seq_printf(m, "%s", "\n");
+			}
+		}
+		seq_printf(m, "%s", "\n");
+		tp_log_info("m->size = %d  m->count = %d\n", (int)m->size, (int)m->count);
+	}
+	return;
+}
+
+static int ilitek_check_busy(int delay)
+{
+	int i;
+	unsigned char buf[2];
+	for(i = 0; i < 1000; i ++){
+		buf[0] = 0x80;
+		if(ilitek_i2c_write_and_read(buf, 1, delay, buf, 1) < 0) {
+			return ILITEK_I2C_TRANSFER_ERR;
+		}
+		if(buf[0] == 0x50) {
+			tp_log_info("check_busy i = %d\n", i);
+			return 0;
+		}
+	}
+	tp_log_info("check_busy error\n");
+	return -1;
+}
+
+static int ilitek_into_testmode(bool testmode) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+	cmd[0] = 0xF2;
+	if (testmode) {
+		cmd[1] = 0x01;
+	}
+	else {
+		cmd[1] = 0x00;
+	}
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,ilitek_into_testmode_2120 err ret %d\n", ret);
+		return ret;
+	}
+	mdelay(10);
+	return 0;
+}
+
+static int ilitek_allnode_test(int *allnode_data) {
+	int ret = 0, newMaxSize = 32, i = 0, j = 0, k = 0, read_len = 0, index = 0, diff = 0;
+	int maxneighborDiff = 0,maxintercrossdiff = 0, txerror_count = 0, moduleerror_count = 0;
+	bool txerror_result = false; 	  
+	uint8_t cmd[4] = {0};
+	uint8_t * buf_recv = NULL;
+	int test_32 = 0;
+	allnode_test_result = 0;
+	test_32 = (ilitek_data->y_ch * ilitek_data->x_ch * 2) / (newMaxSize - 2);
+	if ((ilitek_data->y_ch * ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("kzalloc  test_32 = %d\n", test_32);
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * (ilitek_data->y_ch * ilitek_data->x_ch * 2 + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	mdelay(10);
+	//initial
+	cmd[0] = 0xF3;
+	cmd[1] = 0x0B;
+	cmd[2] = 0x00;
+	if (ilitek_data->mcu_ver[1] == 0x23 || ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		cmd[3] = 0xE6;
+	}
+	else {
+		cmd[3] = 0xE2;
+	}
+	ret = ilitek_i2c_write(cmd, 4);
+	if (ret < 0) {
+		tp_log_err("allnode test  initial set err ret = %d\n", ret);
+	}
+	mdelay(1000);
+	ret = ilitek_check_busy(5);
+	if (ret < 0) {
+		tp_log_err("allnode test  check busy err ret = %d\n", ret);
+	}
+	mdelay(100);
+	if (ilitek_data->mcu_ver[1] == 0x23 || 
+		((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		test_32 = (ilitek_data->y_ch * ilitek_data->x_ch * 2) / (newMaxSize - 2);
+		if ((ilitek_data->y_ch * ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+			test_32 += 1;
+		}
+		cmd[0] = 0xE6;
+		ret = ilitek_i2c_write(cmd, 1);
+		mdelay(10);
+		tp_log_info("ilitek_allnode_test test_32 = %d\n", test_32);
+		for(i = 0; i < test_32; i++) {
+			if ((ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+				ret = ilitek_i2c_read(buf_recv + newMaxSize*i, (ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) + 2);
+			}
+			else {
+				ret = ilitek_i2c_read(buf_recv + newMaxSize*i, newMaxSize);
+			}
+			if(ret < 0){
+				tp_log_err("err,i2c read error ret %d\n", ret);
+			}
+		}
+		index = 0;
+		for (i = 0; i < test_32; i++) {
+			if (index == (ilitek_data->y_ch * ilitek_data->x_ch)) {
+				break;
+			}
+			for (j = 2; j < newMaxSize;) {
+				allnode_data[index++] = (buf_recv[newMaxSize * i + j]) + (buf_recv[newMaxSize * i + j + 1] << 8);
+				j += 2;
+				if (index == (ilitek_data->y_ch * ilitek_data->x_ch)) {
+					break;
+				}
+			}
+		}
+	}
+	else {
+		test_32 = (ilitek_data->x_ch) / (newMaxSize - 2);
+		if ((ilitek_data->x_ch) % (newMaxSize - 2) != 0) {
+			test_32 += 1;
+		}
+		tp_log_info("ilitek_allnode_test test_32 = %d\n", test_32);
+		cmd[0] = 0xE2;
+		index = 0;
+		for (j = 0; j < ilitek_data->y_ch; j++) {
+			for(i = 0; i < test_32; i++) {
+				if ((ilitek_data->x_ch)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+					read_len = (ilitek_data->x_ch) % (newMaxSize - 2) + 2;
+				}
+				else {
+					read_len = newMaxSize;
+				}
+				ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv, read_len);
+				if(ret < 0){
+					tp_log_err("i2c read err ret %d\n",ret);
+				}
+				for (k = 2; k < read_len; k++) {
+					allnode_data[index++] = (buf_recv[k]);
+					//tp_log_info("buf_recv[newMaxSize * i + j] = %d\n", buf_recv[k]);
+				}
+				msleep(10);
+			}
+		}
+	}
+	
+	#if 1
+	//handle
+	for(i = 0; i < ilitek_data->y_ch; i++) {
+		txerror_count = 0;
+		for(j = 0; j < ilitek_data->x_ch; j++) {
+			
+			if(allnode_data[i * ilitek_data->x_ch + j] > ilitek_allnode_max_threshold ||
+				allnode_data[i * ilitek_data->x_ch + j] < ilitek_allnode_min_threshold) {
+				allnode_test_result = -1;
+				tp_log_err(" err,allnode_test_result error allnode_data = %d, ilitek_allnode_max_threshold = %d,\
+					ilitek_allnode_min_threshold = %d i = %d, j = %d\n",
+					allnode_data[i * ilitek_data->x_ch + j], ilitek_allnode_max_threshold, ilitek_allnode_min_threshold, i, j);
+				break;
+			}
+			
+			if(i > 0) {
+				diff = abs(allnode_data[i * ilitek_data->x_ch + j] - allnode_data[(i - 1) * ilitek_data->x_ch + j]);
+				if(diff > maxneighborDiff) {
+					maxneighborDiff = diff;
+				}
+				if(j > 0) {
+					diff = abs((allnode_data[(i - 1) * ilitek_data->x_ch + j - 1] - allnode_data[i * ilitek_data->x_ch + j - 1]) - 
+						(allnode_data[(i - 1) * ilitek_data->x_ch + j] - allnode_data[i * ilitek_data->x_ch + j]));
+					if(diff > maxintercrossdiff) {
+						maxintercrossdiff = diff;
+					}
+					if (diff > ilitek_allnodetestw2) {
+						moduleerror_count++;
+						txerror_count++;
+						tp_log_err("allnodetestw2 err i = %d j = %d txerror_count = %d moduleerror_count = %d\n",
+							i, j, txerror_count, moduleerror_count);
+					}
+				}
+			}
+		}
+		if (txerror_count > ilitek_allnodetx) {
+			txerror_result = true;
+		}
+	}
+	
+	
+	if (ilitek_data->mcu_ver[1] == 0x23 || 
+		((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		if (txerror_result && (moduleerror_count > ilitek_allnodemodule)) {
+			allnode_test_result = -1;
+		}
+	}
+	else {
+		if(maxneighborDiff > ilitek_allnodetestw1) {
+			allnode_test_result = -1;
+			tp_log_err("maxneighborDiff = %d, ilitek_allnodetestw1 = %d\n", maxneighborDiff, ilitek_allnodetestw1);
+		}
+		if(maxintercrossdiff > ilitek_allnodetestw2) {
+			allnode_test_result = -1;
+			tp_log_err("maxintercrossdiff = %d, ilitek_allnodetestw2 = %d\n", maxintercrossdiff, ilitek_allnodetestw2);
+		}
+	}
+	#endif
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+	return allnode_test_result;
+}
+
+static int ilitek_open_test(int *open_data) {
+	int ret = 0, newMaxSize = 32, i = 0, j = 0, k = 0, read_len = 0, index = 0, value = 0;
+	int rxfailindex = 0, rxfail_count = 0;
+	int txfailindex = 0, txfail_count = 0;
+	uint8_t cmd[4] = {0};
+	uint8_t * buf_recv = NULL;
+	int test_32 = 0;
+	open_test_result = 0;
+	test_32 = (ilitek_data->y_ch * ilitek_data->x_ch * 2) / (newMaxSize - 2);
+	if ((ilitek_data->y_ch * ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("kzalloc  test_32 = %d\n", test_32);
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * (ilitek_data->y_ch * ilitek_data->x_ch * 2 + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	mdelay(10);
+	//initial
+	cmd[0] = 0xF3;
+	cmd[1] = 0x0C;
+	cmd[2] = 0x00;
+	if (ilitek_data->mcu_ver[1] == 0x23 || ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		cmd[3] = 0xE6;
+	}
+	else {
+		cmd[3] = 0xE2;
+	}
+	ret = ilitek_i2c_write(cmd, 4);
+	if (ret < 0) {
+		tp_log_err("open test  initial set err ret = %d\n", ret);
+	}
+	mdelay(1000);
+	ret = ilitek_check_busy(5);
+	if (ret < 0) {
+		tp_log_err("open test  check busy err ret = %d\n", ret);
+	}
+	mdelay(100);
+	if (ilitek_data->mcu_ver[1] == 0x23 || 
+		((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		test_32 = (ilitek_data->y_ch * ilitek_data->x_ch * 2) / (newMaxSize - 2);
+		if ((ilitek_data->y_ch * ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+			test_32 += 1;
+		}
+		cmd[0] = 0xE6;
+		ret = ilitek_i2c_write(cmd, 1);
+		mdelay(10);
+		tp_log_info("ilitek_open_test test_32 = %d\n", test_32);
+		for(i = 0; i < test_32; i++){
+			if ((ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+				ret = ilitek_i2c_read(buf_recv + newMaxSize*i, (ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) + 2);
+			}
+			else {
+				ret = ilitek_i2c_read(buf_recv + newMaxSize*i, newMaxSize);
+			}
+			if(ret < 0){
+				tp_log_err("err,i2c read error ret %d\n", ret);
+			}
+		}
+		index = 0;
+		for (i = 0; i < test_32; i++) {
+			if (index == (ilitek_data->y_ch * ilitek_data->x_ch)) {
+				break;
+			}
+			for (j = 2; j < newMaxSize;) {
+				open_data[index++] = (buf_recv[newMaxSize * i + j]) + (buf_recv[newMaxSize * i + j + 1] << 8);
+				j += 2;
+				if (index == (ilitek_data->y_ch * ilitek_data->x_ch)) {
+					break;
+				}
+			}
+		}
+	}
+	else {
+		test_32 = (ilitek_data->x_ch) / (newMaxSize - 2);
+		if ((ilitek_data->x_ch) % (newMaxSize - 2) != 0) {
+			test_32 += 1;
+		}
+		tp_log_info("ilitek_open_test test_32 = %d\n", test_32);
+		cmd[0] = 0xE2;
+		index = 0;
+		for (j = 0; j < ilitek_data->y_ch; j++) {
+			for(i = 0; i < test_32; i++) {
+				if ((ilitek_data->x_ch)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+					read_len = (ilitek_data->x_ch) % (newMaxSize - 2) + 2;
+				}
+				else {
+					read_len = newMaxSize;
+				}
+				ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv, read_len);
+				if(ret < 0){
+					tp_log_err("i2c read err ret %d\n",ret);
+				}
+				for (k = 2; k < read_len; k++) {
+					open_data[index++] = (buf_recv[k]);
+				}
+				msleep(10);
+			}
+		}
+	}
+	//check
+	#if 1
+	index = 0;
+	for(i = 0; i < ilitek_data->y_ch; i++) {
+		for(j = 0; j < ilitek_data->x_ch; j++) {
+			if(open_data[index++] < ilitek_open_threshold) {
+				open_test_result = -1;
+				tp_log_err(" err,open_test_result error open_data[%d] = %d, ilitek_open_threshold = %d\n",
+					(index - 1) , open_data[index - 1], ilitek_open_threshold);
+				break;
+			}
+		}
+	}
+	if (!open_test_result) {
+		if (ilitek_data->mcu_ver[1] == 0x23 || 
+			((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+			for (i = 0; i < ilitek_data->y_ch; i++) {
+				rxfailindex = 0;
+				rxfail_count = 0;
+				for (j = 0; j < ilitek_data->x_ch - 1; j++) {
+					value = abs(open_data[i * ilitek_data->x_ch + j + 1] - open_data[i * ilitek_data->x_ch + j]);
+					if (value > ilitek_open_rxdeltathrehold) {
+						tp_log_err(" open_test rxfail_count = %d i = %d j = %d\n", rxfail_count, i, j);
+						if (rxfail_count == 0) {
+							rxfailindex = j;
+							rxfail_count++;
+						}
+						else {
+							if ((j - rxfailindex) == 1) {
+								rxfailindex = j;
+								rxfail_count++;
+								if (rxfail_count >= 3) {
+									open_test_result = -1;
+									tp_log_err(" err,open_test_result error rxfail_count = %d\n", rxfail_count);
+									break;
+								}
+							}
+							else {
+								rxfailindex = j;
+								rxfail_count = 1;
+							}
+						}
+					}
+				}
+			}
+			if (!open_test_result) {
+				for (i = 0; i < ilitek_data->y_ch - 1; i++) {
+					txfailindex = 0;
+					txfail_count = 0;
+					for (j = 0; j < ilitek_data->x_ch; j++) {
+						value = abs(open_data[(i + 1) * ilitek_data->x_ch + j] - open_data[i * ilitek_data->x_ch + j]);
+						if (value > ilitek_open_txdeltathrehold) {
+							tp_log_err(" open_test txfail_count = %d i = %d j = %d\n", txfail_count, i, j);
+							if (txfail_count == 0) {
+								txfailindex = j;
+								txfail_count++;
+							}
+							else {
+								if ((j - txfailindex) == 1) {
+									txfailindex = j;
+									txfail_count++;
+									if (txfail_count >= 3) {
+										open_test_result = -1;
+										tp_log_err(" err,open_test_result error txfail_count = %d\n", txfail_count);
+										break;
+									}
+								}
+								else {
+									txfailindex = j;
+									txfail_count = 1;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	#endif
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+	return open_test_result;
+}
+
+static int ilitek_short_test(int *short_xdata1, int *short_xdata2, int *short_ydata1, int *short_ydata2) {
+	int ret = 0, newMaxSize = 32, i = 0, j = 0, index = 0;
+	uint8_t cmd[4] = {0};
+	uint8_t * buf_recv = NULL;
+	int test_32 = 0;
+	short_test_result = 0;
+	index = ilitek_data->x_ch;
+	if (ilitek_data->x_ch < ilitek_data->x_ch) {
+		index = ilitek_data->y_ch;
+	}
+	test_32 = index / (newMaxSize - 2);
+	if (index % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("kzalloc  test_32 = %d\n", test_32);
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * (index + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	//initial
+	cmd[0] = 0xF3;
+	cmd[1] = 0x09;
+	cmd[2] = 0x00;
+	cmd[3] = 0xE0;
+	ret = ilitek_i2c_write(cmd, 4);
+	if (ret < 0) {
+		tp_log_err("short test  initial set err ret = %d\n", ret);
+	}	
+	ret = ilitek_check_busy(5);
+	if (ret < 0) {
+		tp_log_err("short test  check busy err ret = %d\n", ret);
+	}
+	mdelay(100);
+	test_32 = ilitek_data->x_ch / (newMaxSize - 2);
+	if (ilitek_data->x_ch % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("short xch  test_32 = %d\n", test_32);
+	cmd[0] = 0xE0;
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->x_ch)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, (ilitek_data->x_ch) % (newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("i2c read err ret %d\n",ret);
+		}
+	}
+	
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->x_ch) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index++) {
+			short_xdata1[j] = buf_recv[i * newMaxSize + index];
+			j++;
+			if (j == ilitek_data->x_ch) {
+				break;
+			}
+		}
+	}
+	if (ilitek_data->mcu_ver[1] == 0x23 || ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		cmd[0] = 0xF3;
+		cmd[1] = 0x09;
+		cmd[2] = 0x00;
+		cmd[3] = 0xE1;
+		ret = ilitek_i2c_write(cmd, 4);
+		if (ret < 0) {
+			tp_log_err("short test	initial set err ret = %d\n", ret);
+		}	
+		
+		//check busy
+		ret = ilitek_check_busy(5);
+		if (ret < 0) {
+			tp_log_err("short test	check busy err ret = %d\n", ret);
+		}
+	}
+
+	test_32 = ilitek_data->y_ch / (newMaxSize - 2);
+	if (ilitek_data->y_ch % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("short ych  test_32 = %d\n", test_32);
+	msleep(100);
+	cmd[0] = 0xE1;
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->y_ch)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, (ilitek_data->y_ch) % (newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("i2c read err ret %d\n",ret);
+		}
+	}
+	
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->y_ch) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index++) {
+			short_ydata1[j] = buf_recv[i * newMaxSize + index];
+			j++;
+			if (j == ilitek_data->y_ch) {
+				break;
+			}
+		}
+	}
+	msleep(100);
+	//initial
+	cmd[0] = 0xF3;
+	cmd[1] = 0x0A;
+	cmd[2] = 0x00;
+	cmd[3] = 0xE0;
+	ret = ilitek_i2c_write(cmd, 4);
+	if (ret < 0) {
+		tp_log_err("short test	initial set err ret = %d\n", ret);
+	}	
+	
+	//check busy
+	ret = ilitek_check_busy(5);
+	if (ret < 0) {
+		tp_log_err("short test	check busy err ret = %d\n", ret);
+	}
+	mdelay(100);
+	test_32 = ilitek_data->x_ch / (newMaxSize - 2);
+	if (ilitek_data->x_ch % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("short xch  test_32 = %d\n", test_32);
+	cmd[0] = 0xE0;
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->x_ch)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, (ilitek_data->x_ch) % (newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("i2c read err ret %d\n",ret);
+		}
+	}
+	
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->x_ch) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index++) {
+			short_xdata2[j] = buf_recv[i * newMaxSize + index];
+			j++;
+			if (j == ilitek_data->x_ch) {
+				break;
+			}
+		}
+	}
+
+	if (ilitek_data->mcu_ver[1] == 0x23 || ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25)) {
+		cmd[0] = 0xF3;
+		cmd[1] = 0x0A;
+		cmd[2] = 0x00;
+		cmd[3] = 0xE1;
+		ret = ilitek_i2c_write(cmd, 4);
+		if (ret < 0) {
+			tp_log_err("short test	initial set err ret = %d\n", ret);
+		}	
+		
+		//check busy
+		ret = ilitek_check_busy(5);
+		if (ret < 0) {
+			tp_log_err("short test	check busy err ret = %d\n", ret);
+		}
+	}
+	test_32 = ilitek_data->y_ch / (newMaxSize - 2);
+	if (ilitek_data->y_ch % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("short ych  test_32 = %d\n", test_32);
+	msleep(100);
+	cmd[0] = 0xE1;
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->y_ch)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, (ilitek_data->y_ch) % (newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_write_and_read(cmd, 1, 2, buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("i2c read err ret %d\n",ret);
+		}
+	}
+	
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->y_ch) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index++) {
+			short_ydata2[j] = buf_recv[i * newMaxSize + index];
+			j++;
+			if (j == ilitek_data->y_ch) {
+				break;
+			}
+		}
+	}
+	//check pass or fail
+	for(i = 0; i < ilitek_data->x_ch; i++) {
+		if(abs(short_xdata1[i] - short_xdata2[i]) > ilitek_short_threshold) {
+			short_test_result = -1;
+			tp_log_err("[TP_selftest] err,short_test_result error short_xdata1[%d] = %d, short_xdata2[%d] = %d, ilitek_short_threshold = %d\n",
+				i , short_xdata1[i], i , short_xdata2[i], ilitek_short_threshold);
+			break;
+		} 
+	}
+	if(short_test_result == 0) {
+		for(i = 0; i < ilitek_data->y_ch; i++) {
+			if(abs(short_ydata1[i] - short_ydata2[i]) > ilitek_short_threshold) {
+				short_test_result = -1;
+				tp_log_err("[TP_selftest] err,short_test_result error short_ydata1[%d] = %d, short_ydata2[%d] = %d, ilitek_short_threshold = %d\n",
+					i , short_ydata1[i], i , short_ydata2[i], ilitek_short_threshold);
+				break;
+			} 
+		}
+	}
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+	return short_test_result;
+}
+
+static int ilitek_sensortest_bigger_size_ic(int * short_xdata1, int * short_xdata2, int * short_ydata1,
+	int * short_ydata2, int * open_data, int * allnode_data) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+	tp_log_info("\n");
+	if(NULL == short_xdata1 || NULL == short_xdata2 || NULL == short_ydata1
+		|| NULL == short_ydata2 || NULL == open_data || NULL == allnode_data){
+		tp_log_err("save data buf is NULL\n");
+		return -ENOMEM;
+	}
+	cmd[0] = 0xF4;
+	cmd[1] = 0x51;
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,f4 51 err ret %d\n", ret);
+		//return ret;
+	}
+	mdelay(10);
+	ret = ilitek_into_testmode(true);
+	if (ret < 0) {
+		tp_log_err("into test mode err ret = %d\n", ret);
+		return ret;
+	}
+	ret = ilitek_short_test(short_xdata1, short_xdata2, short_ydata1, short_ydata2);
+	if (ret < 0) {
+		tp_log_err("short test fail ret = %d\n", ret);
+	}
+	ret = ilitek_into_testmode(true);
+	if (ret < 0) {
+		tp_log_err("into test mode err ret = %d\n", ret);
+		//return ret;
+	}
+	ret = ilitek_open_test(open_data);
+	if (ret < 0) {
+		tp_log_err("open test fail ret = %d\n", ret);
+	}
+	ret = ilitek_into_testmode(true);
+	if (ret < 0) {
+		tp_log_err("into test mode err ret = %d\n", ret);
+		//return ret;
+	}
+	ret = ilitek_allnode_test(allnode_data);
+	if (ret < 0) {
+		tp_log_err("allnode test fail ret = %d\n", ret);
+	}
+	ret = ilitek_into_testmode(false);
+	if (ret < 0) {
+		tp_log_err("into test mode err ret = %d\n", ret);
+		//return ret;
+	}
+	cmd[0] = 0xF4;
+	cmd[1] = 0x50;
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,f4 50 err ret %d\n", ret);
+		//return ret;
+	}
+	return 0;
+}
+
+static int ilitek_allnode_test_2120(int *allnode_data) {
+	int ret = 0, newMaxSize = 32, i = 0, j = 0, index = 0;
+	uint8_t cmd[4] = {0};
+	uint8_t * buf_recv = NULL;
+
+	int test_32 = (ilitek_data->y_ch * ilitek_data->x_ch * 2) / (newMaxSize - 2);
+	if ((ilitek_data->y_ch * ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * (ilitek_data->y_ch * ilitek_data->x_ch * 2 + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	tp_log_info("ilitek_allnode_test test_32 = %d\n", test_32);
+	allnode_test_result = 0;
+	cmd[0] = 0xF1;
+	cmd[1] = 0x08;//0x05;
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+	msleep(10);
+
+	for (i =0; i < 300; i++ ) {
+		ret = ilitek_poll_int();
+		tp_log_info("ilitek interrupt status = %d\n", ret);
+		if (ret == 1) {
+			break;
+		}
+		else {
+			msleep(5);
+		}
+	}
+
+	cmd[0] = 0xF6;
+	cmd[1] = 0xF2;
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+	msleep(10);
+	cmd[0] = 0xF2;
+	ret = ilitek_i2c_write(cmd, 1);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+	msleep(10);
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, (ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("err,i2c read error ret %d\n", ret);
+		}
+	}
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->y_ch * ilitek_data->x_ch) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index += 2) {
+			allnode_data[j] = ((buf_recv[i * newMaxSize + index + 1] << 8) + buf_recv[i * newMaxSize + index]);
+			if ( (allnode_data[j] < ilitek_allnode_min_threshold) ||(allnode_data[j] > ilitek_allnode_max_threshold) ) {
+				tp_log_err("err,allnode_test_result error allnode_data[%d] = %d, ilitek_allnode_min_threshold = %d ilitek_allnode_max_threshold = %d\n",
+					j , allnode_data[j], ilitek_allnode_min_threshold, ilitek_allnode_max_threshold);
+				allnode_test_result = -1;
+				break;
+			}
+			j++;
+
+			if (j == ilitek_data->y_ch * ilitek_data->x_ch) {
+				break;
+			}
+		}
+	}
+
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+
+	return allnode_test_result;
+}
+
+static int ilitek_open_test_2120(int *open_data) {
+	int ret = 0, newMaxSize = 32, i = 0, j = 0, index = 0;
+	uint8_t cmd[4] = {0};
+	uint8_t * buf_recv = NULL;
+
+	int test_32 = (ilitek_data->y_ch * ilitek_data->x_ch * 2) / (newMaxSize - 2);
+	if ((ilitek_data->y_ch * ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * (ilitek_data->y_ch * ilitek_data->x_ch * 2 + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	open_test_result = 0;
+	cmd[0] = 0xF1;
+	cmd[1] = 0x06;
+	cmd[2] = 0x00;
+	ret = ilitek_i2c_write(cmd, 3);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+
+	msleep(1);
+	for (i =0; i < 300; i++ ) {
+		ret = ilitek_poll_int();
+		tp_log_info("ilitek interrupt status = %d\n",ret);
+		if (ret == 1) {
+			break;
+		}
+		else {
+			msleep(5);
+		}
+	}
+
+	cmd[0] = 0xF6;
+	cmd[1] = 0xF2;
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+
+	cmd[0] = 0xF2;
+	ret = ilitek_i2c_write(cmd, 1);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+
+	tp_log_info("ilitek_open_test test_32 = %d\n", test_32);
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, (ilitek_data->y_ch * ilitek_data->x_ch * 2)%(newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("err,i2c read error ret %d\n", ret);
+		}
+	}
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->y_ch * ilitek_data->x_ch) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index += 2) {
+			open_data[j] = ((buf_recv[i * newMaxSize + index + 1] << 8) + buf_recv[i * newMaxSize + index]);
+			if (((buf_recv[i * newMaxSize + index + 1] << 8) + buf_recv[i * newMaxSize + index]) < ilitek_open_threshold) {
+				tp_log_err("[TP_selftest] err,open_test_result error open_data[%d] = %d, ilitek_open_threshold = %d\n",
+					j , open_data[j], ilitek_open_threshold);
+				open_test_result = -1;
+				break;
+			}
+			j++;
+			if (j == ilitek_data->y_ch * ilitek_data->x_ch) {
+				break;
+			}
+		}
+	}
+
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+	return open_test_result;
+}
+
+static int ilitek_short_test_2120(int *short_data1, int *short_data2) {
+	int ret = 0, newMaxSize = 32, i = 0, j = 0, index = 0;
+	uint8_t cmd[4] = {0};
+	uint8_t * buf_recv = NULL;
+
+	int test_32 = (ilitek_data->x_ch * 2) / (newMaxSize - 2);
+	if ((ilitek_data->x_ch * 2) % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("ilitek_short_test test_32 = %d\n", test_32);
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * ((ilitek_data->x_ch * 2) + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	short_test_result = 0;
+	cmd[0] = 0xF1;
+	cmd[1] = 0x04;
+	cmd[2] = 0x00;
+	ret = ilitek_i2c_write(cmd, 3);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+
+	msleep(1);
+	for (i =0; i < 300; i++ ) {
+		ret = ilitek_poll_int();
+		tp_log_info("ilitek interrupt status = %d\n",ret);
+		if (ret == 1) {
+			break;
+		}
+		else {
+			msleep(5);
+		}
+	}
+
+	cmd[0] = 0xF6;
+	cmd[1] = 0xF2;
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+
+	cmd[0] = 0xF2;
+	ret = ilitek_i2c_write(cmd, 1);
+	if(ret < 0){
+		tp_log_err("i2c err, ret %d\n",ret);
+	}
+
+	for(i = 0; i < test_32; i++){
+		if ((ilitek_data->x_ch * 2)%(newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, (ilitek_data->x_ch * 2) % (newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("i2c read err ret %d\n",ret);
+		}
+	}
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == ilitek_data->x_ch * 2) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index++) {
+			if (j < ilitek_data->x_ch) {
+				short_data1[j] = buf_recv[i * newMaxSize + index];
+			}
+			else {
+				short_data2[j - ilitek_data->x_ch] = buf_recv[i * newMaxSize + index];
+			}
+			j++;
+			if (j == ilitek_data->x_ch * 2) {
+				break;
+			}
+		}
+	}
+
+	for (i = 0; i < ilitek_data->x_ch; i++) {
+		if (abs(short_data1[i] - short_data2[i]) > ilitek_short_threshold) {
+			tp_log_err("[TP_selftest] err,short_test_result error short_data1[%d] = %d, short_data2[%d] = %d, ilitek_short_threshold = %d\n",
+				i , short_data1[i], i , short_data2[i], ilitek_short_threshold);
+			short_test_result = -1;
+			break;
+		}
+	}
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+	return short_test_result;
+}
+
+static int ilitek_gesture_disable_sense_start_2120(void) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+
+	cmd[0] = 0x0A;
+	cmd[1] = 0x00;
+	ret = ilitek_i2c_write(cmd, 2);
+	mdelay(10);
+	cmd[0] = 0x01;
+	cmd[1] = 0x01;
+	ret = ilitek_i2c_write(cmd, 2);
+	mdelay(10);
+	return 0;
+}
+
+static int ilitek_into_testmode_2120(bool testmode) {
+	int ret = 0;
+	uint8_t cmd[2] = {0};
+	cmd[0] = 0xF0;
+	if (testmode) {
+		cmd[1] = 0x01;
+	}
+	else {
+		cmd[1] = 0x00;
+	}
+	ret = ilitek_i2c_write(cmd, 2);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,ilitek_into_testmode_2120 err ret %d\n", ret);
+		return ret;
+	}
+	mdelay(10);
+	return 0;
+}
+
+static int ilitek_sensortest_2120(int * short_xdata1, int * short_xdata2, int * open_data, int * allnode_data) {
+	int ret = 0;
+	unsigned char buf[64]={0};
+	tp_log_info("\n");
+	if(NULL == short_xdata1 || NULL == short_xdata2 || NULL == open_data || NULL == allnode_data){
+		tp_log_err("save data buf is NULL\n");
+		return -ENOMEM;
+	}
+	buf[0] = ILITEK_TP_CMD_GET_TOUCH_INFORMATION;
+	ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 3);
+	tp_log_info("write 0x10 read 0x%d, 0x%d, 0x%d\n", buf[0], buf[1], buf[2]);
+	buf[0] = ILITEK_TP_CMD_READ_DATA_CONTROL_2120;
+	buf[1] = 0x13;
+	ret = ilitek_i2c_write_and_read(buf, 2, 10, buf, 0);
+	buf[0] = 0x13;
+	ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 2);
+	tp_log_info("write 0x13 read 0x%d, 0x%d\n", buf[0], buf[1]);
+	ret = ilitek_into_testmode_2120(true);
+	if (ret < 0) {
+		tp_log_err("into test mode err ret = %d\n", ret);
+		return ret;
+	}
+	ret = ilitek_gesture_disable_sense_start_2120();
+	if (ret < 0) {
+		tp_log_err("gesture_disable_sense_start err ret = %d\n", ret);
+		return ret;
+	}
+	ret = ilitek_short_test_2120(short_xdata1, short_xdata2);
+	if (ret < 0) {
+		tp_log_err("short test fail ret = %d\n", ret);
+	}
+	ret = ilitek_open_test_2120(open_data);
+	if (ret < 0) {
+		tp_log_err("open test fail ret = %d\n", ret);
+	}
+	ret = ilitek_allnode_test_2120(allnode_data);
+	if (ret < 0) {
+		tp_log_err("allnode test fail ret = %d\n", ret);
+	}
+	ret = ilitek_into_testmode_2120(false);
+	if (ret < 0) {
+		tp_log_err("into normal mode err ret = %d\n", ret);
+	}
+	return ret;
+}
+static int ilitek_sensortest_proc_show(struct seq_file *m, void *v) {
+	int ret = 0;
+	int * short_xdata1 = NULL;
+	int * short_xdata2 = NULL;
+	int * short_ydata1 = NULL;
+	int * short_ydata2 = NULL;
+	int * open_data = NULL;
+	int * allnode_data = NULL;
+	tp_log_info("m->size = %d  m->count = %d\n", (int)m->size, (int)m->count);
+	if (m->size <= (4096 * 4)) {
+		m->count = m->size;
+		return 0;
+	}
+	short_xdata1 = (int *)vmalloc(sizeof(int) * (ilitek_data->x_ch));
+	short_xdata2 = (int *)vmalloc(sizeof(int) * (ilitek_data->x_ch));
+	short_ydata1 = (int *)vmalloc(sizeof(int) * (ilitek_data->y_ch));
+	short_ydata2 = (int *)vmalloc(sizeof(int) * (ilitek_data->y_ch));
+	open_data = (int *)vmalloc(sizeof(int) * (ilitek_data->y_ch * ilitek_data->x_ch));
+	allnode_data = (int *)vmalloc(sizeof(int) * (ilitek_data->y_ch * ilitek_data->x_ch));
+	if(NULL == short_xdata1 || NULL == short_xdata2 || NULL == short_ydata1
+		|| NULL == short_ydata2 || NULL == open_data || NULL == allnode_data){
+		tp_log_err("kzalloc ERR NULL\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	ilitek_irq_disable();
+	ilitek_data->operation_protection = true;
+	if (!(ilitek_data->ic_2120)) {
+		ret = ilitek_sensortest_bigger_size_ic(short_xdata1, short_xdata2, short_ydata1, short_ydata2, open_data, allnode_data);
+	}
+	else {
+		ret = ilitek_sensortest_2120(short_xdata1, short_xdata2, open_data, allnode_data);
+	}
+	ilitek_reset(300);
+	ilitek_irq_enable();
+	ilitek_data->operation_protection = false;
+	ilitek_printf_sensortest_data(short_xdata1, short_xdata2, short_ydata1, short_ydata2, open_data, allnode_data, m);
+out:
+	if (short_xdata1) {
+		vfree(short_xdata1);
+		short_xdata1 = NULL;
+	}
+	if (short_xdata2) {
+		vfree(short_xdata2);
+		short_xdata2 = NULL;
+	}
+	if (short_ydata1) {
+		vfree(short_ydata1);
+		short_ydata1 = NULL;
+	}
+	if (short_ydata2) {
+		vfree(short_ydata2);
+		short_ydata2 = NULL;
+	}
+	if (open_data) {
+		vfree(open_data);
+		open_data = NULL;
+	}
+	if (allnode_data) {
+		vfree(allnode_data);
+		allnode_data = NULL;
+	}
+	return 0;
+}
+
+static int ilitek_proc_open_sensortest(struct inode *inode, struct file *file) {
+	tp_log_info("\n");
+	return single_open(file, ilitek_sensortest_proc_show, NULL);
+}
+static ssize_t ilitek_sensortest_write(struct file *pFile, const char __user *buf, size_t size, loff_t *pPos) {	
+	int ret = 0;
+	tp_log_info("\n");
+	if (!(ilitek_data->ic_2120)) {
+		ret = sscanf(buf, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s",&ilitek_short_threshold, &ilitek_open_threshold, &ilitek_open_txdeltathrehold,
+			&ilitek_open_rxdeltathrehold, &ilitek_allnode_max_threshold, &ilitek_allnode_min_threshold,
+			&ilitek_allnodetestw1, &ilitek_allnodetestw2, &ilitek_allnodemodule, &ilitek_allnodetx, &ilitek_printsensortestdata, sensor_test_data_path);
+		if (ret != 12) {
+			tp_log_err("sscanf get value fail\n");
+		}
+		tp_log_info("ilitek_short_threshold = %d\n", ilitek_short_threshold);
+		tp_log_info("ilitek_open_threshold = %d\n", ilitek_open_threshold);
+		tp_log_info("ilitek_open_txdeltathrehold = %d\n", ilitek_open_txdeltathrehold);
+		tp_log_info("ilitek_open_rxdeltathrehold = %d\n", ilitek_open_rxdeltathrehold);
+		tp_log_info("ilitek_allnode_max_threshold = %d\n", ilitek_allnode_max_threshold);
+		tp_log_info("ilitek_allnode_min_threshold = %d\n", ilitek_allnode_min_threshold);
+		tp_log_info("ilitek_allnodetestw1 = %d\n", ilitek_allnodetestw1);
+		tp_log_info("ilitek_allnodetestw2 = %d\n", ilitek_allnodetestw2);
+		tp_log_info("ilitek_allnodemodule = %d\n", ilitek_allnodemodule);
+		tp_log_info("ilitek_allnodetx = %d\n", ilitek_allnodetx);
+	}
+	else {
+		ret = sscanf(buf, "%d,%d,%d,%d,%d,%s",&ilitek_short_threshold, &ilitek_open_threshold,
+			&ilitek_allnode_max_threshold, &ilitek_allnode_min_threshold, &ilitek_printsensortestdata, sensor_test_data_path);
+		if (ret != 6) {
+			tp_log_err("sscanf get value fail\n");
+		}
+		tp_log_info("ilitek_short_threshold = %d\n", ilitek_short_threshold);
+		tp_log_info("ilitek_open_threshold = %d\n", ilitek_open_threshold);
+		tp_log_info("ilitek_allnode_max_threshold = %d\n", ilitek_allnode_max_threshold);
+		tp_log_info("ilitek_allnode_min_threshold = %d\n", ilitek_allnode_min_threshold);
+	}
+	tp_log_info("ilitek_printsensortestdata = %d\n", ilitek_printsensortestdata);
+	tp_log_info("sensor_test_data_path = %s\n", sensor_test_data_path);
+	return size;
+}
+const struct file_operations ilitek_proc_fops_sensortest = {
+	.open = ilitek_proc_open_sensortest,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = ilitek_sensortest_write,
+	.release = single_release,
+};
+
+static void ilitek_printf_noisefre_data(uint8_t * noisefre_data, struct seq_file *m) {
+	int i = 0, j = 0, len = 0, loop_10 = 0;
+	int read_noisefre_data_len = 0;
+	struct file *filp;
+	mm_segment_t fs;
+	unsigned char buf[128];
+    struct  timeval   time_now;
+	struct rtc_time tm; 
+    do_gettimeofday(&time_now);
+	rtc_time_to_tm(time_now.tv_sec, &tm); 
+	tp_log_info("%d_%d_%d_%d_%d_%d\n", (tm.tm_year + 1900), tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	len = sprintf(buf, "ilitek_noisefre_%d%02d%02d%02d%02d%02d_pass.csv", (tm.tm_year + 1900), tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	for(j = 0; j < 256; j++) {
+		noisefre_data_path_tmp[j] = noisefre_data_path[j];
+	}
+	strcat(noisefre_data_path, buf);
+	tp_log_info("noisefre_data_path = %s\n", noisefre_data_path);
+	
+	read_noisefre_data_len = ((noisefre_step != 0) ? 
+		(((noisefre_end - noisefre_start) * 10) / noisefre_step + 1) : (((noisefre_end - noisefre_start) * 10) * 2));
+	loop_10 = read_noisefre_data_len / 20;
+	if (read_noisefre_data_len % 20) {
+		loop_10 += 1;
+	}
+	for (i = 0; i < loop_10; i++) {
+		if ((read_noisefre_data_len % 20) && (i == (loop_10 - 1))) {
+			for (j = 0; j < (read_noisefre_data_len % 20); j++) {
+				seq_printf(m, "%04d,", (noisefre_start * 10) + ((i * 20 + j) * noisefre_step));
+			}
+			seq_printf(m, "\n");
+			for (j = 0; j < (read_noisefre_data_len % 20); j++) {
+				seq_printf(m, "%04d,", noisefre_data[(i * 20 + j)]);
+			}
+			seq_printf(m, "\n");
+		}
+		else {
+			for (j = 0; j < 20; j++) {
+				seq_printf(m, "%04d,", (noisefre_start * 10) + ((i * 20 + j) * noisefre_step));
+			}
+			seq_printf(m, "\n");
+			for (j = 0; j < 20; j++) {
+				seq_printf(m, "%04d,", noisefre_data[(i * 20 + j)]);
+			}
+			seq_printf(m, "\n");
+			seq_printf(m, "\n");
+		}
+	}
+	tp_log_info("m->size = %d  m->count = %d\n", (int)m->size, (int)m->count);
+	
+	filp = filp_open(noisefre_data_path, O_CREAT | O_WRONLY, 0777);
+	if(IS_ERR(filp)) {
+		tp_log_err("save noisefre data  File Open Error path = %s\n", noisefre_data_path);
+	}
+	else {
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+
+		for (j = (noisefre_start * 10); j < (noisefre_end * 10); j += noisefre_step) {
+			len = sprintf(buf, "%03d,", j);
+			printk("%03d,", j);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		}
+		len = sprintf(buf, "\n");
+		printk("\n");
+		filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		for (j = 0; j < read_noisefre_data_len; j++) {
+			len = sprintf(buf, "%03d,", noisefre_data[j]);
+			printk("%03d,", noisefre_data[j]);
+			filp->f_op->write(filp, buf, len, &(filp->f_pos));
+		}
+		printk("\n");
+		set_fs(fs);
+	}
+	for(j = 0; j < 256; j++) {
+		noisefre_data_path[j] = noisefre_data_path_tmp[j];
+	}
+	return;
+}
+
+static int ilitek_noisefre_proc_show(struct seq_file *m, void *v) {
+	int ret = 0, newMaxSize = 32, i =0, j = 0, index = 0;
+	uint8_t cmd[8] = {0};
+	int read_noisefre_data_len = 0;
+	int test_32 = 0;
+	uint8_t * buf_recv = NULL;
+	tp_log_info("m->size = %d  m->count = %d\n", (int)m->size, (int)m->count);
+	if (m->size <= (4096)) {
+		m->count = m->size;
+		return 0;
+	}
+	read_noisefre_data_len = ((noisefre_step != 0) ? 
+		(((noisefre_end - noisefre_start) * 10) / noisefre_step + 1) : (((noisefre_end - noisefre_start) * 10) * 2));
+	test_32 = (read_noisefre_data_len) / (newMaxSize - 2);
+	if (read_noisefre_data_len % (newMaxSize - 2) != 0) {
+		test_32 += 1;
+	}
+	tp_log_info("kzalloc  test_32 = %d\n", test_32);
+	buf_recv = (uint8_t *)vmalloc(sizeof(uint8_t) * (read_noisefre_data_len + test_32 * 2 + 32));
+	if(NULL == buf_recv) {
+		tp_log_err("buf_recv NULL\n");
+		return -ENOMEM;
+	}
+	ilitek_irq_disable();
+	ret = ilitek_into_testmode(true);
+	if (ret < 0) {
+		tp_log_err("into test mode err ret = %d\n", ret);
+		return ret;
+	}
+	cmd[0] = 0xF3;
+	cmd[1] = 0x0F;
+	cmd[2] = noisefre_start;
+	cmd[3] = noisefre_end;
+	cmd[4] = noisefre_step;
+	ret = ilitek_i2c_write(cmd, 5);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,ilitek_into_testmode_2120 err ret %d\n", ret);
+		return ret;
+	}
+	ret = ilitek_check_busy(10);
+	if (ret < 0) {
+		tp_log_err("allnode test  check busy err ret = %d\n", ret);
+	}
+	
+	cmd[0] = 0xE4;
+	ret = ilitek_i2c_write(cmd, 1);
+	if(ret < 0){
+		tp_log_err("ilitek_i2c_write err,ilitek_into_testmode_2120 err ret %d\n", ret);
+		return ret;
+	}
+	for(i = 0; i < test_32; i++){
+		if (read_noisefre_data_len % (newMaxSize - 2) != 0 && i == test_32 - 1) {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, read_noisefre_data_len % (newMaxSize - 2) + 2);
+		}
+		else {
+			ret = ilitek_i2c_read(buf_recv + newMaxSize*i, newMaxSize);
+		}
+		if(ret < 0){
+			tp_log_err("err,i2c read error ret %d\n", ret);
+		}
+	}
+	j = 0;
+	for(i = 0; i < test_32; i++) {
+		if (j == read_noisefre_data_len) {
+			break;
+		}
+		for(index = 2; index < newMaxSize; index++) {
+			buf_recv[j] = (buf_recv[i * newMaxSize + index]);
+			j++;
+			if (j == read_noisefre_data_len) {
+				break;
+			}
+		}
+	}
+	ilitek_reset(300);
+	ilitek_irq_enable();
+	ilitek_printf_noisefre_data(buf_recv, m);
+	if (buf_recv) {
+		vfree(buf_recv);
+		buf_recv = NULL;
+	}
+	return 0;
+}
+
+static int ilitek_proc_open_noisefre(struct inode *inode, struct file *file) {
+	tp_log_info("\n");
+	return single_open(file, ilitek_noisefre_proc_show, NULL);
+}
+
+static ssize_t ilitek_noisefre_write(struct file *pFile, const char __user *buf, size_t size, loff_t *pPos) {	
+	int ret = 0;
+	tp_log_info("\n");
+	ret = sscanf(buf, "%d,%d,%d,%s",&noisefre_start, &noisefre_end, &noisefre_step, noisefre_data_path);
+	if (ret != 4) {
+		tp_log_err("sscanf get value fail\n");
+	}
+	tp_log_info("noisefre_start = %d\n", noisefre_start);
+	tp_log_info("noisefre_end = %d\n", noisefre_end);
+	tp_log_info("noisefre_step = %d\n", noisefre_step);
+	tp_log_info("noisefre_data_path = %s\n", noisefre_data_path);
+	return size;
+}
+
+const struct file_operations ilitek_proc_fops_noisefre = {
+	.open = ilitek_proc_open_noisefre,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = ilitek_noisefre_write,
+	.release = single_release,
+};
+
+static unsigned int ilitek_hex_2_dec(unsigned char *hex, int len) {
+	unsigned int ret = 0, temp = 0;
+	int i, shift = (len - 1) * 4;
+	for(i = 0; i < len; shift -= 4, i++) {
+		if((hex[i] >= '0') && (hex[i] <= '9')) {
+			temp = hex[i] - '0';
+		} else if((hex[i] >= 'a') && (hex[i] <= 'z')) {
+			temp = (hex[i] - 'a') + 10;
+		} else {
+			temp = (hex[i] - 'A') + 10;
+		}
+		ret |= (temp << shift);
+	}
+	return ret;
+}
+
+static int ilitek_parse_hex_file(unsigned int * df_startaddr, unsigned int * df_endaddr, unsigned int * df_checksum,
+	unsigned int * ap_startaddr, unsigned int * ap_endaddr, unsigned int * ap_checksum, int hex_len,
+	unsigned char * CTPM_FW, unsigned char * save_hex_content) {
+	int i = 0, j = 0, k = 0;
+	unsigned int checksum = 0, check = 0;
+	unsigned int len = 0, addr = 0, type = 0, exaddr = 0;
+	int hex_end = 0;
+	int offset;
+	tp_log_info("\n");
+	if (save_hex_content == NULL) {
+		tp_log_err("save_hex_content is null\n");
+		return -2;
+	}
+	if (CTPM_FW == NULL) {
+		tp_log_err("CTPM_FW is null\n");
+		return -2;
+	}
+	ilitek_data->upgrade_FW_info_addr = -1;
+	for(i = 0; i < hex_len; ) {
+		len = ilitek_hex_2_dec(&save_hex_content[i + 1], 2);
+		addr = ilitek_hex_2_dec(&save_hex_content[i + 3], 4);
+		type = ilitek_hex_2_dec(&save_hex_content[i + 7], 2);
+		if (type == 1) {
+			hex_end = 1;
+		}
+		if(type == 0x04) {
+			exaddr = ilitek_hex_2_dec(&save_hex_content[i + 9], 4);
+			tp_log_info("exaddr = %x\n", (int)exaddr);
+		}
+		addr = addr + (exaddr << 16);
+		//calculate checksum
+		checksum = 0;
+		for(j = 8; j < (2 + 4 + 2 + (len * 2)); j += 2) {
+			if(type == 0x00) {
+				check = check + ilitek_hex_2_dec(&save_hex_content[i + 1 + j], 2);
+				if(addr + (j - 8) / 2 < *df_startaddr) {
+					*ap_checksum = *ap_checksum + ilitek_hex_2_dec(&save_hex_content[i + 1 + j], 2);
+				} else {
+					*df_checksum = *df_checksum + ilitek_hex_2_dec(&save_hex_content[i + 1 + j], 2);
+				}
+			} else {
+				checksum = 0;
+			}
+		}
+		if(save_hex_content[i + 1 + j + 2] == 0x0D) {
+			offset = 2;
+		} else {
+			offset = 1;
+		}
+		if(addr < *df_startaddr) {
+			*ap_checksum = *ap_checksum + checksum;
+		} else {
+			*df_checksum = *df_checksum + checksum;
+		}
+		if(type == 0x00) {
+			if(addr < *ap_startaddr) {
+				*ap_startaddr = addr;
+			}
+			if((addr + len) > *ap_endaddr && (addr < *df_startaddr)) {
+				*ap_endaddr = addr + len - 1;
+				if(*ap_endaddr > *df_startaddr) {
+					*ap_endaddr = *df_startaddr - 1;
+				}
+			}
+			if((addr + len) > *df_endaddr && (addr >= *df_startaddr)) {
+				*df_endaddr = addr + len;
+			}
+	
+			//fill data
+			for(j = 0, k = 0; j < (len * 2); j += 2, k++) {
+				CTPM_FW[32 + addr + k] = ilitek_hex_2_dec(&save_hex_content[i + 9 + j], 2);
+			}
+		}
+		if (type == 0xAC) {
+			ilitek_data->upgrade_FW_info_addr = 0;
+			for (j = 0; j < len; j++) {
+				tp_log_info("ilitek_hex_2_dec(&save_hex_content[i + 9 + j * 2], 2) = 0x%X\n", ilitek_hex_2_dec(&save_hex_content[i + 9 + j * 2], 2));
+				ilitek_data->upgrade_FW_info_addr += ilitek_hex_2_dec(&save_hex_content[i + 9 + j * 2], 2) << (8 * (len -j - 1));
+			}
+			tp_log_info("upgrade_FW_info_addr = 0x%X\n", ilitek_data->upgrade_FW_info_addr);
+		}
+		i += 1 + 2 + 4 + 2 + (len * 2) + 2 + offset;
+	}
+	if (hex_end == 0) {
+		tp_log_err("hex file is invalid\n");
+		return -1;
+	}
+	return 0;
+}
+
+static ssize_t ilitek_update_with_hex_read(struct file *pFile, char __user *buf, size_t nCount, loff_t *pPos) {
+	int ret = 0;
+	struct file *filp;
+	struct inode *inode;
+	mm_segment_t fs;
+	off_t fsize;
+	unsigned int ap_startaddr = 0xFFFF, df_startaddr = 0xFFFF, ap_endaddr = 0, df_endaddr = 0, ap_checksum = 0, df_checksum = 0;
+	unsigned char * CTPM_FW = NULL;
+	unsigned char * save_hex_content = NULL;
+	CTPM_FW = (unsigned char * )vmalloc(256 * 1024);/* buf size if even */
+	//CTPM_FW = kmalloc(64 * 1024, GFP_ATOMIC);
+	memset(CTPM_FW, 0, 256 * 1024);
+	tp_log_info("\n");
+    if (*pPos != 0) {
+        return 0;
+    }
+	if (!(CTPM_FW)) {
+		tp_log_err("alloctation CTPM_FW memory failed\n");
+		nCount = sprintf(buf, "alloctation CTPM_FW memory failed\n");
+		goto out;
+	}
+	if (!(strstr(ilitek_hex_path, ".hex"))) {
+		tp_log_err("ilitek_hex_path is invalid ilitek_hex_path = %s\n", ilitek_hex_path);
+		nCount = sprintf(buf, "ilitek_hex_path is invalid ilitek_hex_path = %s\n", ilitek_hex_path);
+		goto out;
+	}
+	else {
+		filp = filp_open(ilitek_hex_path, O_RDONLY, 0);
+		if(IS_ERR(filp)) {
+			tp_log_err("hex File Open Error ilitek_hex_path = %s\n", ilitek_hex_path);
+			nCount = sprintf(buf, "hex File Open Error ilitek_hex_path = %s\n", ilitek_hex_path);
+			goto out;
+		}
+		else{
+			tp_log_info("hex File Open Right,O_RDONLY %s\n", ilitek_hex_path);
+			if(!filp->f_op) {
+				tp_log_err("File Operation Method Error\n");
+				nCount = sprintf(buf, "File Operation Method Error\n");
+				goto out;
+			}
+			else {
+				#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0)
+					inode = filp->f_dentry->d_inode;
+				#else
+					inode = filp->f_path.dentry->d_inode;
+				#endif
+				fsize = inode->i_size;
+
+				tp_log_info("File size:%d \n", (int)fsize);
+				save_hex_content = (unsigned char * )vmalloc((int)fsize);
+				//save_hex_content = kmalloc((int)fsize, GFP_ATOMIC);		/* buf size if even */
+				if (!(save_hex_content)) {
+					tp_log_err("alloctation save_hex_content memory failed\n");
+					nCount = sprintf(buf, "alloctation save_hex_content memory failed\n");
+					goto out;
+				}
+				fs = get_fs();
+				set_fs(KERNEL_DS);
+
+				filp->f_op->read(filp, save_hex_content, fsize, &(filp->f_pos));
+				set_fs(fs);
+
+				filp_close(filp, NULL);
+			}
+		}
+	}
+	ilitek_irq_disable();
+	ret = ilitek_read_tp_info();
+	if (ret < 0) {
+		tp_log_err("ilitek_read_tp_info err ret = %d\n", ret);
+		nCount = sprintf(buf, "ilitek_read_tp_info err ret = %d\n", ret);
+		goto out;
+	}
+	else {
+		if (!ilitek_data->ic_2120) {
+			if ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25) {
+				df_startaddr = 0xF000;
+			}
+			else {
+				df_startaddr = 0x1F000;
+			}
+		}
+		else {
+			df_startaddr = 0xE000;
+		}
+		ret = ilitek_parse_hex_file(&df_startaddr, &df_endaddr, &df_checksum, &ap_startaddr, &ap_endaddr, &ap_checksum, fsize, CTPM_FW, save_hex_content);
+		if (ret < 0) {
+			tp_log_err("ilitek_parse_hex_file err ret = %d\n", ret);
+			nCount = sprintf(buf, "ilitek_parse_hex_file err ret = %d\n", ret);
+			goto out;
+		}
+		if (!(ilitek_data->ic_2120)) {
+			if (ilitek_data->upgrade_FW_info_addr != -1 && (ilitek_data->mcu_ver[0] != CTPM_FW[ilitek_data->upgrade_FW_info_addr + 32 + 6] ||
+				ilitek_data->mcu_ver[1] != CTPM_FW[ilitek_data->upgrade_FW_info_addr + 32 + 7])) {
+				tp_log_err("upgrade file mismatch!!! ic is ILI%02X%02X, upgrade file is ILI%02X%02X\n", ilitek_data->mcu_ver[1], ilitek_data->mcu_ver[0],
+					CTPM_FW[ilitek_data->upgrade_FW_info_addr + 32 + 7], CTPM_FW[ilitek_data->upgrade_FW_info_addr + 32 + 6]);
+				nCount = sprintf(buf, "upgrade file mismatch!!! ic is ILI%02X%02X, upgrade file is ILI%02X%02X\n", ilitek_data->mcu_ver[1], ilitek_data->mcu_ver[0],
+					CTPM_FW[ilitek_data->upgrade_FW_info_addr + 32 + 7], CTPM_FW[ilitek_data->upgrade_FW_info_addr + 32 + 6]);
+				goto out;
+			}
+			else if ((ilitek_data->upgrade_FW_info_addr == -1 && ilitek_data->mcu_ver[0] != 0x03 && ilitek_data->mcu_ver[0] != 0x09)) {
+				tp_log_err("upgrade file  mismatch!!! ic is ILI%02X%02X, upgrade file is maybe ILI230X\n", ilitek_data->mcu_ver[1], ilitek_data->mcu_ver[0]);
+				nCount = sprintf(buf, "upgrade file  mismatch!!! ic is ILI%02X%02X, upgrade file is maybe ILI230X\n", ilitek_data->mcu_ver[1], ilitek_data->mcu_ver[0]);
+				goto out;
+			}
+		}
+		tp_log_info("ilitek ap_startaddr=0x%X, ap_endaddr=0x%X, ap_checksum=0x%X\n", ap_startaddr, ap_endaddr, ap_checksum);
+		tp_log_info("ilitek df_startaddr=0x%X, df_endaddr=0x%X, df_checksum=0x%X\n", df_startaddr, df_endaddr, df_checksum);
+		ilitek_data->firmware_updating = true;
+		ilitek_data->operation_protection = true;
+		if (!(ilitek_data->ic_2120)) {
+			ret = ilitek_upgrade_bigger_size_ic(df_startaddr, df_endaddr, df_checksum, ap_startaddr, ap_endaddr, ap_checksum, CTPM_FW);
+		}
+		else {
+			ret = ilitek_upgrade_2120(CTPM_FW);
+		}
+		ilitek_data->operation_protection = false;
+		ilitek_data->firmware_updating = false;
+		if (ret < 0) {
+			tp_log_err("upgrade fail ret = %d\n", ret);
+			nCount = sprintf(buf, "upgrade fail ret = %d\n", ret);
+			goto out;
+		}
+	}
+
+	ret = ilitek_read_tp_info();
+	nCount = sprintf(buf, "upgrade successfull ilitek firmware version is %d.%d.%d.%d.%d.%d.%d.%d\n", ilitek_data->firmware_ver[0], ilitek_data->firmware_ver[1],
+		ilitek_data->firmware_ver[2], ilitek_data->firmware_ver[3], ilitek_data->firmware_ver[4], ilitek_data->firmware_ver[5],
+		ilitek_data->firmware_ver[6], ilitek_data->firmware_ver[7]);
+out:
+	ilitek_irq_enable();
+	if (CTPM_FW) {
+		vfree(CTPM_FW);
+	}
+	if (save_hex_content) {
+		vfree(save_hex_content);
+	}
+    *pPos += nCount;
+	return nCount;
+}
+
+
+static ssize_t ilitek_update_with_hex_write(struct file *pFile, const char __user *buf, size_t size, loff_t *pPos) {	
+	int i = 0;
+	tp_log_info("size = %d\n", (int)size);
+	if (size > 256) {
+		tp_log_err("size > 256 not support size = %d\n", (int)size);
+	}
+	else {
+		for (i = 0; i < (size - 1); i++) {
+			tp_log_info("%c\n", buf[i]);
+			ilitek_hex_path[i] = buf[i];
+		}
+		ilitek_hex_path[size - 1] = '\0';
+		tp_log_info("ilitek_hex_path = %s\n", ilitek_hex_path);
+	}
+	return size;
+}
+static const struct file_operations ilitek_proc_fops_fwupdate = { 
+	.read = ilitek_update_with_hex_read,
+	.write = ilitek_update_with_hex_write,
+};
+static ssize_t ilitek_firmware_version_read(struct file *pFile, char __user *buf, size_t nCount, loff_t *pPos) {
+	int ret = 0;
+	tp_log_info("\n");
+    if (*pPos != 0) {
+        return 0;
+    }
+	ilitek_irq_disable();
+	ret = ilitek_read_tp_info();
+	ilitek_irq_enable();
+	if (ret < 0) {
+		tp_log_err("ilitek_read_tp_info err ret = %d\n", ret);
+		nCount = sprintf(buf, "ilitek firmware version read error ret = %d\n", ret);
+		
+	}
+	else {
+		nCount = sprintf(buf, "ilitek firmware version is %d.%d.%d.%d.%d.%d.%d.%d\n", ilitek_data->firmware_ver[0], ilitek_data->firmware_ver[1],
+			ilitek_data->firmware_ver[2], ilitek_data->firmware_ver[3], ilitek_data->firmware_ver[4], ilitek_data->firmware_ver[5],
+			ilitek_data->firmware_ver[6], ilitek_data->firmware_ver[7]);
+	}
+    *pPos += nCount;
+	return nCount;
+}
+
+static const struct file_operations ilitek_proc_fops_fwversion = { 
+	.read = ilitek_firmware_version_read,
+	.write = NULL,
+};
+
+int ilitek_create_tool_node(void) {
+	int ret = 0;
+	// allocate character device driver buffer
+	ret = alloc_chrdev_region(&ilitek_dev.devno, 0, 1, "ilitek_file");
+	if (ret) {
+		tp_log_err("can't allocate chrdev\n");
+		//return ret;
+	}
+	else {
+		tp_log_info("register chrdev(%d, %d)\n", MAJOR(ilitek_dev.devno), MINOR(ilitek_dev.devno));
+
+		// initialize character device driver
+		cdev_init(&ilitek_dev.cdev, &ilitek_fops);
+		ilitek_dev.cdev.owner = THIS_MODULE;
+		ret = cdev_add(&ilitek_dev.cdev, ilitek_dev.devno, 1);
+		if (ret < 0) {
+			tp_log_err("add character device error, ret %d\n", ret);
+			//return ret;
+		}
+		else {
+			ilitek_dev.class = class_create(THIS_MODULE, "ilitek_file");
+			if (IS_ERR(ilitek_dev.class)) {
+				tp_log_err("create class, error\n");
+				//return ret;
+			}
+			device_create(ilitek_dev.class, NULL, ilitek_dev.devno, NULL, "ilitek_ctrl");
+		}
+	}
+	ilitek_proc = proc_create("ilitek_ctrl", 0666, NULL, &ilitek_fops);
+	if (ilitek_proc == NULL) {
+		tp_log_err("proc_create(ilitek_ctrl, 0666, NULL, &ilitek_fops) fail\n");
+	}
+#ifdef ILITEK_TUNING_NODE	
+	ilitek_proc_debug = proc_create("ilitek_debug", 0666, NULL, &ilitek_debug_fops);
+	if (ilitek_proc_debug == NULL) {
+		tp_log_err("proc_create(ilitek_debug, 0666, NULL, &ilitek_debug_fops) fail\n");
+	}
+	init_waitqueue_head(&(ilitek_data->inq));
+	ilitek_data->send_data = true;
+#endif
+	ilitek_proc_entry = proc_mkdir("ilitek", NULL);
+	if (!ilitek_proc_entry) {
+		tp_log_err("Error, failed to creat procfs.\n");
+	}
+	else {
+		if (!proc_create("firmware_version", 0666, ilitek_proc_entry, &ilitek_proc_fops_fwversion)) {
+			tp_log_err("Error, failed to creat procfs firmware_version.\n");
+			remove_proc_entry("firmware_version", ilitek_proc_entry);
+		}
+		if (!proc_create("update_firmware", 0666, ilitek_proc_entry, &ilitek_proc_fops_fwupdate)) {
+			tp_log_err("Error, failed to creat procfs update_firmware.\n");
+			remove_proc_entry("update_firmware", ilitek_proc_entry);
+		}
+		if (!proc_create("sensor_test_data", 0666, ilitek_proc_entry, &ilitek_proc_fops_sensortest)) {
+			tp_log_err("Error, failed to creat procfs sensor_test.\n");
+			remove_proc_entry("sensor_test_data", ilitek_proc_entry);
+		}
+		if (!proc_create("noisefre_data", 0666, ilitek_proc_entry, &ilitek_proc_fops_noisefre)) {
+			tp_log_err("Error, failed to creat procfs noisefre_data.\n");
+			remove_proc_entry("noisefre_data", ilitek_proc_entry);
+		}
+	}
+	return 0;
+}
+
+int ilitek_remove_tool_node(void) {
+	cdev_del(&ilitek_dev.cdev);
+	unregister_chrdev_region(ilitek_dev.devno, 1);
+	device_destroy(ilitek_dev.class, ilitek_dev.devno);
+	class_destroy(ilitek_dev.class);
+	if (ilitek_proc) {
+		tp_log_info("remove procfs ilitek_ctrl.\n");
+		remove_proc_entry("ilitek_ctrl", NULL);
+		ilitek_proc = NULL;
+	}
+#ifdef ILITEK_TUNING_NODE	
+	if (ilitek_proc_debug) {
+		tp_log_info("remove procfs ilitek_ctrl.\n");
+		remove_proc_entry("ilitek_debug", NULL);
+		ilitek_proc_debug = NULL;
+	}
+#endif
+	if (ilitek_proc_entry) {
+		tp_log_info("remove procfs firmware_version.\n");
+		remove_proc_entry("firmware_version", ilitek_proc_entry);
+		tp_log_info("remove procfs update_firmware.\n");
+		remove_proc_entry("update_firmware", ilitek_proc_entry);
+		tp_log_info("remove procfs sensor_test_data.\n");
+		remove_proc_entry("sensor_test_data", ilitek_proc_entry);
+		tp_log_info("remove procfs noisefre_data.\n");
+		remove_proc_entry("noisefre_data", ilitek_proc_entry);
+		tp_log_info("remove procfs ilitek.\n");
+		remove_proc_entry("ilitek", NULL);
+		ilitek_proc_entry = NULL;
+	}
+	return 0;
+}
+#endif
diff --git a/drivers/input/touchscreen/ilitek_ts.h b/drivers/input/touchscreen/ilitek_ts.h
new file mode 100755
index 000000000000..8f74be36e477
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_ts.h
@@ -0,0 +1,492 @@
+/*
+ * ILITEK Touch IC driver
+ *
+ * Copyright (C) 2011 ILI Technology Corporation.
+ *
+ * Author: Jijie Wang <jijie_wang@ilitek.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA.
+ * 
+ */
+
+#ifndef __ILITEK_TS_H__
+#define __ILITEK_TS_H__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include <linux/version.h>
+#include <linux/rtc.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/pm_runtime.h>
+#ifdef CONFIG_OF
+#include <linux/of_gpio.h>
+#endif
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#endif
+
+//driver information
+#define DERVER_VERSION_MAJOR 		5
+#define DERVER_VERSION_MINOR 		1
+#define CUSTOMER_ID 				0
+#define MODULE_ID					0
+#define PLATFORM_ID					0
+#define PLATFORM_MODULE				0
+#define ENGINEER_ID					0
+
+#define ILITEK_PLAT_QCOM												1
+#define ILITEK_PLAT_MTK													2
+#define ILITEK_PLAT_ROCKCHIP											3
+#define ILITEK_PLAT_ALLWIN												4
+#define ILITEK_PLAT_AMLOGIC												5
+
+#define ILITEK_PLAT														ILITEK_PLAT_QCOM
+
+
+#define ILITEK_TOOL
+
+//#define ILITEK_GLOVE
+
+//#define ILITEK_CHARGER_DETECTION
+#define POWER_SUPPLY_BATTERY_STATUS_PATCH  "/sys/class/power_supply/battery/status"
+
+//#define ILITEK_ESD_PROTECTION
+
+#define ILITEK_TOUCH_PROTOCOL_B
+
+//#define ILITEK_USE_LCM_RESOLUTION
+
+#define ILITEK_ROTATE_FLAG												0
+#define ILITEK_REVERT_X													0
+#define ILITEK_REVERT_Y													0
+#define TOUCH_SCREEN_X_MAX   											(1080)  //LCD_WIDTH
+#define TOUCH_SCREEN_Y_MAX   											(1920) //LCD_HEIGHT
+
+#define ILITEK_ENABLE_REGULATOR_POWER_ON
+#define ILITEK_GET_GPIO_NUM
+
+
+#define ILITEK_CLICK_WAKEUP												0
+#define ILITEK_DOUBLE_CLICK_WAKEUP										1
+#define ILITEK_GESTURE_WAKEUP											2
+//#define ILITEK_GESTURE													ILITEK_CLICK_WAKEUP
+
+//#define ILITEK_UPDATE_FW
+#define ILI_UPDATE_BY_CHECK_INT
+
+#define ILITEK_TS_NAME													"tchip,ilitek"
+#define ILITEK_TUNING_MESSAGE											0xDB
+#define ILITEK_TUNING_NODE												0xDB
+
+#define ILITEK_UPGRADE_WITH_BIN											0
+#define ILITEK_FW_FILENAME												"ilitek_i2c.bin"
+
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+
+//#define NO_USE_MTK_ANDROID_SDK_6_UPWARD //no use dts and for mtk old version
+#define ILITEK_ENABLE_DMA
+#define ILITEK_USE_MTK_INPUT_DEV
+#if defined ILITEK_GET_GPIO_NUM
+#undef ILITEK_GET_GPIO_NUM
+#endif
+
+#include <linux/sched.h>
+#include <linux/kthread.h>
+//#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+
+#define TPD_KEY_COUNT   4
+#define key_1           60,17000             //auto define  
+#define key_2           180,17000
+#define key_3           300,17000
+#define key_4           420,17000
+
+#define TPD_KEYS        {KEY_MENU, KEY_HOMEPAGE, KEY_BACK, KEY_SEARCH}	//change for you panel key info
+#define TPD_KEYS_DIM    {{key_1,50,30},{key_2,50,30},{key_3,50,30},{key_4,50,30}}
+
+struct touch_vitual_key_map_t
+{
+	int point_x;
+	int point_y;
+};
+
+extern struct touch_vitual_key_map_t touch_key_point_maping_array[];
+
+
+#include <mach/mt_pm_ldo.h>
+#include <cust_eint.h>
+
+#include "cust_gpio_usage.h"
+#include <mach/mt_gpio.h>
+//#include <mach/mt_reg_base.h>
+#include <mach/mt_typedefs.h>
+//#include <mach/eint.h>
+#include <pmic_drv.h>
+#include <mach/mt_boot.h>
+
+#include <linux/dma-mapping.h>
+
+#else
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/gpio.h>
+
+#ifdef CONFIG_MTK_BOOT
+#include "mt_boot_common.h"
+#endif
+
+#endif
+
+#include "tpd.h"
+#endif
+
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+#include <linux/irq.h>
+#include <linux/init-input.h>
+#include <linux/pm.h>
+#include <linux/gpio.h>
+extern struct ctp_config_info config_info;
+
+
+#endif
+
+
+#ifndef ILITEK_GET_GPIO_NUM
+//must set
+#if ILITEK_PLAT == ILITEK_PLAT_MTK
+#ifdef NO_USE_MTK_ANDROID_SDK_6_UPWARD
+#define ILITEK_IRQ_GPIO													 GPIO_CTP_EINT_PIN   
+#define ILITEK_RESET_GPIO 												GPIO_CTP_RST_PIN 
+#else
+#define IMX_GPIO_NR(bank, nr)		(((bank) - 1) * 32 + (nr))
+#define ILITEK_IRQ_GPIO													IMX_GPIO_NR(5, 11)
+#define ILITEK_RESET_GPIO												IMX_GPIO_NR(5, 12)
+#endif
+#elif ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+#define ILITEK_IRQ_GPIO													(config_info.int_number)
+#define ILITEK_RESET_GPIO												(config_info.wakeup_gpio.gpio)
+#else
+#define ILITEK_IRQ_GPIO													9
+#define ILITEK_RESET_GPIO												10
+#endif
+#endif
+
+#ifdef ILITEK_TUNING_MESSAGE
+#include <linux/kernel.h> 
+#include <linux/init.h> 
+#include <net/sock.h>
+#include <net/netlink.h>
+#include <linux/skbuff.h>
+#include <linux/module.h>  
+#include <linux/netlink.h>  
+#include <linux/sched.h>  
+#include <net/sock.h>  
+#include <linux/proc_fs.h>  
+#include <linux/netfilter.h>  
+#include <linux/netfilter_ipv4.h>  
+#include <linux/ip.h>  
+#include <linux/tcp.h>  
+#include <linux/icmp.h>  
+#include <linux/udp.h>
+#endif
+
+#define ILITEK_TP_CMD_READ_MODE											0xC0
+#define ILITEK_TP_MODE_APPLICATION										0x5A
+#define ILITEK_TP_MODE_BOOTLOADER										0x55
+#define ILITEK_TP_CMD_WRITE_ENABLE										0xC4
+#define ILITEK_TP_CMD_WRITE_DATA										0xC3
+#define ILITEK_TP_CMD_SLEEP												0x30
+#define ILITEK_TP_CMD_GET_FIRMWARE_VERSION								0x40
+#define ILITEK_TP_CMD_GET_PROTOCOL_VERSION								0x42
+#define ILITEK_TP_CMD_GET_KERNEL_VERSION								0x61
+#define ILITEK_TP_CMD_GET_TP_RESOLUTION									0x20
+#define ILITEK_TP_CMD_GET_SCREEN_RESOLUTION								0x21
+#define ILITEK_TP_CMD_GET_KEY_INFORMATION								0x22
+#define ILITEK_TP_CMD_GET_TOUCH_INFORMATION								0x10
+
+#define AP_STARTADDR													0x00
+#define AP_ENDADDR														0xDFFF
+#define UPGRADE_TRANSMIT_LEN											256
+#define FW_VERSION1														0xD100
+#define FW_VERSION2														0xD101
+#define FW_VERSION3														0xD102
+
+#define PRODUCT_ID_STARTADDR											0xE000
+#define PRODUCT_ID_ENDADDR												0xE006
+
+#define SECTOR_SIZE														0x1000
+#define SECTOR_ENDADDR													0xD000
+
+#define REG_LEN															4
+#define REG_START_DATA													0x25
+
+#define ENTER_ICE_MODE													0x181062
+#define ENTER_ICE_MODE_NO_DATA											0x0
+
+#define EXIT_ICE_MODE													0x1810621B
+
+#define REG_FLASH_CMD													0x041000
+#define REG_FLASH_CMD_DATA_ERASE										0x20
+#define REG_FLASH_CMD_DATA_PROGRAMME									0x02
+#define REG_FLASH_CMD_READ_FLASH_STATUS									0x5
+#define REG_FLASH_CMD_WRITE_ENABLE										0x6
+#define REG_FLASH_CMD_MEMORY_READ										0x3B
+#define REG_FLASH_CMD_RELEASE_FROM_POWER_DOWN							0xab
+
+#define REG_PGM_NUM														0x041004
+#define REG_PGM_NUM_TRIGGER_KEY											0x66aa5500
+#define REG_PGM_LEN														(0x66aa5500 + UPGRADE_TRANSMIT_LEN - 1)
+
+#define REG_READ_NUM													0x041009
+#define REG_READ_NUM_1													0x0
+
+#define REG_CHK_EN														0x04100B
+#define REG_CHK_EN_PARTIAL_READ 										0x3
+
+#define REG_TIMING_SET													0x04100d
+#define REG_TIMING_SET_10MS												0x00
+
+#define REG_CHK_FLAG													0x041011
+#define FLASH_READ_DATA													0x041012
+#define FLASH_STATUS													0x041013
+#define REG_PGM_DATA													0x041020
+
+#define WDTRLDT                            								0x5200C
+#define WDTRLDT_CLOSE                            						0
+#define WDTCNT1                     									0x52020
+#define WDTCNT1_OPEN                     								1
+#define WDTCNT1_CLOSE                     								0
+
+#define CLOSE_10K_WDT1													0x42000
+#define CLOSE_10K_WDT1_VALUE											0x0f154900
+
+#define CLOSE_10K_WDT2													0x42014
+#define CLOSE_10K_WDT2_VALUE											0x02
+
+#define CLOSE_10K_WDT3													0x42000
+#define CLOSE_10K_WDT3_VALUE											0x00000000
+
+#define DATA_SHIFT_0													0x000000FF
+#define DATA_SHIFT_8													0x0000FF00
+#define DATA_SHIFT_16													0x00FF0000
+#define DATA_SHIFT_24													0xFF000000
+
+
+#define ILITEK_TP_CMD_READ_DATA_CONTROL_2120							0xF6
+#define ILITEK_TP_CMD_GET_FIRMWARE_VERSION_2120							0x21
+#define ILITEK_TP_CMD_GET_PROTOCOL_VERSION_2120							0x22
+#define ILITEK_TP_CMD_GET_KEY_INFORMATION_2120							0x27
+#define ILITEK_TP_CMD_SLEEP_2120										0x02
+
+#define ILITEK_TP_UPGRADE_FAIL											(-5)
+#define ILITEK_I2C_TRANSFER_ERR											(-4)
+#define ILITEK_TP_CHANGETOBL_ERR										(-3)
+#define ILITEK_TP_CHANGETOAP_ERR										(-2)
+
+#define ILITEK_ERR_LOG_LEVEL 											(1)   
+#define ILITEK_INFO_LOG_LEVEL 											(3)   
+#define ILITEK_DEBUG_LOG_LEVEL 											(4)  
+#define ILITEK_DEFAULT_LOG_LEVEL										(3)   
+
+#define debug_level(level, fmt, arg...) do {\
+	if (level <= ilitek_log_level_value) {\
+		if (level == ILITEK_ERR_LOG_LEVEL) {\
+			printk(" %s ERR  line = %d %s : "fmt, "ILITEK", __LINE__, __func__, ##arg);\
+		}\
+		else if (level == ILITEK_INFO_LOG_LEVEL) {\
+			printk(" %s INFO line = %d %s : "fmt, "ILITEK", __LINE__, __func__, ##arg);\
+		}\
+		else if (level == ILITEK_DEBUG_LOG_LEVEL) {\
+			printk(" %s DEBUG line = %d %s : "fmt, "ILITEK", __LINE__, __func__, ##arg);\
+		}\
+	}\
+} while (0)
+
+#define tp_log_err(fmt, arg...) debug_level(ILITEK_ERR_LOG_LEVEL, fmt, ##arg) 
+#define tp_log_info(fmt, arg...) debug_level(ILITEK_INFO_LOG_LEVEL, fmt, ##arg) 
+#define tp_log_debug(fmt, arg...) debug_level(ILITEK_DEBUG_LOG_LEVEL, fmt, ##arg) 
+
+
+struct ilitek_key_info {
+	int id;
+	int x;
+	int y;
+	int status;
+	int flag;
+};
+
+struct ilitek_ts_data {
+    struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct regulator *vdd;
+	struct regulator *vdd_i2c;
+	struct regulator *vcc_io;
+	int irq_gpio;
+	int reset_gpio;
+	bool ic_2120;
+	bool system_suspend;
+	unsigned char firmware_ver[8];
+	unsigned char mcu_ver[8];
+	unsigned char bl_ver[4];
+	int upgrade_FW_info_addr;
+	unsigned char upgrade_mcu_ver[4];
+	int protocol_ver;
+	int tp_max_x;
+	int tp_max_y;
+	int tp_min_x;
+	int tp_min_y;
+	int screen_max_x;
+	int screen_max_y;
+	int screen_min_x;
+	int screen_min_y;
+	int max_tp;
+	int max_btn;
+	int x_ch;
+	int y_ch;
+	int keycount;
+	int key_xlen;
+	int key_ylen;
+	struct ilitek_key_info keyinfo[10];
+	bool irq_status;
+	bool irq_trigger;
+	struct task_struct * irq_thread;
+	spinlock_t irq_lock;
+	bool is_touched;
+	bool touch_key_hold_press;
+	int touch_flag[10];
+	
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+//#ifdef ILITEK_UPDATE_FW
+	bool force_update;
+	bool has_df;
+	int page_number;
+	struct task_struct * update_thread;
+//#endif
+	bool firmware_updating;
+	bool operation_protection;
+
+#ifdef ILITEK_GESTURE
+	bool enable_gesture;
+#endif
+
+#ifdef ILITEK_GLOVE
+	bool enable_glove;
+#endif
+
+#ifdef ILITEK_CHARGER_DETECTION
+	struct workqueue_struct *charge_wq;
+	struct delayed_work charge_work;
+	bool charge_check;
+	unsigned long charge_delay;
+#endif
+
+#ifdef ILITEK_ESD_PROTECTION
+	 struct workqueue_struct *esd_wq;
+	 struct delayed_work esd_work;
+	 bool esd_check;
+	 unsigned long esd_delay;
+#endif
+
+	struct kobject * ilitek_func_kobj;
+	struct mutex ilitek_mutex;
+#ifdef ILITEK_TUNING_NODE
+		bool debug_node_open;
+		bool have_data;
+		bool send_data;
+		wait_queue_head_t inq;
+		unsigned char debug_buf[64];
+		struct mutex ilitek_debug_mutex;
+#endif
+
+};
+
+#define ILITEK_I2C_RETRY_COUNT											3
+
+extern int ilitek_log_level_value;
+extern char ilitek_driver_information[];
+extern struct ilitek_ts_data * ilitek_data;
+extern void ilitek_resume(void);
+extern void ilitek_suspend(void);
+
+extern int ilitek_main_probe(struct ilitek_ts_data * ilitek_data);
+extern int ilitek_main_remove(struct ilitek_ts_data * ilitek_data);
+extern void ilitek_reset(int delay);
+extern int ilitek_poll_int(void);
+extern int ilitek_i2c_write(uint8_t * cmd, int length);
+extern int ilitek_i2c_read(uint8_t *data, int length);
+extern int ilitek_i2c_write_and_read(uint8_t *cmd,
+			int write_len, int delay, uint8_t *data, int read_len);
+
+extern void ilitek_irq_enable(void);
+extern void ilitek_irq_disable(void);
+extern int ilitek_read_tp_info(void);
+
+#ifdef ILITEK_UPDATE_FW
+extern int ilitek_upgrade_firmware(void);
+#endif
+extern int ilitek_upgrade_bigger_size_ic(unsigned int df_startaddr, unsigned int df_endaddr, unsigned int df_checksum,
+	unsigned int ap_startaddr, unsigned int ap_endaddr, unsigned int ap_checksum, unsigned char * CTPM_FW);
+extern int ilitek_upgrade_2120(unsigned char * CTPM_FW);
+
+#ifdef ILITEK_TUNING_MESSAGE
+extern bool ilitek_debug_flag;
+#endif
+#ifdef ILITEK_TOOL
+extern int ilitek_create_tool_node(void);
+extern int ilitek_remove_tool_node(void);
+#endif
+#if ILITEK_PLAT == ILITEK_PLAT_ALLWIN
+extern int ilitek_suspend_allwin(struct i2c_client *client, pm_message_t mesg);
+extern int ilitek_resume_allwin(struct i2c_client *client);
+#endif
+
+#endif
diff --git a/drivers/input/touchscreen/ilitek_update.c b/drivers/input/touchscreen/ilitek_update.c
new file mode 100755
index 000000000000..1f083d17e8c4
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_update.c
@@ -0,0 +1,942 @@
+/*
+ * ILITEK Touch IC driver
+ *
+ * Copyright (C) 2011 ILI Technology Corporation.
+ *
+ * Author: Jijie Wang <jijie_wang@ilitek.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA.
+ * 
+ */
+
+#include "ilitek_ts.h"
+#include <linux/firmware.h>
+#include <linux/vmalloc.h>
+
+#ifdef ILITEK_UPDATE_FW
+#if !ILITEK_UPGRADE_WITH_BIN
+#include "ilitek_fw.h"
+#endif
+#endif
+
+unsigned int UpdateCRC(unsigned int crc, unsigned char newbyte)
+{
+   char i;                                  // loop counter
+   #define CRC_POLY 0x8408      // CRC16-CCITT FCS (X^16+X^12+X^5+1)
+
+   crc = crc ^ newbyte;
+
+   for (i = 0; i < 8; i++)
+   {
+      if (crc & 0x01)
+      {
+         crc = crc >> 1;
+         crc ^= CRC_POLY;
+      }
+      else
+      {
+         crc = crc >> 1;
+      }
+   }
+   return crc;
+}
+
+int check_busy(int delay)
+{
+	int i;
+	unsigned char buf[2];
+	for(i = 0; i < 1000; i ++){
+		buf[0] = 0x80;
+		if(ilitek_i2c_write_and_read(buf, 1, delay, buf, 1) < 0) {
+			return ILITEK_I2C_TRANSFER_ERR;
+		}
+		if(buf[0] == 0x50) {
+			//tp_log_info("check_busy i = %d\n", i);
+			return 0;
+		}
+	}
+	tp_log_info("check_busy error\n");
+	return -1;
+}
+int ilitek_changetoblmode(bool mode) {
+	int ret = 0, i = 0;
+	unsigned char buf[8];
+	buf[0] = 0xc0;
+	ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 2);
+	if(ret < 0)
+	{
+		tp_log_err("ilitek_i2c_write_and_read\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}		
+	msleep(30);
+	tp_log_info("ilitek ic. mode =%d , it's %s \n",buf[0],((buf[0] == 0x5A)?"AP MODE":((buf[0] == ILITEK_TP_MODE_BOOTLOADER) ? "BL MODE" : "UNKNOW MODE")));
+	if ((buf[0] == ILITEK_TP_MODE_APPLICATION && !mode) || (buf[0] == ILITEK_TP_MODE_BOOTLOADER && mode)) {
+		if (mode) {
+			tp_log_info("ilitek change to BL mode ok already BL mode\n");
+		}
+		else {
+			tp_log_info("ilitek change to AP mode ok already AP mode\n");
+		}
+	}
+	else {
+		for (i = 0; i < 5; i++) {
+			buf[0] = ILITEK_TP_CMD_WRITE_ENABLE;
+			buf[1] = 0x5A;
+			buf[2] = 0xA5;
+			ret = ilitek_i2c_write(buf, 3);
+			if(ret < 0)
+			{
+				tp_log_err("ilitek_i2c_write_and_read\n");
+				return ILITEK_I2C_TRANSFER_ERR;
+			}		
+			msleep(20);
+			if (mode) {
+				buf[0] = 0xc2;
+			}
+			else {
+				buf[0] = 0xc1;
+			}
+			ret = ilitek_i2c_write(buf, 1);
+			if(ret < 0)
+			{
+				tp_log_err("ilitek_i2c_write ERR\n");
+				return ILITEK_I2C_TRANSFER_ERR;
+			}		
+			msleep(200);
+			buf[0] = 0xc0;
+			ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 2);
+			if(ret < 0)
+			{
+				tp_log_err("ilitek_i2c_write_and_read\n");
+				return ILITEK_I2C_TRANSFER_ERR;
+			}		
+			msleep(30);
+			tp_log_info("ilitek ic. mode =%d , it's  %s \n",buf[0],((buf[0] == ILITEK_TP_MODE_APPLICATION) ? "AP MODE" : ((buf[0] == ILITEK_TP_MODE_BOOTLOADER) ? "BL MODE" : "UNKNOW MODE")));
+			if ((buf[0] == ILITEK_TP_MODE_APPLICATION && !mode) || (buf[0] == ILITEK_TP_MODE_BOOTLOADER && mode)) {
+				if (mode) {
+					tp_log_info("ilitek change to BL mode ok\n");
+				}
+				else {
+					tp_log_info("ilitek change to AP mode ok\n");
+				}
+				break;
+			}
+		}
+	}
+	if (i >= 5) {
+		if (mode) {
+			tp_log_err("change to bl mode err, 0x%X\n", buf[0]);
+			return ILITEK_TP_CHANGETOBL_ERR;
+		}
+		else {
+			tp_log_err("change to ap mode err, 0x%X\n", buf[0]);
+			return ILITEK_TP_CHANGETOAP_ERR;
+		}
+	}
+	else {
+		return 0;
+	}
+}
+int ilitek_upgrade_2302or2312(unsigned int df_startaddr, unsigned int df_endaddr, unsigned int df_checksum,
+	unsigned int ap_startaddr, unsigned int ap_endaddr, unsigned int ap_checksum, unsigned char * CTPM_FW) {
+	int ret = 0, upgrade_status = 0, i = 0, j = 0, k = 0, tmp_ap_end_addr = 0;
+	unsigned char buf[64] = {0};
+	if (ilitek_data->bl_ver[0] >= 1 && ilitek_data->bl_ver[1] >= 4) {
+		buf[0] = (unsigned char)ILITEK_TP_CMD_WRITE_ENABLE;//0xc4
+		buf[1] = 0x5A;
+		buf[2] = 0xA5;
+		buf[3] = 0x81;
+		
+		if (!ilitek_data->has_df) { 
+			tp_log_info("ilitek no df data set df_endaddr 0x1ffff\n");
+			df_endaddr = 0x1ffff;
+			df_checksum = 0x1000 * 0xff;
+			buf[4] = df_endaddr >> 16;
+			buf[5] = (df_endaddr >> 8) & 0xFF;
+			buf[6] = (df_endaddr) & 0xFF;
+			buf[7] = df_checksum >> 16;
+			buf[8] = (df_checksum >> 8) & 0xFF;
+			buf[9] = df_checksum & 0xFF;
+		}
+		else {
+			buf[4] = df_endaddr >> 16;
+			buf[5] = (df_endaddr >> 8) & 0xFF;
+			buf[6] = (df_endaddr) & 0xFF;
+			buf[7] = df_checksum >> 16;
+			buf[8] = (df_checksum >> 8) & 0xFF;
+			buf[9] = df_checksum & 0xFF;
+		}
+		tp_log_info("ilitek df_startaddr=0x%X, df_endaddr=0x%X, df_checksum=0x%X\n", df_startaddr, df_endaddr, df_checksum);
+		ret = ilitek_i2c_write(buf, 10);
+		if(ret < 0)
+		{
+			tp_log_err("ilitek_i2c_write\n");
+		}		
+		msleep(20);
+		j = 0;
+		for(i = df_startaddr; i < df_endaddr; i += 32)
+		{
+			buf[0] = ILITEK_TP_CMD_WRITE_DATA;
+			for(k = 0; k < 32; k++)
+			{
+				if (ilitek_data->has_df) { 
+					if ((i + k) >= df_endaddr) {
+						buf[1 + k] = 0x00;
+					}
+					else {
+						buf[1 + k] = CTPM_FW[i + 32 + k];
+					}
+				}
+				else {
+					buf[1 + k] = 0xff;
+				}
+			}
+		
+			ret = ilitek_i2c_write(buf, 33);
+			if(ret < 0)
+			{
+				tp_log_err("ilitek_i2c_write_and_read\n");
+				return ILITEK_I2C_TRANSFER_ERR;
+			}		
+			j += 1;
+			
+		#ifdef ILI_UPDATE_BY_CHECK_INT
+			for (k = 0; k < 40; k++) {
+				if (!(ilitek_poll_int())) {
+					break;
+				}
+				else {
+					mdelay(1);
+				}
+			}
+			if (k >= 40) {
+				tp_log_err("upgrade check int fail retry = %d\n", k);
+			}
+		#else
+			if((j % (ilitek_data->page_number)) == 0) {
+				//msleep(30);
+				mdelay(20);
+			}
+			mdelay(10);
+		#endif
+			upgrade_status = ((i - df_startaddr) * 100) / (df_endaddr - df_startaddr);
+			if (upgrade_status % 10 == 0) {
+				tp_log_info("%c ilitek ILITEK: Firmware Upgrade(Data flash), %02d%c. \n",0x0D,upgrade_status,'%');
+			}
+		}
+		buf[0] = (unsigned char)ILITEK_TP_CMD_WRITE_ENABLE;//0xc4
+		buf[1] = 0x5A;
+		buf[2] = 0xA5;
+		buf[3] = 0x80;
+		if (((ap_endaddr + 1) % 32) != 0) {
+			tp_log_info("ap_endaddr = 0x%X\n", (int)(ap_endaddr + 32 + 32 - ((ap_endaddr + 1) % 32)));
+			buf[4] = (ap_endaddr + 32 + 32 - ((ap_endaddr + 1) % 32)) >> 16;
+			buf[5] = ((ap_endaddr + 32 + 32 - ((ap_endaddr + 1) % 32)) >> 8) & 0xFF;
+			buf[6] = ((ap_endaddr + 32 + 32 - ((ap_endaddr + 1) % 32))) & 0xFF;
+			tp_log_info("ap_checksum = 0x%X\n", (int)(ap_checksum + (32 + 32 - ((ap_endaddr + 1) % 32)) * 0xff));
+			buf[7] = (ap_checksum + (32 + 32 -((ap_endaddr + 1) % 32)) * 0xff) >> 16;
+			buf[8] = ((ap_checksum + (32 + 32 -((ap_endaddr + 1) % 32)) * 0xff) >> 8) & 0xFF;
+			buf[9] = (ap_checksum + (32 + 32 - ((ap_endaddr + 1) % 32)) * 0xff) & 0xFF;
+		}
+		else {
+			tp_log_info("32 0 ap_endaddr  32 = 0x%X\n", (int)(ap_endaddr + 32));
+			tp_log_info("ap_endaddr = 0x%X\n", (int)(ap_endaddr + 32));
+			buf[4] = (ap_endaddr + 32) >> 16;
+			buf[5] = ((ap_endaddr + 32) >> 8) & 0xFF;
+			buf[6] = ((ap_endaddr + 32)) & 0xFF;
+			tp_log_info("ap_checksum = 0x%X\n", (int)(ap_checksum + 32 * 0xff));
+			buf[7] = (ap_checksum + 32 * 0xff) >> 16;
+			buf[8] = ((ap_checksum + 32 * 0xff) >> 8) & 0xFF;
+			buf[9] = (ap_checksum + 32 * 0xff) & 0xFF;
+		}
+		ret = ilitek_i2c_write(buf, 10);
+		msleep(20);
+		tmp_ap_end_addr = ap_endaddr;
+		ap_endaddr += 32;
+		j = 0;
+		for(i = ap_startaddr; i < ap_endaddr; i += 32)
+		{
+			buf[0] = ILITEK_TP_CMD_WRITE_DATA;
+			for(k = 0; k < 32; k++)
+			{
+				if((i + k) > tmp_ap_end_addr) {
+					buf[1 + k] = 0xff;
+				}
+				else {
+					buf[1 + k] = CTPM_FW[i + k + 32];
+				}
+			}
+		
+			buf[0] = 0xc3;
+			ret = ilitek_i2c_write(buf, 33);
+			if(ret < 0)
+			{
+				tp_log_err("%s, ilitek_i2c_write_and_read\n", __func__);
+				return ILITEK_I2C_TRANSFER_ERR;
+			}		
+			j += 1;
+	#ifdef ILI_UPDATE_BY_CHECK_INT
+			for (k = 0; k < 40; k++) {
+				if (!(ilitek_poll_int())) {
+					break;
+				}
+				else {
+					mdelay(1);
+				}
+			}
+			if (k >= 40) {
+				tp_log_err("upgrade check int fail retry = %d\n", k);
+			}
+	#else
+			if((j % (ilitek_data->page_number)) == 0) {
+				mdelay(20);
+			}
+			mdelay(10);
+	#endif
+			upgrade_status = (i * 100) / ap_endaddr;
+			if (upgrade_status % 10 == 0) {
+				tp_log_info("%c ilitek ILITEK: Firmware Upgrade(AP), %02d%c. \n", 0x0D, upgrade_status, '%');
+			}
+		}
+	}
+	else {
+		tp_log_info("not support this bl version upgrade flow\n");
+	}
+	return 0;
+}
+int ilitek_upgrade_2511(unsigned int df_startaddr, unsigned int df_endaddr,
+	unsigned int ap_startaddr, unsigned int ap_endaddr, unsigned char * CTPM_FW) {
+	int ret = 0, upgrade_status = 0, i = 0, k = 0, CRC_DF = 0, CRC_AP = 0;
+	unsigned char buf[64] = {0};
+	for(i = df_startaddr + 2; i < df_endaddr; i++)
+	{
+		CRC_DF = UpdateCRC(CRC_DF, CTPM_FW[i + 32]);
+	}	
+	tp_log_info("CRC_DF = 0x%X\n", CRC_DF);
+	for(i = ap_startaddr; i < ap_endaddr - 1; i++)
+	{
+		CRC_AP = UpdateCRC(CRC_AP, CTPM_FW[i + 32]);
+	}
+	tp_log_info("CRC_AP = 0x%x\n", CRC_AP);
+
+	buf[0] = (unsigned char)ILITEK_TP_CMD_WRITE_ENABLE;//0xc4
+	buf[1]=0x5A;
+	buf[2]=0xA5;
+	buf[3]=0x01;
+	buf[4]=df_endaddr >> 16;
+	buf[5]=(df_endaddr >> 8) & 0xFF;
+	buf[6]=(df_endaddr) & 0xFF;
+	buf[7]=CRC_DF >> 16;
+	buf[8]=(CRC_DF >> 8) & 0xFF;
+	buf[9]=CRC_DF & 0xFF; 
+	ret = ilitek_i2c_write(buf, 10);
+	if(ret < 0)
+	{
+		tp_log_err("ilitek_i2c_write\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}
+	check_busy(1);
+	if(((df_endaddr) % 32) != 0) {
+		df_endaddr += 32;
+	}
+	tp_log_info("write data to df mode\n");
+	for(i = df_startaddr; i < df_endaddr; i += 32) {
+		// we should do delay when the size is equal to 512 bytes
+		buf[0] = (unsigned char)ILITEK_TP_CMD_WRITE_DATA;
+		for(k = 0; k < 32; k++) {
+			buf[1 + k] = CTPM_FW[i + k + 32];
+		}
+		if(ilitek_i2c_write(buf, 33) < 0) {
+			tp_log_err("%s, ilitek_i2c_write_and_read\n", __func__);
+			return ILITEK_I2C_TRANSFER_ERR;
+		}
+		check_busy(1);
+		upgrade_status = ((i - df_startaddr) * 100) / (df_endaddr - df_startaddr);
+		//tp_log_info("%c ilitek ILITEK: Firmware Upgrade(Data flash), %02d%c. \n",0x0D,upgrade_status,'%');
+	}
+	
+	buf[0] = (unsigned char) 0xC7;
+	if(ilitek_i2c_write(buf, 1) < 0) {
+		tp_log_err("ilitek_i2c_write\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}
+	check_busy(1);
+	buf[0] = (unsigned char)0xC7;
+	ilitek_i2c_write_and_read(buf, 1, 10, buf, 4);
+	tp_log_info("upgrade end write c7 read 0x%X, 0x%X, 0x%X, 0x%X\n", buf[0], buf[1], buf[2], buf[3]);
+	if (CRC_DF != buf[1] * 256 + buf[0]) {
+		tp_log_err("CRC DF compare error\n");
+		//return ILITEK_UPDATE_FAIL;
+	}
+	else {
+		tp_log_info("CRC DF compare Right\n");
+	}
+	buf[0] = (unsigned char)ILITEK_TP_CMD_WRITE_ENABLE;//0xc4
+	buf[1]=0x5A;
+	buf[2]=0xA5;
+	buf[3]=0x00;
+	buf[4]=(ap_endaddr + 1) >> 16;
+	buf[5]=((ap_endaddr + 1) >> 8) & 0xFF;
+	buf[6]=((ap_endaddr + 1)) & 0xFF;
+	buf[7]=0;
+	buf[8]=(CRC_AP & 0xFFFF) >> 8;
+	buf[9]=CRC_AP & 0xFFFF; 
+	ret = ilitek_i2c_write(buf, 10);
+	if(ret < 0)
+	{
+		tp_log_err("ilitek_i2c_write\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}
+	check_busy(1);
+	if(((ap_endaddr + 1) % 32) != 0) {
+		tp_log_info("ap_endaddr += 32\n");
+		ap_endaddr += 32;
+	}
+	tp_log_info("write data to AP mode\n");
+	for(i = ap_startaddr; i < ap_endaddr; i += 32) {
+		buf[0] = (unsigned char)ILITEK_TP_CMD_WRITE_DATA;
+		for(k = 0; k < 32; k++) {
+			buf[1 + k] = CTPM_FW[i + k + 32];
+		}
+		if (ilitek_i2c_write(buf, 33) < 0) {
+			tp_log_err("ilitek_i2c_write\n");
+			return ILITEK_I2C_TRANSFER_ERR;
+		}
+		check_busy(1);
+		upgrade_status = ((i - ap_startaddr) * 100) / (ap_endaddr - ap_startaddr);
+		//tp_log_info("%c ilitek ILITEK: Firmware Upgrade(AP), %02d%c. \n",0x0D,upgrade_status,'%');
+	}
+	for (i = 0; i < 20; i++) {
+		buf[0] = (unsigned char) 0xC7;
+		if(ilitek_i2c_write(buf, 1) < 0) {
+			tp_log_err("ilitek_i2c_write\n");
+			return ILITEK_I2C_TRANSFER_ERR;
+		}
+		check_busy(1);
+		buf[0] = (unsigned char)0xC7;
+		ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 4);
+		if(ret < 0)
+		{
+			tp_log_err("ilitek_i2c_write_and_read 0xc7\n");
+			return ILITEK_I2C_TRANSFER_ERR;
+		}
+		tp_log_info("upgrade end write c7 read 0x%X, 0x%X, 0x%X, 0x%X\n", buf[0], buf[1], buf[2], buf[3]);
+		if (CRC_AP != buf[1] * 256 + buf[0]) {
+			tp_log_err("CRC compare error retry\n");
+			//return ILITEK_TP_UPGRADE_FAIL;
+		}
+		else {
+			tp_log_info("CRC compare Right\n");
+			break;
+		}
+	}
+	if (i >= 20) {
+		tp_log_err("CRC compare error\n");
+		return ILITEK_TP_UPGRADE_FAIL;
+	}
+	return 0;
+}
+
+int inwrite(unsigned int address)
+{
+	uint8_t outbuff[64];
+	int data, ret;
+	outbuff[0] = REG_START_DATA;
+	outbuff[1] = (char)((address & DATA_SHIFT_0) >> 0);
+	outbuff[2] = (char)((address & DATA_SHIFT_8) >> 8);
+	outbuff[3] = (char)((address & DATA_SHIFT_16) >> 16);
+	ret = ilitek_i2c_write(outbuff, 4);
+	if (ret < 0) {
+		tp_log_err("i2c communication err\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}
+	mdelay(1);
+	ret = ilitek_i2c_read(outbuff, 4);
+	if (ret < 0) {
+		tp_log_err("i2c communication err\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}
+	data = (outbuff[0] + outbuff[1] * 256 + outbuff[2] * 256 * 256 + outbuff[3] * 256 * 256 * 256);
+	tp_log_debug("data=0x%x, outbuff[0]=%x, outbuff[1]=%x, outbuff[2]=%x, outbuff[3]=%x\n", data, outbuff[0], outbuff[1], outbuff[2], outbuff[3]);
+	return data;
+}
+
+int outwrite(unsigned int address, unsigned int data, int size)
+{
+	int ret, i;
+	char outbuff[64];
+	outbuff[0] = REG_START_DATA;
+	outbuff[1] = (char)((address & DATA_SHIFT_0) >> 0);
+	outbuff[2] = (char)((address & DATA_SHIFT_8) >> 8);
+	outbuff[3] = (char)((address & DATA_SHIFT_16) >> 16);
+	for(i = 0; i < size; i++)
+	{
+		outbuff[i + 4] = (char)(data >> (8 * i));
+	}
+	ret = ilitek_i2c_write(outbuff, size + 4);
+	if (ret < 0) {
+		tp_log_err("i2c communication err\n");
+		return ILITEK_I2C_TRANSFER_ERR;
+	}
+	return ret;
+}
+
+int ilitek_ready_upgrade_2120(void) {
+	int ret = 0;
+	ret = outwrite(ENTER_ICE_MODE, ENTER_ICE_MODE_NO_DATA, 0);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(WDTRLDT, WDTRLDT_CLOSE, 2);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(WDTCNT1, WDTCNT1_OPEN, 1);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(WDTCNT1, WDTCNT1_CLOSE, 1);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(CLOSE_10K_WDT1, CLOSE_10K_WDT1_VALUE, 4);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(CLOSE_10K_WDT2, CLOSE_10K_WDT2_VALUE, 1);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(CLOSE_10K_WDT3, CLOSE_10K_WDT3_VALUE, 4);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	tp_log_info("%s, release Power Down Release mode\n", __func__);
+	ret = outwrite(REG_FLASH_CMD, REG_FLASH_CMD_RELEASE_FROM_POWER_DOWN, 1);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(REG_PGM_NUM, REG_PGM_NUM_TRIGGER_KEY, 4);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(2);
+	ret = outwrite(REG_TIMING_SET, REG_TIMING_SET_10MS, 1);
+	if (ret < 0) {
+		tp_log_err("communication err ret = %d\n", ret);
+		return ret;
+	}
+	msleep(10);
+	return ret;
+}
+
+int ilitek_erase_sector_2120(void) {
+	int ret = 0, i = 0, j = 0, temp = 0;
+	unsigned char buf[64] = {0};
+	for (i = 0; i <= SECTOR_ENDADDR; i += SECTOR_SIZE) {
+		tp_log_debug("i = %X\n", i);
+		ret = outwrite(REG_FLASH_CMD, REG_FLASH_CMD_WRITE_ENABLE, 1);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		msleep(1);
+		ret = outwrite(REG_PGM_NUM, REG_PGM_NUM_TRIGGER_KEY, 4);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		msleep(1);
+		temp = (i << 8) + REG_FLASH_CMD_DATA_ERASE;
+		ret = outwrite(REG_FLASH_CMD, temp, 4);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		msleep(1);
+		ret = outwrite(REG_PGM_NUM, REG_PGM_NUM_TRIGGER_KEY, 4);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		msleep(25);
+		for (j = 0; j < 50; j++) {
+			ret = outwrite(REG_FLASH_CMD, REG_FLASH_CMD_READ_FLASH_STATUS, 1);
+			if (ret < 0) {
+				tp_log_err("communication err ret = %d\n", ret);
+				return ret;
+			}
+			ret = outwrite(REG_PGM_NUM, REG_PGM_NUM_TRIGGER_KEY, 4);
+			if (ret < 0) {
+				tp_log_err("communication err ret = %d\n", ret);
+				return ret;
+			}
+			msleep(1);
+			buf[0] = inwrite(FLASH_STATUS);
+			if (ret < 0) {
+				tp_log_err("communication err ret = %d\n", ret);
+				return ret;
+			}
+			tp_log_debug("buf[0] = %X\n", buf[0]);
+			if (buf[0] == 0) {
+				break;
+			}
+			else {
+				msleep(2);
+			};
+		}
+		if (j >= 50) {
+			tp_log_info("FLASH_STATUS ERROR j = %d, buf[0] = 0x%X\n", j, buf[0]);
+		}
+	}
+	msleep(100);
+	return 0;
+}
+
+int ilitek_write_data_upgrade_2120(unsigned char * CTPM_FW) {
+	int ret = 0, i = 0, k = 0, temp = 0;
+	unsigned char buf[512] = {0};
+	for(i = AP_STARTADDR; i < AP_ENDADDR; i += UPGRADE_TRANSMIT_LEN) {
+		tp_log_debug("i = %X\n", i);
+		ret = outwrite(REG_FLASH_CMD, REG_FLASH_CMD_WRITE_ENABLE, 1);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		ret = outwrite(REG_PGM_NUM, REG_PGM_NUM_TRIGGER_KEY, 4);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		temp = (i << 8) + REG_FLASH_CMD_DATA_PROGRAMME;
+		ret = outwrite(REG_FLASH_CMD, temp, 4);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		ret = outwrite(REG_PGM_NUM, REG_PGM_LEN, 4);
+		if (ret < 0) {
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		buf[0] = REG_START_DATA;
+		buf[3] = (char)((REG_PGM_DATA  & DATA_SHIFT_16) >> 16);
+		buf[2] = (char)((REG_PGM_DATA  & DATA_SHIFT_8) >> 8);
+		buf[1] = (char)((REG_PGM_DATA  & DATA_SHIFT_0));
+		for(k = 0; k < UPGRADE_TRANSMIT_LEN; k++)
+		{
+			buf[4 + k] = CTPM_FW[i  + k + 32];
+		}
+		ret = ilitek_i2c_write(buf, UPGRADE_TRANSMIT_LEN + REG_LEN);
+		if(ret < 0) {
+			tp_log_err("write data error, address = 0x%X, start_addr = 0x%X, end_addr = 0x%X\n", (int)i, (int)AP_STARTADDR, (int)AP_ENDADDR);
+			tp_log_err("communication err ret = %d\n", ret);
+			return ret;
+		}
+		mdelay(3);
+	}
+	return 0;
+}
+int ilitek_upgrade_2120(unsigned char * CTPM_FW) {
+	int ret = 0, retry = 0;
+	unsigned char buf[64] = {0};
+Retry:
+	if (retry < 2) {
+		retry++;
+	}
+	else {
+		tp_log_err("retry 2 times upgrade fail\n");
+		return ret;
+	}
+	ret = ilitek_ready_upgrade_2120();
+	if (ret < 0) {
+		tp_log_err("ilitek_ready_upgrade_2120 err ret = %d\n", ret);
+		goto Retry;
+	}
+	ret = ilitek_erase_sector_2120();
+	if (ret < 0) {
+		tp_log_err("ilitek_erase_sector_2120 err ret = %d\n", ret);
+		goto Retry;
+	}
+	ret = ilitek_write_data_upgrade_2120(CTPM_FW);
+	if (ret < 0) {
+		tp_log_err("ilitek_write_data_upgrade_2120 err ret = %d\n", ret);
+		goto Retry;
+	}
+	buf[0] = (unsigned char)(EXIT_ICE_MODE & DATA_SHIFT_0);
+	buf[1] = (unsigned char)((EXIT_ICE_MODE & DATA_SHIFT_8) >> 8);
+	buf[2] = (unsigned char)((EXIT_ICE_MODE & DATA_SHIFT_16) >> 16);
+	buf[3] = (unsigned char)((EXIT_ICE_MODE & DATA_SHIFT_24) >> 24);
+	ilitek_i2c_write(buf, 4);
+	ilitek_reset(100);
+
+	buf[0] = ILITEK_TP_CMD_GET_TOUCH_INFORMATION;
+	ilitek_i2c_write(buf, 1);
+	ret = ilitek_i2c_read(buf, 3);
+	tp_log_info("buf = %X, %X, %X\n", buf[0], buf[1], buf[2]);
+	if (buf[1] >= 0X80) {
+		tp_log_info("upgrade ok ok \n");
+	}else {
+		goto Retry;
+	}
+	return 0;
+}
+
+int ilitek_upgrade_bigger_size_ic(unsigned int df_startaddr, unsigned int df_endaddr, unsigned int df_checksum,
+	unsigned int ap_startaddr, unsigned int ap_endaddr, unsigned int ap_checksum, unsigned char * CTPM_FW) {
+	int ret = 0, retry = 0, i = 0;
+	unsigned char buf[64] = {0};
+Retry:
+	if (retry < 2) {
+		retry++;
+	}
+	else {
+		tp_log_err("retry 2 times upgrade fail\n");
+		return ret;
+	}
+	tp_log_info("upgrade firmware start	reset\n");
+	ilitek_reset(300);
+	buf[0] = 0xF2;
+	buf[1] = 0x01;
+	ret = ilitek_i2c_write(buf, 2);
+	if (ret < 0) {
+		tp_log_err("ilitek_i2c_write\n");
+		goto Retry;
+	}
+	check_busy(1);
+	//check ic type
+	buf[0] = ILITEK_TP_CMD_GET_KERNEL_VERSION;
+	ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 5);
+	if (ret < 0) {
+		tp_log_err("ilitek_i2c_write_and_read\n");
+		goto Retry;
+	}
+	for (i = 0; i < 5; i++) {
+		ilitek_data->mcu_ver[i] = buf[i];
+	}
+	tp_log_info("MCU KERNEL version:%d.%d.%d.%d.%d\n", buf[0], buf[1], buf[2],buf[3], buf[4]);
+	ret = ilitek_changetoblmode(true);
+	if(ret) {
+		tp_log_err("change to bl mode err ret = %d\n", ret);
+		goto Retry;
+	}
+	else {
+		tp_log_info("ilitek change to bl mode ok\n");
+	}
+	buf[0] = ILITEK_TP_CMD_GET_PROTOCOL_VERSION;
+	ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 4);
+	if(ret < 0)
+	{
+		tp_log_err("ilitek_i2c_write_and_read ret = %d\n", ret);
+		goto Retry;
+	}
+	tp_log_info("bl protocol version %d.%d\n", buf[0], buf[1]);
+	ilitek_data->bl_ver[0] = buf[0];
+	ilitek_data->bl_ver[1] = buf[1];
+	if (buf[0] == 1 && buf[1] >= 4) {
+		buf[0] = ILITEK_TP_CMD_GET_KERNEL_VERSION;
+		ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 6);
+		df_startaddr = buf[2] * 256 * 256 + buf[3] * 256 + buf[4];
+		tp_log_info("df_start_addr = %x\n", (int)df_startaddr);
+		if(buf[0] != 0x05) {
+			ilitek_data->page_number = 16;
+			tp_log_info("ilitek page_number = 16, page is 512 bytes\n");
+		} else {
+			ilitek_data->page_number = 8;
+			tp_log_info("ilitek page_number = 8, page is 256 bytes\n");
+		}
+		buf[0] = 0xc7;
+		ret = ilitek_i2c_write_and_read(buf, 1, 10, buf, 1);
+		tp_log_info("0xc7 read= %x\n", buf[0]);
+	}
+		
+	if ((ilitek_data->mcu_ver[0] == 0x11 || ilitek_data->mcu_ver[0] == 0x10) && ilitek_data->mcu_ver[1] == 0x25) {
+		df_startaddr = 0xF000;
+		ret = ilitek_upgrade_2511(df_startaddr, df_endaddr, ap_startaddr, ap_endaddr, CTPM_FW);
+		if (ret < 0) {
+			tp_log_err("ilitek_upgrade_2511 err ret = %d\n", ret);
+			//goto Retry;
+		}
+	}
+	else {
+		df_startaddr = 0x1F000;
+		if (df_startaddr < df_endaddr) {
+			ilitek_data->has_df = true;
+		}
+		else {
+			ilitek_data->has_df = false;
+		}
+		ret = ilitek_upgrade_2302or2312(df_startaddr, df_endaddr, df_checksum, ap_startaddr, ap_endaddr, ap_checksum, CTPM_FW);
+		if (ret < 0) {
+			tp_log_err("ilitek_upgrade_2302or2312 err ret = %d\n", ret);
+			//goto Retry;
+		}
+	}
+	tp_log_info("upgrade firmware completed	reset\n");
+	ilitek_reset(300);
+	
+	ret = ilitek_changetoblmode(false);
+	if(ret) {
+		tp_log_err("change to ap mode err\n");
+		goto Retry;
+	}
+	else {
+		tp_log_info("ilitek change to ap mode ok\n");
+	}
+	return 0;
+}
+#ifdef ILITEK_UPDATE_FW
+int ilitek_upgrade_firmware(void) {
+	int ret = 0, i = 0, ap_len = 0, df_len = 0;
+	unsigned int ap_startaddr = 0, df_startaddr = 0, ap_endaddr = 0, df_endaddr = 0, ap_checksum = 0, df_checksum = 0;
+	unsigned char firmware_ver[8] = {0};
+	const struct firmware *fw;
+	uint8_t * CTPM_FW_BIN = NULL;
+	ap_startaddr = ( CTPM_FW[0] << 16 ) + ( CTPM_FW[1] << 8 ) + CTPM_FW[2];
+	ap_endaddr = ( CTPM_FW[3] << 16 ) + ( CTPM_FW[4] << 8 ) + CTPM_FW[5];
+	ap_checksum = ( CTPM_FW[6] << 16 ) + ( CTPM_FW[7] << 8 ) + CTPM_FW[8];
+	df_startaddr = ( CTPM_FW[9] << 16 ) + ( CTPM_FW[10] << 8 ) + CTPM_FW[11];
+	ilitek_data->upgrade_mcu_ver[0] = CTPM_FW[10];
+	ilitek_data->upgrade_mcu_ver[1] = CTPM_FW[11];
+	df_endaddr = ( CTPM_FW[12] << 16 ) + ( CTPM_FW[13] << 8 ) + CTPM_FW[14];
+	df_checksum = ( CTPM_FW[15] << 16 ) + ( CTPM_FW[16] << 8 ) + CTPM_FW[17];
+	firmware_ver[0] = CTPM_FW[18];
+	firmware_ver[1] = CTPM_FW[19];
+	firmware_ver[2] = CTPM_FW[20];
+	firmware_ver[3] = CTPM_FW[21];
+	firmware_ver[4] = CTPM_FW[22];
+	firmware_ver[5] = CTPM_FW[23];
+	firmware_ver[6] = CTPM_FW[24];
+	firmware_ver[7] = CTPM_FW[25];
+	df_len = ( CTPM_FW[26] << 16 ) + ( CTPM_FW[27] << 8 ) + CTPM_FW[28];
+	ap_len = ( CTPM_FW[29] << 16 ) + ( CTPM_FW[30] << 8 ) + CTPM_FW[31];
+	if (ilitek_data->ic_2120 && ILITEK_UPGRADE_WITH_BIN) {
+		CTPM_FW_BIN = vmalloc(64 * 1024);
+		if (!CTPM_FW_BIN) {
+			tp_log_err("CTPM_FW_BIN alloctation memory failed\n");
+			return ILITEK_TP_UPGRADE_FAIL;
+		}
+		ap_startaddr = AP_STARTADDR;
+		ap_endaddr = AP_ENDADDR;
+		ret = request_firmware(&fw, ILITEK_FW_FILENAME, &ilitek_data->client->dev);
+		if (ret) {
+			tp_log_err("failed to request firmware %s: %d\n", ILITEK_FW_FILENAME, ret);
+			return ret;
+		}
+		tp_log_info("ilitek fw->size = %d\n", (int)fw->size);
+		if (fw->size != 0xE000) {
+			tp_log_err("ilitek fw->size = %d err\n", (int)fw->size);
+			return ILITEK_TP_UPGRADE_FAIL;
+		}
+		for (ret = 0; ret < fw->size; ret++) {
+			CTPM_FW_BIN[ret + 32] = fw->data[ret];
+		}
+		firmware_ver[0] = 0x0;
+		firmware_ver[1] = CTPM_FW_BIN[FW_VERSION1 + 32];
+		firmware_ver[2] = CTPM_FW_BIN[FW_VERSION2 + 32];
+		firmware_ver[3] = CTPM_FW_BIN[FW_VERSION3 + 32];
+		release_firmware(fw);
+		
+		tp_log_info("firmware_ver[0] = %d, firmware_ver[1] = %d firmware_ver[2]=%d firmware_ver[3]=%d\n",firmware_ver[0], firmware_ver[1], firmware_ver[2], firmware_ver[3]);
+	}
+	tp_log_info("ilitek ap_startaddr=0x%X, ap_endaddr=0x%X, ap_checksum=0x%X, ap_len = 0x%d\n", ap_startaddr, ap_endaddr, ap_checksum, ap_len);
+	tp_log_info("ilitek df_startaddr=0x%X, df_endaddr=0x%X, df_checksum=0x%X, df_len = 0x%d\n", df_startaddr, df_endaddr, df_checksum, df_len);
+	if (!(ilitek_data->force_update)) {
+		for (i = 0; i < 8; i++) {
+			tp_log_info("ilitek_data.firmware_ver[%d] = %d, firmware_ver[%d] = %d\n", i, ilitek_data->firmware_ver[i], i, firmware_ver[i]);
+			if (!ilitek_data->ic_2120) {
+				if (firmware_ver[i] < ilitek_data->firmware_ver[i]) {
+					i = 8;
+					break;
+				}
+				if (firmware_ver[i] > ilitek_data->firmware_ver[i]) {
+					break;
+				}
+			}
+			else {
+				if (firmware_ver[i] != ilitek_data->firmware_ver[i]) {
+					break;
+				}
+			}
+		}
+		if (i >= 8) {
+			if (!ilitek_data->ic_2120) {
+				tp_log_info("firmware version is older so not upgrade\n");
+			}
+			else {
+				tp_log_info("firmware version is same so not upgrade\n");
+				if (ILITEK_UPGRADE_WITH_BIN) {
+					if (CTPM_FW_BIN) {
+						vfree(CTPM_FW_BIN);
+						CTPM_FW_BIN = NULL;
+					}
+				}
+			}
+			return 1;
+		}
+	}
+	if (!ilitek_data->ic_2120) {
+		ret = -1;
+		if ((ilitek_data->upgrade_mcu_ver[0] != 0 || ilitek_data->upgrade_mcu_ver[1] != 0) && (ilitek_data->mcu_ver[0] != ilitek_data->upgrade_mcu_ver[0] ||
+			ilitek_data->mcu_ver[1] != ilitek_data->upgrade_mcu_ver[1])) {
+			tp_log_info("upgrade file mismatch!!! ic is ILI%02X%02X, upgrade file is ILI%02X%02X\n", ilitek_data->mcu_ver[1], ilitek_data->mcu_ver[0],
+				ilitek_data->upgrade_mcu_ver[1], ilitek_data->upgrade_mcu_ver[0]);
+		}
+		else if (ilitek_data->upgrade_mcu_ver[0] == 0 && ilitek_data->upgrade_mcu_ver[1] == 0 && ilitek_data->mcu_ver[0] != 0x03 && ilitek_data->mcu_ver[0] != 0x09) {
+			tp_log_info("upgrade file  mismatch!!! ic is ILI%02X%02X, upgrade file is maybe ILI230X\n", ilitek_data->mcu_ver[1], ilitek_data->mcu_ver[0]);
+		}
+		else {
+			ret = ilitek_upgrade_bigger_size_ic(df_startaddr, df_endaddr, df_checksum, ap_startaddr, ap_endaddr, ap_checksum, CTPM_FW);
+		}
+	}
+	else {
+		if (ILITEK_UPGRADE_WITH_BIN) {
+			ret = ilitek_upgrade_2120(CTPM_FW_BIN);
+		}
+		else {
+			ret = ilitek_upgrade_2120(CTPM_FW);
+		}
+	}
+	if (ret < 0) {
+		tp_log_err("upgrade fail\n");
+		return ret;
+	}
+	if (ILITEK_UPGRADE_WITH_BIN) {
+		if (CTPM_FW_BIN) {
+			vfree(CTPM_FW_BIN);
+			CTPM_FW_BIN = NULL;
+		}
+	}
+	return 0;
+}
+#endif

From 70f087d3ad10cae2101a01258f2a33037ccb806c Mon Sep 17 00:00:00 2001
From: Hans Christian Lonstad <hcl@datarespons.no>
Date: Wed, 12 Dec 2018 14:37:23 +0100
Subject: [PATCH 08/11] Schedule alarm on shutdown

To avoid the RTC sync issues, schedule alarm on shutdown as the relative
time to SMC RTC becomes valid
---
 drivers/misc/vhgw-smc/vhgw-smc.c | 529 ++++++++++++++++++-------------
 1 file changed, 304 insertions(+), 225 deletions(-)

diff --git a/drivers/misc/vhgw-smc/vhgw-smc.c b/drivers/misc/vhgw-smc/vhgw-smc.c
index 7770aca029f2..056de2a84062 100644
--- a/drivers/misc/vhgw-smc/vhgw-smc.c
+++ b/drivers/misc/vhgw-smc/vhgw-smc.c
@@ -89,6 +89,9 @@ struct smc_data {
 	struct power_supply *psy_dcout2;
 	unsigned long psy_jiffies;
 	InitEventType_t start_cause;
+	int alarm_pending;
+	u32 alarm_in_seconds;
+	int rtc_updated;
 };
 
 /*
@@ -103,7 +106,8 @@ struct smc_data {
 #define LED_USER_SPACE_NAME_STATUS_GREEN	"status-green"
 #define LED_USER_SPACE_NAME_STATUS_RED		"status-red"
 
-static int compare_version(MpuVersionHeader_t ver, u16 maj, u16 min) {
+static int compare_version(MpuVersionHeader_t ver, u16 maj, u16 min)
+{
 	u32 numv = (maj << 16) | min;
 	u32 hdr_numv = (ver.ver_major << 16) | ver.ver_minor;
 	if (hdr_numv > numv)
@@ -114,7 +118,8 @@ static int compare_version(MpuVersionHeader_t ver, u16 maj, u16 min) {
 		return 0;
 }
 
-static int smc_send(struct i2c_client *client, u8 *outbuf, int outbuf_size) {
+static int smc_send(struct i2c_client *client, u8 *outbuf, int outbuf_size)
+{
 	int ret = 0;
 	struct i2c_msg msg_tx[1];
 	struct smc_data *data = i2c_get_clientdata(client);
@@ -128,7 +133,7 @@ static int smc_send(struct i2c_client *client, u8 *outbuf, int outbuf_size) {
 	data->is_ready = false;
 
 	dev_dbg(&client->dev, "%s: msg %d, sz %d\n", __func__, outbuf[0],
-			outbuf_size);
+		outbuf_size);
 	ret = i2c_transfer(client->adapter, msg_tx, 1);
 	if (ret < 1) {
 		dev_err(&client->dev, "i2c_transfer: [tx] , ret = %d\n", ret);
@@ -137,12 +142,13 @@ static int smc_send(struct i2c_client *client, u8 *outbuf, int outbuf_size) {
 	return 0;
 }
 
-static int smc_recv(struct i2c_client *client) {
+static int smc_recv(struct i2c_client *client)
+{
 	int ret = 0;
 	struct smc_data *data = i2c_get_clientdata(client);
 	struct i2c_msg msg_rx[1];
 	int rx_len = 0;
-	char buf[I2C_SMBUS_BLOCK_MAX+4];
+	char buf[I2C_SMBUS_BLOCK_MAX + 4];
 
 	/* The data will get returned in this structure */
 	msg_rx[0].addr = client->addr;
@@ -159,14 +165,13 @@ static int smc_recv(struct i2c_client *client) {
 	dev_dbg(&client->dev, "%s: RX len is %d\n", __func__, rx_len);
 	if (rx_len > (I2C_SMBUS_BLOCK_MAX)) {
 		dev_warn(&client->dev, "i2c_transfer [rx] encoded len=%d\n",
-				rx_len);
+			rx_len);
 		return -EIO;
 	}
-	if (buf[rx_len] != mpu_compute_checksum(buf + 1,
-					rx_len - 1)) {
+	if (buf[rx_len] != mpu_compute_checksum(buf + 1, rx_len - 1)) {
 		dev_warn(&client->dev,
-				"i2c rcv msg[%d] checksum error, len=%d\n",
-				buf[1], rx_len - 1);
+			"i2c rcv msg[%d] checksum error, len=%d\n", buf[1],
+			rx_len - 1);
 		return -EINVAL;
 	}
 
@@ -175,9 +180,10 @@ static int smc_recv(struct i2c_client *client) {
 }
 
 static int smc_transaction(struct i2c_client *client, u8 *outbuf,
-		int outbuf_size, u8 *result, int result_size) {
+	int outbuf_size, u8 *result, int result_size)
+{
 	int ret;
-	int retries=2;
+	int retries = 2;
 	MpuMsgHeader_t hdr_in, hdr_out;
 	struct smc_data *data = i2c_get_clientdata(client);
 	ret = mutex_lock_interruptible(&data->transaction_mutex);
@@ -186,8 +192,8 @@ static int smc_transaction(struct i2c_client *client, u8 *outbuf,
 
 	if (result_size > (I2C_SMBUS_BLOCK_MAX + 1)) {
 		dev_err(&client->dev,
-				"Transactation read size of %d to big, max %d\n",
-				result_size, I2C_SMBUS_BLOCK_MAX + 1);
+			"Transactation read size of %d to big, max %d\n",
+			result_size, I2C_SMBUS_BLOCK_MAX + 1);
 		mutex_unlock(&data->transaction_mutex);
 		return -EINVAL;
 	}
@@ -203,34 +209,38 @@ static int smc_transaction(struct i2c_client *client, u8 *outbuf,
 			continue;
 		}
 
-		ret = wait_event_interruptible_timeout(data->readq, data->is_ready,
-				msecs_to_jiffies(2000));
+		ret = wait_event_interruptible_timeout(data->readq,
+			data->is_ready, msecs_to_jiffies(2000));
 
 		if (ret <= 0) {
 			data->read_pending = 0;
-			dev_warn(&client->dev, "Timeout waiting for command reply\n");
+			dev_warn(&client->dev,
+				"Timeout waiting for command reply\n");
 			if (ret == 0)
 				ret = -ETIMEDOUT;
 			continue;
 		}
 		if (data->rx_result < 0) {
 			dev_warn(&client->dev, "%s: Rx Error %d\n", __func__,
-					data->rx_result);
+				data->rx_result);
 			ret = data->rx_result;
 			continue;
 		}
 		hdr_out = mpu_message_header(result);
 		if (hdr_in.type != hdr_out.type) {
-			dev_err(&client->dev, "Msg in type %d differs from reply %d\n", hdr_in.type, hdr_out.type);
+			dev_err(&client->dev,
+				"Msg in type %d differs from reply %d\n",
+				hdr_in.type, hdr_out.type);
 			ret = -EINVAL;
 		}
-	} while ( ret && retries--);
+	} while (ret && retries--);
 	mutex_unlock(&data->transaction_mutex);
-	return ret;
+	return ret >= 0 ? 0 : ret;
 }
 
 static int set_led(struct smc_data *data, int led,
-		enum led_brightness brightness) {
+	enum led_brightness brightness)
+{
 	int ret = 0;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	u8 reply[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -245,7 +255,8 @@ static int set_led(struct smc_data *data, int led,
 }
 
 static int smc_led_brightness_set(struct led_classdev *cdev,
-		enum led_brightness brightness) {
+	enum led_brightness brightness)
+{
 	struct smc_data *priv = dev_get_drvdata(cdev->dev->parent);
 
 	if (strcmp(cdev->name, LED_USER_SPACE_NAME_STATUS_GREEN) == 0)
@@ -256,7 +267,8 @@ static int smc_led_brightness_set(struct led_classdev *cdev,
 }
 
 static int smc_register_led(struct smc_data *data, struct smc_led *led,
-		const char *name, int id, const char *trigger) {
+	const char *name, int id, const char *trigger)
+{
 	int err;
 
 	strncpy(led->name, name, sizeof(led->name));
@@ -267,10 +279,10 @@ static int smc_register_led(struct smc_data *data, struct smc_led *led,
 	led->led_id = id;
 
 	err = led_classdev_register((struct device * )&data->client->dev,
-			&led->led_dev);
+		&led->led_dev);
 	if (err) {
 		dev_warn(&data->client->dev, "Could not register LED %s\n",
-				name);
+			name);
 		led->registered = 0;
 	} else
 		led->registered = 1;
@@ -278,17 +290,20 @@ static int smc_register_led(struct smc_data *data, struct smc_led *led,
 	return err;
 }
 
-static void smc_unregister_led(struct smc_data *data, struct smc_led *led) {
+static void smc_unregister_led(struct smc_data *data, struct smc_led *led)
+{
 	if (led->registered)
 		led_classdev_unregister(&led->led_dev);
 }
 
-static void smc_unregister_leds(struct smc_data *data) {
+static void smc_unregister_leds(struct smc_data *data)
+{
 	smc_unregister_led(data, &data->led_status_green);
 	smc_unregister_led(data, &data->led_status_red);
 }
 
-static void smc_init_leds(struct smc_data *data) {
+static void smc_init_leds(struct smc_data *data)
+{
 	// initializing leds
 	int ret = 0;
 	char name[VHGW_SMC_LED_MAX_NAME_LEN + 1];
@@ -301,15 +316,16 @@ static void smc_init_leds(struct smc_data *data) {
 
 	snprintf(name, sizeof(name), LED_USER_SPACE_NAME_STATUS_GREEN);
 	ret = smc_register_led(data, &data->led_status_green, name,
-			LedStatusGreen, "none");
+		LedStatusGreen, "none");
 
 	snprintf(name, sizeof(name), LED_USER_SPACE_NAME_STATUS_RED);
 	ret = smc_register_led(data, &data->led_status_red, name, LedStatusRed,
-			"none");
+		"none");
 }
 
 static ssize_t get_ignition_delay(struct device *dev,
-		struct device_attribute *attr, char *buf) {
+	struct device_attribute *attr, char *buf)
+{
 	const u8 *ignRes;
 	int ret = 0;
 	struct i2c_client *client = to_i2c_client(dev);
@@ -321,9 +337,9 @@ static ssize_t get_ignition_delay(struct device *dev,
 	ignMsg[0] = IgnitionDelayGet;
 	ignMsg[1] = 0;
 	ret = mpu_create_message(msg_ignition, mpu_status_ok, outbuf, ignMsg,
-			2);
+		2);
 	ret = smc_transaction(client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + 2);
+		sizeof(MpuMsgHeader_t) + 2);
 
 	if (ret < 0)
 		return -EINVAL;
@@ -333,7 +349,8 @@ static ssize_t get_ignition_delay(struct device *dev,
 }
 
 static ssize_t set_ignition_delay(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count) {
+	struct device_attribute *attr, const char *buf, size_t count)
+{
 	int ret = 0;
 	struct i2c_client *client = to_i2c_client(dev);
 	int ignition_delay = 0;
@@ -348,22 +365,24 @@ static ssize_t set_ignition_delay(struct device *dev,
 	ignMsg[0] = IgnitionDelaySet;
 	ignMsg[1] = ignition_delay;
 	ret = mpu_create_message(msg_ignition, mpu_status_ok, outbuf, ignMsg,
-			2);
+		2);
 	ret = smc_transaction(client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + 2);
+		sizeof(MpuMsgHeader_t) + 2);
 
 	return count;
 }
 static DEVICE_ATTR(ignition_delay, S_IWUSR | S_IRUGO, get_ignition_delay, set_ignition_delay);
 
 static ssize_t get_debug(struct device *dev, struct device_attribute *attr,
-		char *buf) {
+	char *buf)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	return sprintf(buf, "%d\n", priv->debug_mode);
 }
 
 static ssize_t set_debug(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count) {
+	const char *buf, size_t count)
+{
 	int ret = 0;
 	struct i2c_client *client = to_i2c_client(dev);
 	int dbg = 0;
@@ -382,7 +401,7 @@ static ssize_t set_debug(struct device *dev, struct device_attribute *attr,
 	msg[0] = dbg;
 	ret = mpu_create_message(msg_debug, mpu_status_ok, outbuf, msg, 1);
 	ret = smc_transaction(client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + 1);
+		sizeof(MpuMsgHeader_t) + 1);
 	if (ret > 0)
 		priv->debug_mode = dbg;
 	return count;
@@ -391,7 +410,8 @@ static ssize_t set_debug(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR(debug, S_IWUSR | S_IRUGO, get_debug, set_debug);
 
 static ssize_t command(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count) {
+	const char *buf, size_t count)
+{
 	int ret = 0;
 	struct i2c_client *client = to_i2c_client(dev);
 	MpuMsgHeader_t hdr;
@@ -402,20 +422,20 @@ static ssize_t command(struct device *dev, struct device_attribute *attr,
 
 		dev_warn(dev, "Reset MCU\n");
 		ret = mpu_create_message(msg_reset, mpu_status_ok, outbuf, 0,
-				0);
+			0);
 		ret = smc_transaction(client, outbuf, ret, result,
-				sizeof(result));
+			sizeof(result));
 		hdr = mpu_message_header(result);
 		if (hdr.replyStatus == mpu_status_ok)
 			dev_info(dev, "RESET in progress\n");
 		else
 			dev_info(dev, "Command %s failed with %d\n", buf,
-					hdr.replyStatus);
+				hdr.replyStatus);
 	} else if (sysfs_streq(buf, "defaults")) {
 		ret = mpu_create_message(msg_defaults, mpu_status_ok, outbuf, 0,
-				0);
+			0);
 		ret = smc_transaction(client, outbuf, ret, result,
-				sizeof(result));
+			sizeof(result));
 	} else
 		return -EINVAL;
 	if (ret < 0)
@@ -424,7 +444,8 @@ static ssize_t command(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR(command, S_IWUSR, 0, command);
 
-static int fetch_firmware_version(struct smc_data *priv) {
+static int fetch_firmware_version(struct smc_data *priv)
+{
 	int ret = 0;
 
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -432,7 +453,7 @@ static int fetch_firmware_version(struct smc_data *priv) {
 
 	ret = mpu_create_message(msg_version, mpu_status_ok, outbuf, 0, 0);
 	ret = smc_transaction(priv->client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + sizeof(MpuVersionHeader_t));
+		sizeof(MpuMsgHeader_t) + sizeof(MpuVersionHeader_t));
 	if (ret < 0)
 		return ret;
 
@@ -440,7 +461,8 @@ static int fetch_firmware_version(struct smc_data *priv) {
 	return 0;
 }
 
-static int send_async(struct smc_data *priv) {
+static int send_async(struct smc_data *priv)
+{
 	int ret = 0;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	u8 result[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -453,7 +475,8 @@ static int send_async(struct smc_data *priv) {
 	return 0;
 }
 
-static int send_reboot(struct smc_data *priv) {
+static int send_reboot(struct smc_data *priv)
+{
 	int ret = 0;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	u8 result[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -466,7 +489,8 @@ static int send_reboot(struct smc_data *priv) {
 	return 0;
 }
 
-static ssize_t smc_get_sensors(struct smc_data *priv) {
+static ssize_t smc_get_sensors(struct smc_data *priv)
+{
 	int ret = 0;
 	SensorMsg_t *s;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -474,7 +498,7 @@ static ssize_t smc_get_sensors(struct smc_data *priv) {
 
 	ret = mpu_create_message(msg_sensors, mpu_status_ok, outbuf, 0, 0);
 	ret = smc_transaction(priv->client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + 2);
+		sizeof(MpuMsgHeader_t) + 2);
 
 	if (ret < 0)
 		return -EINVAL;
@@ -487,7 +511,8 @@ static ssize_t smc_get_sensors(struct smc_data *priv) {
 	return 0;
 }
 
-static ssize_t smc_get_psy(struct smc_data *priv) {
+static ssize_t smc_get_psy(struct smc_data *priv)
+{
 	int ret = 0;
 	PowerSupplyMsg_t *s;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -495,7 +520,7 @@ static ssize_t smc_get_psy(struct smc_data *priv) {
 
 	ret = mpu_create_message(msg_power_supply, mpu_status_ok, outbuf, 0, 0);
 	ret = smc_transaction(priv->client, outbuf, ret, result,
-			mpu_max_message_size);
+		mpu_max_message_size);
 
 	if (ret < 0)
 		return -EINVAL;
@@ -511,7 +536,8 @@ static ssize_t smc_get_psy(struct smc_data *priv) {
 	return 0;
 }
 
-static ssize_t smc_get_startup_cause(struct smc_data *priv) {
+static ssize_t smc_get_startup_cause(struct smc_data *priv)
+{
 	int ret = 0;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	u8 result[mpu_max_message_size] __attribute__((aligned(0x10)));
@@ -521,7 +547,7 @@ static ssize_t smc_get_startup_cause(struct smc_data *priv) {
 		return 0;
 	ret = mpu_create_message(msg_init, mpu_status_ok, outbuf, 0, 0);
 	ret = smc_transaction(priv->client, outbuf, ret, result,
-			mpu_max_message_size);
+		mpu_max_message_size);
 
 	if (ret < 0)
 		return -EINVAL;
@@ -532,14 +558,16 @@ static ssize_t smc_get_startup_cause(struct smc_data *priv) {
 }
 
 static ssize_t get_firmware_version(struct device *dev,
-		struct device_attribute *attr, char *buf) {
+	struct device_attribute *attr, char *buf)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	return sprintf(buf, "%d.%d\n", priv->version.ver_major,
-			priv->version.ver_minor);
+		priv->version.ver_minor);
 }
 
 static ssize_t get_scap_volt(struct device *dev, struct device_attribute *attr,
-		char *buf) {
+	char *buf)
+{
 	int res;
 	struct smc_data *priv = dev_get_drvdata(dev);
 	if (compare_version(priv->version, 2, 2) >= 0) {
@@ -555,7 +583,8 @@ static DEVICE_ATTR(firmware_version, S_IRUGO, get_firmware_version, 0);
 static DEVICE_ATTR(scap_voltage, S_IRUGO, get_scap_volt, 0);
 
 static ssize_t get_startup_cause(struct device *dev,
-		struct device_attribute *attr, char *buf) {
+	struct device_attribute *attr, char *buf)
+{
 	int res;
 	struct smc_data *priv = dev_get_drvdata(dev);
 	if (compare_version(priv->version, 3, 1) >= 0) {
@@ -597,7 +626,8 @@ static ssize_t get_startup_cause(struct device *dev,
 
 static DEVICE_ATTR(startup_cause, S_IRUGO, get_startup_cause, 0);
 
-static void smc_set(struct gpio_chip *chip, unsigned offset, int value) {
+static void smc_set(struct gpio_chip *chip, unsigned offset, int value)
+{
 	struct smc_data *priv = gpiochip_get_data(chip);
 	struct i2c_client *client = priv->client;
 	int ret = 0;
@@ -612,10 +642,11 @@ static void smc_set(struct gpio_chip *chip, unsigned offset, int value) {
 
 	ret = mpu_create_message(msg_gpo, mpu_status_ok, outbuf, msg, 3);
 	ret = smc_transaction(client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + 3);
+		sizeof(MpuMsgHeader_t) + 3);
 }
 
-static int smc_get(struct gpio_chip *chip, unsigned offset) {
+static int smc_get(struct gpio_chip *chip, unsigned offset)
+{
 	MpuMsgHeader_t hdr;
 	int ret = 0;
 	struct smc_data *priv = gpiochip_get_data(chip);
@@ -633,7 +664,7 @@ static int smc_get(struct gpio_chip *chip, unsigned offset) {
 
 	ret = mpu_create_message(msg_gpo, mpu_status_ok, outbuf, msg, 3);
 	ret = smc_transaction(client, outbuf, ret, result,
-			sizeof(MpuMsgHeader_t) + 3);
+		sizeof(MpuMsgHeader_t) + 3);
 	if (ret < 0)
 		return ret;
 	resultPtr = mpu_get_payload(result);
@@ -644,7 +675,8 @@ static int smc_get(struct gpio_chip *chip, unsigned offset) {
 	return value;
 }
 
-static int smc_get_direction(struct gpio_chip *chip, unsigned offset) {
+static int smc_get_direction(struct gpio_chip *chip, unsigned offset)
+{
 	switch (offset) {
 	case 0:
 	case 1:
@@ -661,7 +693,8 @@ static int smc_get_direction(struct gpio_chip *chip, unsigned offset) {
 	}
 }
 
-static int smc_direction_input(struct gpio_chip *chip, unsigned offset) {
+static int smc_direction_input(struct gpio_chip *chip, unsigned offset)
+{
 	switch (offset) {
 	case 0:
 	case 1:
@@ -680,7 +713,8 @@ static int smc_direction_input(struct gpio_chip *chip, unsigned offset) {
 }
 
 static int smc_direction_output(struct gpio_chip *chip, unsigned offset,
-		int value) {
+	int value)
+{
 	switch (offset) {
 	case 0:
 	case 1:
@@ -698,14 +732,18 @@ static int smc_direction_output(struct gpio_chip *chip, unsigned offset,
 	}
 }
 
-static void smc_alert_handler(struct work_struct *work) {
+static void smc_alert_handler(struct work_struct *work)
+{
 	int res;
-	struct smc_data *priv = container_of(work, struct smc_data, alert_work);
+	struct smc_data
+	*priv = container_of(work, struct smc_data, alert_work);
 	MpuMsgHeader_t hdr;
 	NotificationMsg_t notify;
 	res = smc_recv(priv->client);
 	if (res < 0) {
-		dev_err(&priv->client->dev, "%s: Receive error %d, pending op %s\n", __func__, res, priv->read_pending ? "yes" : "no");
+		dev_err(&priv->client->dev,
+			"%s: Receive error %d, pending op %s\n", __func__, res,
+			priv->read_pending ? "yes" : "no");
 		return;
 	}
 	priv->rx_result = res;
@@ -713,71 +751,71 @@ static void smc_alert_handler(struct work_struct *work) {
 	if (hdr.type == msg_notify) {
 		notify = notify_get_message(mpu_get_payload(priv->rx_buffer));
 		dev_info(&priv->client->dev,
-				"%s: Notification for %d with value %d\n",
-				__func__, notify.id, notify.value);
+			"%s: Notification for %d with value %d\n", __func__,
+			notify.id, notify.value);
 		switch (notify.id) {
 		case GpiIgnition:
 			if (priv->gpio_dev[2]
-					&& (gpiod_get_direction(
-							priv->gpio_descs[2]) > 0)) {
+				&& (gpiod_get_direction(priv->gpio_descs[2]) > 0)) {
 				kobject_uevent(&priv->gpio_dev[2]->kobj,
-						KOBJ_CHANGE);
+					KOBJ_CHANGE);
 			}
 			break;
 
 		case GpiWakeup:
 			if (priv->gpio_dev[3]
-					&& (gpiod_get_direction(
-							priv->gpio_descs[3]) > 0)) {
+				&& (gpiod_get_direction(priv->gpio_descs[3]) > 0)) {
 				kobject_uevent(&priv->gpio_dev[3]->kobj,
-						KOBJ_CHANGE);
+					KOBJ_CHANGE);
 			}
 			break;
 
 		case PowerFail:
 			dev_warn(&priv->client->dev, "%s: POWER FAIL!!",
-					__func__);	// Todo send event
+				__func__);	// Todo send event
 			kill_cad_pid(SIGINT, 1);
 			break;
 
 		default:
 			dev_warn(&priv->client->dev,
-					"%s: Unexpected notification id %d received\n",
-					__func__, notify.id);
+				"%s: Unexpected notification id %d received\n",
+				__func__, notify.id);
 		}
 	} else if (hdr.type < msg_max && priv->read_pending) {
 		dev_dbg(&priv->client->dev, "Transaction IRQ\n");
 		priv->is_ready = true;
 		memcpy(priv->transaction_read_buffer, priv->rx_buffer,
-				priv->rx_result);
+			priv->rx_result);
 		priv->read_pending = 0;
 		wake_up_interruptible(&priv->readq);
 	} else {
 		dev_warn(&priv->client->dev,
-				"%s: Unexpected message %d received\n",
-				__func__, hdr.type);
+			"%s: Unexpected message %d received\n", __func__,
+			hdr.type);
 	}
 
 }
 
-static irqreturn_t smc_irq(int irq, void *dev_id) {
+static irqreturn_t smc_irq(int irq, void *dev_id)
+{
 	struct i2c_client *client = dev_id;
 	struct smc_data *priv = i2c_get_clientdata(client);
 	queue_work(priv->wq, &priv->alert_work);
 	return IRQ_HANDLED;
 }
 
-static int smc_rtc_read(struct device *dev, struct rtc_time *rtctime) {
+static int smc_rtc_read(struct device *dev, struct rtc_time *rtctime)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	int status;
 	RtcMsg_t msg;
 	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	u8 inbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	int sz = rtc_create_message(msg_rtc_get_time,
-			outbuf + sizeof(MpuMsgHeader_t), 0);
+		outbuf + sizeof(MpuMsgHeader_t), 0);
 	sz = mpu_create_message(msg_rtc, 0, outbuf, 0, sz);
 	status = smc_transaction(priv->client, outbuf, sz, inbuf,
-			sizeof(inbuf));
+		sizeof(inbuf));
 	if (status < 0)
 		return status;
 
@@ -792,14 +830,55 @@ static int smc_rtc_read(struct device *dev, struct rtc_time *rtctime) {
 	rtctime->tm_yday = 0;
 	rtctime->tm_isdst = 0;
 	dev_dbg(dev, "RTC time read: %02d.%02d.%02d : %02d.%02d.%02d, wd=%d\n",
-			(rtctime->tm_hour), (rtctime->tm_min),
-			(rtctime->tm_sec), (rtctime->tm_mday),
-			(rtctime->tm_mon), (rtctime->tm_year),
-			rtctime->tm_wday);
+		(rtctime->tm_hour), (rtctime->tm_min), (rtctime->tm_sec),
+		(rtctime->tm_mday), (rtctime->tm_mon), (rtctime->tm_year),
+		rtctime->tm_wday);
 	return 0;
 }
 
-static int smc_rtc_set(struct device *dev, struct rtc_time *rtctime) {
+static int smc_send_alarm(struct smc_data *priv)
+{
+	int status, sz;
+	RtcAlarm_t msg;
+	struct rtc_time rtc_now, rtc_alarm;
+	time64_t now;
+	RtcMsgType_t msg_type;
+
+	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
+	u8 inbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
+	if (priv->alarm_in_seconds == 0)
+		msg_type = msg_rtc_cancel_alarm;
+	else {
+		msg_type = msg_rtc_set_alarm;
+
+		status = rtc_read_time(priv->rtc, &rtc_now);
+		if (status < 0)
+			return status;
+
+		now = rtc_tm_to_time64(&rtc_now);
+		rtc_time64_to_tm(now + priv->alarm_in_seconds, &rtc_alarm);
+
+		msg.tm_sec = bin2bcd(rtc_alarm.tm_sec);
+		msg.tm_min = bin2bcd(rtc_alarm.tm_min);
+		msg.tm_hour = bin2bcd(rtc_alarm.tm_hour);
+		msg.tm_mday = bin2bcd(rtc_alarm.tm_mday);
+		msg.pending = 0;
+		msg.enable = 1;
+		dev_info(&priv->client->dev, "Alarm set at %02d.%02d.%02d %02d:%02d:%02d\n",
+			rtc_alarm.tm_mday, rtc_alarm.tm_mon + 1,
+			rtc_alarm.tm_year - 100, rtc_alarm.tm_hour,
+			rtc_alarm.tm_min, rtc_alarm.tm_sec);
+	}
+	sz = rtc_create_alarm_message(msg_type, outbuf + sizeof(MpuMsgHeader_t),
+		&msg);
+	sz = mpu_create_message(msg_rtc, 0, outbuf, 0, sz);
+	status = smc_transaction(priv->client, outbuf, sz, inbuf,
+		sizeof(inbuf));
+	return status;
+}
+
+static int smc_rtc_set(struct device *dev, struct rtc_time *rtctime)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	int status, sz;
 	RtcMsg_t msg;
@@ -813,78 +892,65 @@ static int smc_rtc_set(struct device *dev, struct rtc_time *rtctime) {
 	msg.tm_year = bin2bcd(rtctime->tm_year - 100);
 	msg.tm_wday = (!rtctime->tm_wday) ? 7 : rtctime->tm_wday;
 	msg.sub_second = 0;
+	dev_info(dev, "RTC set to %02d.%02d.%02d %02d:%02d:%02d\n", rtctime->tm_mday,
+		rtctime->tm_mon + 1, rtctime->tm_year - 100, rtctime->tm_hour,
+		rtctime->tm_min, rtctime->tm_sec);
 	sz = rtc_create_message(msg_rtc_set_time,
-			outbuf + sizeof(MpuMsgHeader_t), &msg);
+		outbuf + sizeof(MpuMsgHeader_t), &msg);
 	sz = mpu_create_message(msg_rtc, 0, outbuf, 0, sz);
 	status = smc_transaction(priv->client, outbuf, sz, inbuf,
-			sizeof(inbuf));
+		sizeof(inbuf));
 	return status;
 }
 
 static ssize_t smc_set_wakeup(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count) {
+	const char *buf, size_t count)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
-	int status, sz;
+	int status;
 	u32 val;
-	RtcAlarm_t msg;
-	MpuMsgHeader_t hdr;
-	struct rtc_time rtc_now, rtc_alarm;
-	time64_t now;
-	RtcMsgType_t msg_type;
 
-	u8 outbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
-	u8 inbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	if (compare_version(priv->version, 3, 0) < 0)
 		return -EINVAL;
-	if (strncmp(buf, "cancel", 6) == 0)
-		msg_type = msg_rtc_cancel_alarm;
-	else {
-		msg_type = msg_rtc_set_alarm;
+	if (strncmp(buf, "cancel", 6) == 0) {
+		val = 0;
+	} else {
 		status = kstrtouint(buf, 10, &val);
 		if (status < 0)
 			return status;
-		if (val > wakeup_max_seconds) {
+		else if (val > wakeup_max_seconds) {
 			dev_err(dev, "%s: Can not set alarm beyond %d days\n",
-					__func__,
-					wakeup_max_seconds / (24 * 3600));
+				__func__, wakeup_max_seconds / (24 * 3600));
 			return -EINVAL;
 		}
-
-		status = rtc_read_time(priv->rtc, &rtc_now);
-		if (status < 0)
-			return status;
-
-		now = rtc_tm_to_time64(&rtc_now);
-		rtc_time64_to_tm(now + val, &rtc_alarm);
-
-		msg.tm_sec = bin2bcd(rtc_alarm.tm_sec);
-		msg.tm_min = bin2bcd(rtc_alarm.tm_min);
-		msg.tm_hour = bin2bcd(rtc_alarm.tm_hour);
-		msg.tm_mday = bin2bcd(rtc_alarm.tm_mday);
-		msg.pending = 0;
-		msg.enable = 1;
-		dev_info(dev, "Alarm set at %d.%d.%d %d:%d:%d\n",
-				rtc_alarm.tm_mday, rtc_alarm.tm_mon,
-				rtc_alarm.tm_year, rtc_alarm.tm_hour,
-				rtc_alarm.tm_min, rtc_alarm.tm_sec);
 	}
-	sz = rtc_create_alarm_message(msg_type, outbuf + sizeof(MpuMsgHeader_t),
-			&msg);
-	sz = mpu_create_message(msg_rtc, 0, outbuf, 0, sz);
-	status = smc_transaction(priv->client, outbuf, sz, inbuf,
-			sizeof(inbuf));
+	priv->alarm_in_seconds = val;
+	if (priv->alarm_in_seconds == 0) {
+		if (priv->alarm_pending) {
+			priv->alarm_pending = 0;
+			dev_info(dev, "Cancelled pending alarm\n");
+		} else {
+			status = smc_send_alarm(priv);
+			dev_info(dev, "Cancelled alarm\n");
+		}
+	} else {
+		if (priv->rtc_updated) {
+			priv->alarm_pending = 0;
+			status = smc_send_alarm(priv);
+		} else {
+			priv->alarm_pending = 1;
+			dev_info(dev, "Alarm pending %d seconds\n", priv->alarm_in_seconds);
+		}
+	}
 	if (status < 0)
 		return status;
-	hdr = mpu_message_header(inbuf);
-	dev_dbg(dev, "%s: Return code is %d\n", __func__, hdr.replyStatus);
-	if (hdr.replyStatus == mpu_status_ok)
-		return count;
 	else
-		return -EINVAL;
+		return count;
 }
 
 static ssize_t smc_get_wakeup(struct device *dev, struct device_attribute *attr,
-		char *buf) {
+	char *buf)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	int status, sz;
 	MpuMsgHeader_t hdr;
@@ -894,11 +960,13 @@ static ssize_t smc_get_wakeup(struct device *dev, struct device_attribute *attr,
 	u8 inbuf[mpu_max_message_size] __attribute__((aligned(0x10)));
 	if (compare_version(priv->version, 3, 0) < 0)
 		return -EINVAL;
+	if (priv->alarm_pending)
+		return sprintf(buf, "Alarm pending at %d seconds\n", priv->alarm_in_seconds);
 	sz = rtc_create_alarm_message(msg_rtc_get_alarm,
-			outbuf + sizeof(MpuMsgHeader_t), 0);
+		outbuf + sizeof(MpuMsgHeader_t), 0);
 	sz = mpu_create_message(msg_rtc, 0, outbuf, 0, sz);
 	status = smc_transaction(priv->client, outbuf, sz, inbuf,
-			sizeof(inbuf));
+		sizeof(inbuf));
 	if (status < 0)
 		return status;
 	hdr = mpu_message_header(inbuf);
@@ -906,10 +974,8 @@ static ssize_t smc_get_wakeup(struct device *dev, struct device_attribute *attr,
 		rtc_alarm_get_payload(mpu_get_payload(inbuf), &alarm);
 		if (alarm.pending)
 			return sprintf(buf, "%d %02d:%02d:%02d\n",
-					bcd2bin(alarm.tm_mday),
-					bcd2bin(alarm.tm_hour),
-					bcd2bin(alarm.tm_min),
-					bcd2bin(alarm.tm_sec));
+				bcd2bin(alarm.tm_mday), bcd2bin(alarm.tm_hour),
+				bcd2bin(alarm.tm_min), bcd2bin(alarm.tm_sec));
 		else
 			return sprintf(buf, "No alarm pending\n");
 	} else
@@ -919,7 +985,8 @@ static ssize_t smc_get_wakeup(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR(wakeup_in_seconds, S_IWUSR | S_IRUGO, smc_get_wakeup , smc_set_wakeup);
 
 static ssize_t smc_set_start_options(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count) {
+	struct device_attribute *attr, const char *buf, size_t count)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	int status, sz;
 	MpuMsgHeader_t hdr;
@@ -945,9 +1012,9 @@ static ssize_t smc_set_start_options(struct device *dev,
 	init.event_mask = cpu_to_le16(init.event_mask);
 
 	sz = mpu_create_message(msg_set_start_options, 0, outbuf, (u8*) &init,
-			sizeof(InitMessage_t));
+		sizeof(InitMessage_t));
 	status = smc_transaction(priv->client, outbuf, sz, inbuf,
-			sizeof(inbuf));
+		sizeof(inbuf));
 	if (status < 0)
 		return status;
 	hdr = mpu_message_header(inbuf);
@@ -958,7 +1025,8 @@ static ssize_t smc_set_start_options(struct device *dev,
 }
 
 static ssize_t smc_get_start_options(struct device *dev,
-		struct device_attribute *attr, char *buf) {
+	struct device_attribute *attr, char *buf)
+{
 	struct smc_data *priv = dev_get_drvdata(dev);
 	int status, sz;
 	MpuMsgHeader_t hdr;
@@ -970,9 +1038,9 @@ static ssize_t smc_get_start_options(struct device *dev,
 	init.set_mask_cmd = 0;
 	init.event_mask = 0;
 	sz = mpu_create_message(msg_set_start_options, 0, outbuf, (u8*) &init,
-			sizeof(InitMessage_t));
+		sizeof(InitMessage_t));
 	status = smc_transaction(priv->client, outbuf, sz, inbuf,
-			sizeof(inbuf));
+		sizeof(inbuf));
 	if (status < 0)
 		return status;
 	hdr = mpu_message_header(inbuf);
@@ -1001,33 +1069,34 @@ static ssize_t smc_get_start_options(struct device *dev,
 
 static DEVICE_ATTR(start_options, S_IWUSR | S_IRUGO, smc_get_start_options , smc_set_start_options);
 
-static struct attribute *smc_attrs[] = { &dev_attr_ignition_delay.attr,
-		&dev_attr_firmware_version.attr, &dev_attr_command.attr,
-		&dev_attr_debug.attr, &dev_attr_scap_voltage.attr,
-		&dev_attr_wakeup_in_seconds.attr, &dev_attr_startup_cause.attr,
-		&dev_attr_start_options.attr,
-		NULL };
+static struct attribute *smc_attrs[] = {
+	&dev_attr_ignition_delay.attr, &dev_attr_firmware_version.attr,
+	&dev_attr_command.attr, &dev_attr_debug.attr,
+	&dev_attr_scap_voltage.attr, &dev_attr_wakeup_in_seconds.attr,
+	&dev_attr_startup_cause.attr, &dev_attr_start_options.attr,
+	NULL };
 
 static const struct attribute_group smc_attr_group = { .attrs = smc_attrs, };
-static struct rtc_class_ops smc_rtc_ops = { .read_time = smc_rtc_read,
-		.set_time = smc_rtc_set, };
+static struct rtc_class_ops smc_rtc_ops = {
+	.read_time = smc_rtc_read, .set_time = smc_rtc_set, };
 
 /*
  * Power supply
  */
 
-static enum power_supply_property ps_props[] = { POWER_SUPPLY_PROP_STATUS,
-		POWER_SUPPLY_PROP_ONLINE, POWER_SUPPLY_PROP_VOLTAGE_NOW,
-		POWER_SUPPLY_PROP_VOLTAGE_MIN, POWER_SUPPLY_PROP_VOLTAGE_MAX,
-		POWER_SUPPLY_PROP_CURRENT_NOW, };
+static enum power_supply_property ps_props[] = {
+	POWER_SUPPLY_PROP_STATUS, POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW, POWER_SUPPLY_PROP_VOLTAGE_MIN,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX, POWER_SUPPLY_PROP_CURRENT_NOW, };
 
 static int smc_ps_get_property(struct power_supply *psy,
-		enum power_supply_property psp, union power_supply_propval *val) {
+	enum power_supply_property psp, union power_supply_propval *val)
+{
 	int err;
 	struct smc_data *priv = dev_get_drvdata(psy->dev.parent);
 	unsigned long jiffies_passed = jiffies - priv->sensor_jiffies;
 	if (jiffies_to_msecs(jiffies_passed) > 100
-			|| priv->sensor_jiffies == 0) {
+		|| priv->sensor_jiffies == 0) {
 		priv->sensor_jiffies = jiffies;
 		err = smc_get_sensors(priv);
 		if (err)
@@ -1072,12 +1141,12 @@ static int smc_ps_get_property(struct power_supply *psy,
 	return 0;
 }
 static const struct power_supply_desc ps_desc = { .name = "mains", .type =
-		POWER_SUPPLY_TYPE_MAINS, .properties = ps_props,
-		.num_properties = ARRAY_SIZE(ps_props), .get_property =
-				smc_ps_get_property, };
+	POWER_SUPPLY_TYPE_MAINS, .properties = ps_props, .num_properties =
+	ARRAY_SIZE(ps_props), .get_property = smc_ps_get_property, };
 
 static int smc_power_get_property(struct power_supply *psy,
-		enum power_supply_property psp, union power_supply_propval *val) {
+	enum power_supply_property psp, union power_supply_propval *val)
+{
 	int err;
 	struct smc_data *priv = dev_get_drvdata(psy->dev.parent);
 
@@ -1124,31 +1193,31 @@ static int smc_power_get_property(struct power_supply *psy,
 	return 0;
 }
 static enum power_supply_property power_props_dcout[] = {
-		POWER_SUPPLY_PROP_VOLTAGE_NOW, POWER_SUPPLY_PROP_CURRENT_NOW,
-		POWER_SUPPLY_PROP_ONLINE, };
+	POWER_SUPPLY_PROP_VOLTAGE_NOW, POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_ONLINE, };
 
 static enum power_supply_property power_props_gpo[] = {
-		POWER_SUPPLY_PROP_VOLTAGE_NOW, POWER_SUPPLY_PROP_CURRENT_NOW, };
-
-static const struct power_supply_desc ps_desc_gpo1 = { .name = "gpo1", .type =
-		POWER_SUPPLY_TYPE_MAINS, .properties = power_props_gpo,
-		.num_properties = ARRAY_SIZE(power_props_gpo), .get_property =
-				smc_power_get_property, };
-static const struct power_supply_desc ps_desc_gpo2 = { .name = "gpo2", .type =
-		POWER_SUPPLY_TYPE_MAINS, .properties = power_props_gpo,
-		.num_properties = ARRAY_SIZE(power_props_gpo), .get_property =
-				smc_power_get_property, };
-static const struct power_supply_desc ps_desc_dcout1 = { .name = "dcout1",
-		.type = POWER_SUPPLY_TYPE_MAINS,
-		.properties = power_props_dcout, .num_properties = ARRAY_SIZE(
-				power_props_dcout), .get_property =
-				smc_power_get_property, };
-static const struct power_supply_desc ps_desc_dcout2 = { .name = "can", .type =
-		POWER_SUPPLY_TYPE_MAINS, .properties = power_props_dcout,
-		.num_properties = ARRAY_SIZE(power_props_dcout), .get_property =
-				smc_power_get_property, };
-
-static int smc_setup_gpio(struct smc_data *priv) {
+	POWER_SUPPLY_PROP_VOLTAGE_NOW, POWER_SUPPLY_PROP_CURRENT_NOW, };
+
+static const struct power_supply_desc ps_desc_gpo1 = {
+	.name = "gpo1", .type = POWER_SUPPLY_TYPE_MAINS, .properties =
+		power_props_gpo, .num_properties = ARRAY_SIZE(power_props_gpo),
+	.get_property = smc_power_get_property, };
+static const struct power_supply_desc ps_desc_gpo2 = {
+	.name = "gpo2", .type = POWER_SUPPLY_TYPE_MAINS, .properties =
+		power_props_gpo, .num_properties = ARRAY_SIZE(power_props_gpo),
+	.get_property = smc_power_get_property, };
+static const struct power_supply_desc ps_desc_dcout1 = {
+	.name = "dcout1", .type = POWER_SUPPLY_TYPE_MAINS, .properties =
+		power_props_dcout, .num_properties = ARRAY_SIZE(
+		power_props_dcout), .get_property = smc_power_get_property, };
+static const struct power_supply_desc ps_desc_dcout2 = {
+	.name = "can", .type = POWER_SUPPLY_TYPE_MAINS, .properties =
+		power_props_dcout, .num_properties = ARRAY_SIZE(
+		power_props_dcout), .get_property = smc_power_get_property, };
+
+static int smc_setup_gpio(struct smc_data *priv)
+{
 	const char *gpio_names[MAX_GPIOS];
 	int err, n;
 	struct device_node *np = priv->client->dev.of_node;
@@ -1166,11 +1235,10 @@ static int smc_setup_gpio(struct smc_data *priv) {
 	priv->gpio_ctl.ngpio = n;
 
 	err = of_property_read_u8_array(np, "smc-gpio-input",
-			priv->gpio_is_input, priv->gpio_ctl.ngpio);
+		priv->gpio_is_input, priv->gpio_ctl.ngpio);
 	if (err < 0) {
 		dev_warn(&priv->client->dev,
-				"%s: DT gpios io defs do not match\n",
-				__func__);
+			"%s: DT gpios io defs do not match\n", __func__);
 		return err;
 	}
 	priv->gpio_ctl.label = "smc-gpio";
@@ -1188,18 +1256,19 @@ static int smc_setup_gpio(struct smc_data *priv) {
 
 	for (n = 0; n < priv->gpio_ctl.ngpio; n++) {
 		priv->gpio_descs[n] = gpiochip_request_own_desc(&priv->gpio_ctl,
-				n, gpio_names[n]);
+			n, gpio_names[n]);
 		gpiod_export(priv->gpio_descs[n], true);
 		priv->gpio_dev[n] = gpiod_to_dev(priv->gpio_descs[n]);
 		dev_info(&priv->client->dev, "Add GPIO %s from DT\n",
-				gpio_names[n]);
+			gpio_names[n]);
 		if (priv->gpio_is_input[n])
 			gpiod_direction_input(priv->gpio_descs[n]);
 	}
 	return err;
 }
 
-static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id) {
+static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
 	int err = 0;
 	int retries;
 	const char * irq_name = { "mcu-irq" };
@@ -1234,12 +1303,11 @@ static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	priv->irq = client->irq;
 	if (client->irq > 0) {
 		err = devm_request_threaded_irq(&client->dev, client->irq, NULL,
-				smc_irq,
-				IRQF_TRIGGER_RISING | IRQF_ONESHOT, irq_name,
-				client);
+			smc_irq,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT, irq_name, client);
 		if (err) {
 			dev_err(&client->dev, "unable to request %s\n",
-					irq_name);
+				irq_name);
 			goto exit;
 		}
 
@@ -1255,8 +1323,7 @@ static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto exit_sysfsg;
 	} else {
 		dev_info(&client->dev, "MCU FW %d.%d\n",
-				priv->version.ver_major,
-				priv->version.ver_minor);
+			priv->version.ver_major, priv->version.ver_minor);
 		if (of_property_read_bool(client->dev.of_node, "status-led")) {
 			dev_info(&client->dev, "Status LED supported\n");
 			smc_init_leds(priv);
@@ -1264,13 +1331,13 @@ static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		if (of_property_read_bool(client->dev.of_node, "has-rtc")) {
 			if (priv->version.ver_major >= 3) {
 				dev_info(&client->dev,
-						"RTC supported with alarm\n");
+					"RTC supported with alarm\n");
 				if (priv->irq)
 					device_init_wakeup(&client->dev, 1);
 			} else
 				dev_info(&client->dev, "RTC supported\n");
 			priv->rtc = devm_rtc_device_register(&client->dev,
-					"mcu", &smc_rtc_ops, THIS_MODULE);
+				"mcu", &smc_rtc_ops, THIS_MODULE);
 		}
 	}
 
@@ -1286,10 +1353,10 @@ static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		psy_cfg.of_node = client->dev.of_node;
 		psy_cfg.drv_data = priv;
 		priv->psy = devm_power_supply_register(&client->dev, &ps_desc,
-				&psy_cfg);
+			&psy_cfg);
 		if (IS_ERR(priv->psy)) {
 			dev_err(&client->dev,
-					"Failed to create power supply\n");
+				"Failed to create power supply\n");
 			err = PTR_ERR(priv->psy);
 			goto exit_sysfsg;
 		}
@@ -1298,18 +1365,17 @@ static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		psy_cfg.of_node = client->dev.of_node;
 		psy_cfg.drv_data = priv;
 		priv->psy_dcout1 = devm_power_supply_register(&client->dev,
-				&ps_desc_dcout1, &psy_cfg);
+			&ps_desc_dcout1, &psy_cfg);
 		priv->psy_dcout2 = devm_power_supply_register(&client->dev,
-				&ps_desc_dcout2, &psy_cfg);
+			&ps_desc_dcout2, &psy_cfg);
 		priv->psy_gpo1 = devm_power_supply_register(&client->dev,
-				&ps_desc_gpo1, &psy_cfg);
+			&ps_desc_gpo1, &psy_cfg);
 		priv->psy_gpo2 = devm_power_supply_register(&client->dev,
-				&ps_desc_gpo2, &psy_cfg);
+			&ps_desc_gpo2, &psy_cfg);
 		if (IS_ERR(priv->psy_dcout1) || IS_ERR(priv->psy_dcout2)
-				|| IS_ERR(priv->psy_gpo1)
-				|| IS_ERR(priv->psy_gpo2)) {
+			|| IS_ERR(priv->psy_gpo1) || IS_ERR(priv->psy_gpo2)) {
 			dev_err(&client->dev,
-					"Failed to create power supply\n");
+				"Failed to create power supply\n");
 			err = -ENOMEM;
 			goto exit_sysfsg;
 		}
@@ -1321,7 +1387,8 @@ static int smc_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	return err;
 }
 
-static int smc_remove(struct i2c_client *client) {
+static int smc_remove(struct i2c_client *client)
+{
 	int n;
 	struct smc_data *priv = i2c_get_clientdata(client);
 	cancel_work_sync(&priv->alert_work);
@@ -1337,10 +1404,22 @@ static int smc_remove(struct i2c_client *client) {
 	return 0;
 }
 
-static void smc_shutdown(struct i2c_client *client) {
+static void smc_shutdown(struct i2c_client *client)
+{
 	struct smc_data *priv = i2c_get_clientdata(client);
-	int err = send_reboot(priv);
-	if (err < 0)
+	int ret;
+	if (compare_version(priv->version, 3, 0) >= 0 && priv->alarm_pending) {
+		ret = smc_send_alarm(priv);
+		if (ret < 0)
+			dev_warn(&client->dev, "%s: Failed [%d] to send pending alarm\n",
+				__func__, ret);
+		else
+			dev_info(&client->dev, "%s: Send pending alarm @%d seconds\n",
+				__func__, priv->alarm_in_seconds);
+		priv->alarm_pending = 0;
+	}
+	ret = send_reboot(priv);
+	if (ret < 0)
 		dev_err(&client->dev, "%s: Failed to call SMC\n", __func__);
 	cancel_work_sync(&priv->alert_work);
 }
@@ -1370,18 +1449,18 @@ static int smc_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(smc_pm_ops, smc_suspend, smc_resume);
 
 static const struct of_device_id of_smc_match[] = { { .compatible =
-		"datarespons,vhgw-smc" }, { /* Sentinel */} };
+	"datarespons,vhgw-smc" }, { /* Sentinel */} };
 
 static struct i2c_device_id smc_id[] = { { "vhgw-smc", 0 }, { } };
 
 MODULE_DEVICE_TABLE( i2c, smc_id);
 
-static struct i2c_driver vhgw_smc_driver = { .driver = { .owner = THIS_MODULE,
-		.name = "vhgw_smc", .of_match_table = of_smc_match, .pm =
-				&smc_pm_ops, },
+static struct i2c_driver vhgw_smc_driver = { .driver = {
+	.owner = THIS_MODULE, .name = "vhgw_smc", .of_match_table =
+		of_smc_match, .pm = &smc_pm_ops, },
 
 .id_table = smc_id, .probe = smc_probe, .remove = smc_remove, .shutdown =
-		smc_shutdown, };
+	smc_shutdown, };
 
 module_i2c_driver( vhgw_smc_driver);
 
-- 
2.17.1


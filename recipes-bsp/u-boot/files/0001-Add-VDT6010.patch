From f63081f4141e5f00f14ecde3119a4d6760d300c6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mikko=20Salom=C3=A4ki?= <ms@datarespons.se>
Date: Mon, 29 Apr 2019 10:29:51 +0200
Subject: [PATCH] Add VDT6010

---
 arch/arm/mach-imx/mx6/Kconfig                      |   8 +-
 board/datarespons/vdt6010/Kconfig                  |  30 ++
 board/datarespons/vdt6010/MAINTAINERS              |   6 +
 board/datarespons/vdt6010/Makefile                 |  14 +
 board/datarespons/vdt6010/fused_rev.c              |  23 ++
 board/datarespons/vdt6010/mx6.cfg                  |  28 ++
 .../vdt6010/ram/NT5CC256M16EP-EK_calib.txt         | 320 +++++++++++++++++
 board/datarespons/vdt6010/spl.c                    | 251 +++++++++++++
 board/datarespons/vdt6010/vdt6010.c                | 398 +++++++++++++++++++++
 board/datarespons/vdt6010/vdt6010_gpio.h           |  40 +++
 board/datarespons/vdt6010/vdt6010_pins.h           | 157 ++++++++
 configs/vdt6010_defconfig                          |  59 +++
 include/configs/vdt6010.h                          | 302 ++++++++++++++++
 13 files changed, 1632 insertions(+), 4 deletions(-)
 create mode 100644 board/datarespons/vdt6010/Kconfig
 create mode 100644 board/datarespons/vdt6010/MAINTAINERS
 create mode 100644 board/datarespons/vdt6010/Makefile
 create mode 100644 board/datarespons/vdt6010/fused_rev.c
 create mode 100644 board/datarespons/vdt6010/mx6.cfg
 create mode 100644 board/datarespons/vdt6010/ram/NT5CC256M16EP-EK_calib.txt
 create mode 100644 board/datarespons/vdt6010/spl.c
 create mode 100644 board/datarespons/vdt6010/vdt6010.c
 create mode 100644 board/datarespons/vdt6010/vdt6010_gpio.h
 create mode 100644 board/datarespons/vdt6010/vdt6010_pins.h
 create mode 100644 configs/vdt6010_defconfig
 create mode 100644 include/configs/vdt6010.h

diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index 0ad9b40bb6..7244ea8413 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -517,6 +517,15 @@
	select DM_THERMAL
	select SUPPORT_SPL
	imply CMD_DM
+	
+config TARGET_VDT6010
+	bool "vdt6010"
+	select MX6QDL
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	select DM
+	select DM_THERMAL
+	select BOARD_EARLY_INIT_F
 
 endchoice
 
@@ -571,5 +579,6 @@
 source "board/udoo/neo/Kconfig"
 source "board/wandboard/Kconfig"
 source "board/warp/Kconfig"
+source "board/datarespons/vdt6010/Kconfig"
 
 endif

diff --git a/board/datarespons/vdt6010/Kconfig b/board/datarespons/vdt6010/Kconfig
new file mode 100644
index 0000000000..4a4b0abd3c
--- /dev/null
+++ b/board/datarespons/vdt6010/Kconfig
@@ -0,0 +1,30 @@
+if TARGET_VDT6010
+
+config SYS_BOARD
+	default "vdt6010"
+
+config SYS_VENDOR
+	default "datarespons"
+
+config SYS_CONFIG_NAME
+	default "vdt6010"
+
+config PMIC_I2C_BUS
+	int
+	default 0
+
+config FACTORY_BOOT
+	bool "Factory boot mode"
+	default n
+	help
+	  Enables the factory installation boot mode
+
+config LOGLEVEL
+	int "Kernel loglevel"
+	default 4
+
+config BOOT_USB_INITRD
+	bool "Only allow usb boot from signed initrd"
+	default n
+
+endif
diff --git a/board/datarespons/vdt6010/MAINTAINERS b/board/datarespons/vdt6010/MAINTAINERS
new file mode 100644
index 0000000000..614046e756
--- /dev/null
+++ b/board/datarespons/vdt6010/MAINTAINERS
@@ -0,0 +1,6 @@
+VDT6010 BOARD
+M:	Mikko Salomäki <ms@datarespons.se>
+S:	Maintained
+F:	board/datarespons/vdt6010
+F:	include/configs/vdt6010.h
+F:	configs/vdt6010_defconfig
diff --git a/board/datarespons/vdt6010/Makefile b/board/datarespons/vdt6010/Makefile
new file mode 100644
index 0000000000..abf09a8f59
--- /dev/null
+++ b/board/datarespons/vdt6010/Makefile
@@ -0,0 +1,14 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-y += vdt6010.o
+obj-y += ../common/dev/pfuze100.o
+endif
diff --git a/board/datarespons/vdt6010/fused_rev.c b/board/datarespons/vdt6010/fused_rev.c
new file mode 100644
index 0000000000..9f66bda4ca
--- /dev/null
+++ b/board/datarespons/vdt6010/fused_rev.c
@@ -0,0 +1,23 @@
+#ifdef CONFIG_NXP_BOARD_REVISION
+int nxp_board_rev(void)
+{
+	/*
+	 * Get Board ID information from OCOTP_GP1[15:8]
+	 * RevA: 0x1
+	 * RevB: 0x2
+	 * RevC: 0x3
+	 */
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[4];
+	struct fuse_bank4_regs *fuse =
+			(struct fuse_bank4_regs *)bank->fuse_regs;
+
+	return (readl(&fuse->gp1) >> 8 & 0x0F);
+}
+
+char nxp_board_rev_string(void)
+{
+	const char *rev = "A";
+
+	return (*rev + nxp_board_rev() - 1);
+}
diff --git a/board/datarespons/vdt6010/mx6.cfg b/board/datarespons/vdt6010/mx6.cfg
new file mode 100644
index 0000000000..9d5347a634
--- /dev/null
+++ b/board/datarespons/vdt6010/mx6.cfg
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
diff --git a/board/datarespons/vdt6010/ram/NT5CC256M16EP-EK_calib.txt b/board/datarespons/vdt6010/ram/NT5CC256M16EP-EK_calib.txt
new file mode 100644
index 0000000000..593b230d4a
--- /dev/null
+++ b/board/datarespons/vdt6010/ram/NT5CC256M16EP-EK_calib.txt
@@ -0,0 +1,320 @@
+
+============================================
+        DDR Stress Test (3.0.0) 
+        Build: Dec 14 2018, 14:12:06
+        NXP Semiconductors.
+============================================
+
+============================================
+        Chip ID
+CHIP ID = i.MX6 Dual/Quad (0x63)
+Internal Revision = TO1.5
+============================================
+
+============================================
+        Boot Configuration
+SRC_SBMR1(0x020d8004) = 0x09007830
+SRC_SBMR2(0x020d801c) = 0x19000001
+============================================
+
+ARM Clock set to 1GHz
+
+============================================
+        DDR configuration
+BOOT_CFG3[5-4]: 0x00, Single DDR channel.
+DDR type is DDR3 
+Data width: 64, bank num: 8
+Row size: 15, col size: 10
+Chip select CSD0 is used 
+Density per chip select: 2048MB 
+============================================
+
+Current Temperature: 28
+============================================
+
+DDR Freq: 528 MHz 
+
+ddr_mr1=0x00000000
+Start write leveling calibration...
+running Write level HW calibration
+  MPWLHWERR register read out for factory diagnostics: 
+  MPWLHWERR PHY0 = 0x3e3e3e3e
+  MPWLHWERR PHY1 = 0x1e3e1e3c
+
+Write leveling calibration completed, update the following registers in your initialization script
+    MMDC_MPWLDECTRL0 ch0 (0x021b080c) = 0x001E001D
+    MMDC_MPWLDECTRL1 ch0 (0x021b0810) = 0x001E0019
+    MMDC_MPWLDECTRL0 ch1 (0x021b480c) = 0x000F0024
+    MMDC_MPWLDECTRL1 ch1 (0x021b4810) = 0x000D001F
+Write DQS delay result:
+   Write DQS0 delay: 29/256 CK
+   Write DQS1 delay: 30/256 CK
+   Write DQS2 delay: 25/256 CK
+   Write DQS3 delay: 30/256 CK
+   Write DQS4 delay: 36/256 CK
+   Write DQS5 delay: 15/256 CK
+   Write DQS6 delay: 31/256 CK
+   Write DQS7 delay: 13/256 CK
+
+Starting DQS gating calibration
+. HC_DEL=0x00000000	result[00]=0x11111111
+. HC_DEL=0x00000001	result[01]=0x01101110
+. HC_DEL=0x00000002	result[02]=0x00000000
+. HC_DEL=0x00000003	result[03]=0x00000000
+. HC_DEL=0x00000004	result[04]=0x01000000
+. HC_DEL=0x00000005	result[05]=0x11111111
+. HC_DEL=0x00000006	result[06]=0x11111111
+. HC_DEL=0x00000007	result[07]=0x11111111
+. HC_DEL=0x00000008	result[08]=0x11111111
+. HC_DEL=0x00000009	result[09]=0x11111111
+. HC_DEL=0x0000000A	result[0A]=0x11111111
+. HC_DEL=0x0000000B	result[0B]=0x11111111
+. HC_DEL=0x0000000C	result[0C]=0x11111111
+. HC_DEL=0x0000000D	result[0D]=0x11111111
+DQS HC delay value low1 = 0x02020201, high1=0x04040404
+DQS HC delay value low2 = 0x01020201, high2=0x04030404
+
+loop ABS offset to get HW_DG_LOW
+. ABS_OFFSET=0x00000000	result[00]=0x11111111
+. ABS_OFFSET=0x00000004	result[01]=0x11111111
+. ABS_OFFSET=0x00000008	result[02]=0x11111111
+. ABS_OFFSET=0x0000000C	result[03]=0x11111111
+. ABS_OFFSET=0x00000010	result[04]=0x11111111
+. ABS_OFFSET=0x00000014	result[05]=0x11111111
+. ABS_OFFSET=0x00000018	result[06]=0x11111111
+. ABS_OFFSET=0x0000001C	result[07]=0x11111111
+. ABS_OFFSET=0x00000020	result[08]=0x11111111
+. ABS_OFFSET=0x00000024	result[09]=0x11111111
+. ABS_OFFSET=0x00000028	result[0A]=0x11111111
+. ABS_OFFSET=0x0000002C	result[0B]=0x11111111
+. ABS_OFFSET=0x00000030	result[0C]=0x10111111
+. ABS_OFFSET=0x00000034	result[0D]=0x10111111
+. ABS_OFFSET=0x00000038	result[0E]=0x10111111
+. ABS_OFFSET=0x0000003C	result[0F]=0x10111111
+. ABS_OFFSET=0x00000040	result[10]=0x10111111
+. ABS_OFFSET=0x00000044	result[11]=0x00111111
+. ABS_OFFSET=0x00000048	result[12]=0x00111111
+. ABS_OFFSET=0x0000004C	result[13]=0x00110111
+. ABS_OFFSET=0x00000050	result[14]=0x00110011
+. ABS_OFFSET=0x00000054	result[15]=0x00110011
+. ABS_OFFSET=0x00000058	result[16]=0x00100001
+. ABS_OFFSET=0x0000005C	result[17]=0x00100001
+. ABS_OFFSET=0x00000060	result[18]=0x00100000
+. ABS_OFFSET=0x00000064	result[19]=0x00000000
+. ABS_OFFSET=0x00000068	result[1A]=0x00000000
+. ABS_OFFSET=0x0000006C	result[1B]=0x00000000
+. ABS_OFFSET=0x00000070	result[1C]=0x00000000
+. ABS_OFFSET=0x00000074	result[1D]=0x00000000
+. ABS_OFFSET=0x00000078	result[1E]=0x00000000
+. ABS_OFFSET=0x0000007C	result[1F]=0x00000000
+
+loop ABS offset to get HW_DG_HIGH
+. ABS_OFFSET=0x00000000	result[00]=0x00000000
+. ABS_OFFSET=0x00000004	result[01]=0x00000000
+. ABS_OFFSET=0x00000008	result[02]=0x00000100
+. ABS_OFFSET=0x0000000C	result[03]=0x00000100
+. ABS_OFFSET=0x00000010	result[04]=0x10001100
+. ABS_OFFSET=0x00000014	result[05]=0x10101110
+. ABS_OFFSET=0x00000018	result[06]=0x10101110
+. ABS_OFFSET=0x0000001C	result[07]=0x10101110
+. ABS_OFFSET=0x00000020	result[08]=0x10101110
+. ABS_OFFSET=0x00000024	result[09]=0x10111110
+. ABS_OFFSET=0x00000028	result[0A]=0x10111111
+. ABS_OFFSET=0x0000002C	result[0B]=0x10111111
+. ABS_OFFSET=0x00000030	result[0C]=0x10111111
+. ABS_OFFSET=0x00000034	result[0D]=0x10111111
+. ABS_OFFSET=0x00000038	result[0E]=0x10111111
+. ABS_OFFSET=0x0000003C	result[0F]=0x10111111
+. ABS_OFFSET=0x00000040	result[10]=0x10111111
+. ABS_OFFSET=0x00000044	result[11]=0x10111111
+. ABS_OFFSET=0x00000048	result[12]=0x10111111
+. ABS_OFFSET=0x0000004C	result[13]=0x10111111
+. ABS_OFFSET=0x00000050	result[14]=0x10111111
+. ABS_OFFSET=0x00000054	result[15]=0x10111111
+. ABS_OFFSET=0x00000058	result[16]=0x10111111
+. ABS_OFFSET=0x0000005C	result[17]=0x11111111
+. ABS_OFFSET=0x00000060	result[18]=0x11111111
+. ABS_OFFSET=0x00000064	result[19]=0x11111111
+. ABS_OFFSET=0x00000068	result[1A]=0x11111111
+. ABS_OFFSET=0x0000006C	result[1B]=0x11111111
+. ABS_OFFSET=0x00000070	result[1C]=0x11111111
+. ABS_OFFSET=0x00000074	result[1D]=0x11111111
+. ABS_OFFSET=0x00000078	result[1E]=0x11111111
+. ABS_OFFSET=0x0000007C	result[1F]=0x11111111
+
+
+BYTE 0: 
+	Start:		 HC=0x00 ABS=0x60
+	End:		 HC=0x04 ABS=0x24
+	Mean:		 HC=0x02 ABS=0x42
+	End-0.5*tCK:	 HC=0x03 ABS=0x24
+	Final:		 HC=0x03 ABS=0x24
+BYTE 1: 
+	Start:		 HC=0x01 ABS=0x58
+	End:		 HC=0x04 ABS=0x10
+	Mean:		 HC=0x02 ABS=0x73
+	End-0.5*tCK:	 HC=0x03 ABS=0x10
+	Final:		 HC=0x03 ABS=0x10
+BYTE 2: 
+	Start:		 HC=0x01 ABS=0x50
+	End:		 HC=0x04 ABS=0x04
+	Mean:		 HC=0x02 ABS=0x69
+	End-0.5*tCK:	 HC=0x03 ABS=0x04
+	Final:		 HC=0x03 ABS=0x04
+BYTE 3: 
+	Start:		 HC=0x01 ABS=0x4C
+	End:		 HC=0x04 ABS=0x0C
+	Mean:		 HC=0x02 ABS=0x6B
+	End-0.5*tCK:	 HC=0x03 ABS=0x0C
+	Final:		 HC=0x03 ABS=0x0C
+BYTE 4: 
+	Start:		 HC=0x00 ABS=0x58
+	End:		 HC=0x04 ABS=0x20
+	Mean:		 HC=0x02 ABS=0x3C
+	End-0.5*tCK:	 HC=0x03 ABS=0x20
+	Final:		 HC=0x03 ABS=0x20
+BYTE 5: 
+	Start:		 HC=0x01 ABS=0x64
+	End:		 HC=0x04 ABS=0x10
+	Mean:		 HC=0x02 ABS=0x79
+	End-0.5*tCK:	 HC=0x03 ABS=0x10
+	Final:		 HC=0x03 ABS=0x10
+BYTE 6: 
+	Start:		 HC=0x01 ABS=0x30
+	End:		 HC=0x03 ABS=0x58
+	Mean:		 HC=0x02 ABS=0x44
+	End-0.5*tCK:	 HC=0x02 ABS=0x58
+	Final:		 HC=0x02 ABS=0x58
+BYTE 7: 
+	Start:		 HC=0x00 ABS=0x44
+	End:		 HC=0x04 ABS=0x0C
+	Mean:		 HC=0x02 ABS=0x28
+	End-0.5*tCK:	 HC=0x03 ABS=0x0C
+	Final:		 HC=0x03 ABS=0x0C
+
+DQS calibration MMDC0 MPDGCTRL0 = 0x03100324, MPDGCTRL1 = 0x030C0304
+
+DQS calibration MMDC1 MPDGCTRL0 = 0x03100320, MPDGCTRL1 = 0x030C0258
+
+Note: Array result[] holds the DRAM test result of each byte.  
+      0: test pass.  1: test fail  
+      4 bits respresent the result of 1 byte.    
+      result 00000001:byte 0 fail. 
+      result 00000011:byte 0, 1 fail. 
+
+Starting Read calibration...
+
+ABS_OFFSET=0x00000000	result[00]=0x11111111
+ABS_OFFSET=0x04040404	result[01]=0x11111111
+ABS_OFFSET=0x08080808	result[02]=0x11111111
+ABS_OFFSET=0x0C0C0C0C	result[03]=0x11111111
+ABS_OFFSET=0x10101010	result[04]=0x01011011
+ABS_OFFSET=0x14141414	result[05]=0x01011011
+ABS_OFFSET=0x18181818	result[06]=0x00011010
+ABS_OFFSET=0x1C1C1C1C	result[07]=0x00011000
+ABS_OFFSET=0x20202020	result[08]=0x00011000
+ABS_OFFSET=0x24242424	result[09]=0x00000000
+ABS_OFFSET=0x28282828	result[0A]=0x00000000
+ABS_OFFSET=0x2C2C2C2C	result[0B]=0x00000000
+ABS_OFFSET=0x30303030	result[0C]=0x00000000
+ABS_OFFSET=0x34343434	result[0D]=0x00000000
+ABS_OFFSET=0x38383838	result[0E]=0x00000000
+ABS_OFFSET=0x3C3C3C3C	result[0F]=0x00000000
+ABS_OFFSET=0x40404040	result[10]=0x00000000
+ABS_OFFSET=0x44444444	result[11]=0x00000000
+ABS_OFFSET=0x48484848	result[12]=0x00000000
+ABS_OFFSET=0x4C4C4C4C	result[13]=0x00000000
+ABS_OFFSET=0x50505050	result[14]=0x00000000
+ABS_OFFSET=0x54545454	result[15]=0x00000000
+ABS_OFFSET=0x58585858	result[16]=0x00000000
+ABS_OFFSET=0x5C5C5C5C	result[17]=0x00000000
+ABS_OFFSET=0x60606060	result[18]=0x00100000
+ABS_OFFSET=0x64646464	result[19]=0x00100000
+ABS_OFFSET=0x68686868	result[1A]=0x01100100
+ABS_OFFSET=0x6C6C6C6C	result[1B]=0x01100110
+ABS_OFFSET=0x70707070	result[1C]=0x11100110
+ABS_OFFSET=0x74747474	result[1D]=0x11101111
+ABS_OFFSET=0x78787878	result[1E]=0x11111111
+ABS_OFFSET=0x7C7C7C7C	result[1F]=0x11111111
+
+Byte 0: (0x18 - 0x70), middle value:0x44
+Byte 1: (0x1c - 0x68), middle value:0x42
+Byte 2: (0x10 - 0x64), middle value:0x3a
+Byte 3: (0x24 - 0x70), middle value:0x4a
+Byte 4: (0x24 - 0x74), middle value:0x4c
+Byte 5: (0x10 - 0x5c), middle value:0x36
+Byte 6: (0x18 - 0x64), middle value:0x3e
+Byte 7: (0x10 - 0x6c), middle value:0x3e
+
+MMDC0 MPRDDLCTL = 0x4A3A4244, MMDC1 MPRDDLCTL = 0x3E3E364C
+
+Starting Write calibration...
+
+ABS_OFFSET=0x00000000	result[00]=0x11111111
+ABS_OFFSET=0x04040404	result[01]=0x10111111
+ABS_OFFSET=0x08080808	result[02]=0x10111111
+ABS_OFFSET=0x0C0C0C0C	result[03]=0x10100111
+ABS_OFFSET=0x10101010	result[04]=0x10100010
+ABS_OFFSET=0x14141414	result[05]=0x00100010
+ABS_OFFSET=0x18181818	result[06]=0x00100000
+ABS_OFFSET=0x1C1C1C1C	result[07]=0x00000000
+ABS_OFFSET=0x20202020	result[08]=0x00000000
+ABS_OFFSET=0x24242424	result[09]=0x00000000
+ABS_OFFSET=0x28282828	result[0A]=0x00000000
+ABS_OFFSET=0x2C2C2C2C	result[0B]=0x00000000
+ABS_OFFSET=0x30303030	result[0C]=0x00000000
+ABS_OFFSET=0x34343434	result[0D]=0x00000000
+ABS_OFFSET=0x38383838	result[0E]=0x00000000
+ABS_OFFSET=0x3C3C3C3C	result[0F]=0x00000000
+ABS_OFFSET=0x40404040	result[10]=0x00000000
+ABS_OFFSET=0x44444444	result[11]=0x00000000
+ABS_OFFSET=0x48484848	result[12]=0x00000000
+ABS_OFFSET=0x4C4C4C4C	result[13]=0x00000000
+ABS_OFFSET=0x50505050	result[14]=0x00000000
+ABS_OFFSET=0x54545454	result[15]=0x00000000
+ABS_OFFSET=0x58585858	result[16]=0x00000000
+ABS_OFFSET=0x5C5C5C5C	result[17]=0x00000000
+ABS_OFFSET=0x60606060	result[18]=0x00000000
+ABS_OFFSET=0x64646464	result[19]=0x01000000
+ABS_OFFSET=0x68686868	result[1A]=0x01000000
+ABS_OFFSET=0x6C6C6C6C	result[1B]=0x01011000
+ABS_OFFSET=0x70707070	result[1C]=0x01011100
+ABS_OFFSET=0x74747474	result[1D]=0x01111111
+ABS_OFFSET=0x78787878	result[1E]=0x11111111
+ABS_OFFSET=0x7C7C7C7C	result[1F]=0x11111111
+
+Byte 0: (0x10 - 0x70), middle value:0x40
+Byte 1: (0x18 - 0x70), middle value:0x44
+Byte 2: (0x10 - 0x6c), middle value:0x3e
+Byte 3: (0x0c - 0x68), middle value:0x3a
+(0x0c - 0x68), middle value:0x3aByte 5: (0x1c - 0x70), middle value:0x46
+Byte 6: (0x04 - 0x60), middle value:0x32
+Byte 7: (0x14 - 0x74), middle value:0x44
+
+MMDC0 MPWRDLCTL = 0x3A3E4440,MMDC1 MPWRDLCTL = 0x4432463A
+
+
+   MMDC registers updated from calibration 
+
+   Write leveling calibration
+   MMDC_MPWLDECTRL0 ch0 (0x021b080c) = 0x001E001D
+   MMDC_MPWLDECTRL1 ch0 (0x021b0810) = 0x001E0019
+   MMDC_MPWLDECTRL0 ch1 (0x021b480c) = 0x000F0024
+   MMDC_MPWLDECTRL1 ch1 (0x021b4810) = 0x000D001F
+
+   Read DQS Gating calibration
+   MPDGCTRL0 PHY0 (0x021b083c) = 0x03100324
+   MPDGCTRL1 PHY0 (0x021b0840) = 0x030C0304
+   MPDGCTRL0 PHY1 (0x021b483c) = 0x03100320
+   MPDGCTRL1 PHY1 (0x021b4840) = 0x030C0258
+
+   Read calibration
+   MPRDDLCTL PHY0 (0x021b0848) = 0x4A3A4244
+   MPRDDLCTL PHY1 (0x021b4848) = 0x3E3E364C
+
+   Write calibration
+   MPWRDLCTL PHY0 (0x021b0850) = 0x3A3E4440
+   MPWRDLCTL PHY1 (0x021b4850) = 0x4432463A
+
+
+Success: DDR calibration completed!!!
diff --git a/board/datarespons/vdt6010/spl.c b/board/datarespons/vdt6010/spl.c
new file mode 100644
index 0000000000..c5141c240b
--- /dev/null
+++ b/board/datarespons/vdt6010/spl.c
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2019 Data Respons Solutions AB
+ *
+ * Author: Mikko Salomäki <ms@datarespons.se>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/mach-imx/spi.h>
+#include <linux/errno.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <input.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include <environment.h>
+#include <usb.h>
+#include <pwm.h>
+#include <version.h>
+#include <watchdog.h>
+#include <asm/arch/mx6-ddr.h>
+#include <spl.h>
+#include <asm/mach-imx/hab.h>
+//#include <vsprintf.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#include "../common/mx6_common_defs.h"
+#include "vdt6010_pins.h"
+#include "vdt6010_gpio.h"
+
+
+struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC4_BASE_ADDR},
+};
+
+static int get_version(void)
+{
+	return 0;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC4_BASE_ADDR:
+		ret = 1;
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	unsigned reg = readl(&psrc->sbmr1) >> 11;
+	/*
+	 * Upon reading BOOT_CFG register the following map is done:
+	 * Bit 11 and 12 of BOOT_CFG register can determine the current
+	 * mmc port
+	 * 0x1                  SD1
+	 * 0x2                  SD2
+	 * 0x3                  SD4
+	 */
+
+	switch (reg & 0x3) {
+	case 0x1:
+		SETUP_IOMUX_PADS(usdhc2_pads);
+		usdhc_cfg[0].esdhc_base = USDHC2_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	case 0x3:
+		SETUP_IOMUX_PADS(usdhc4_pads);
+		usdhc_cfg[0].esdhc_base = USDHC4_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	}
+
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+}
+
+#define MX6DQ_DDR_TYPE_DD3 0x000C0000
+#define MX6DQ_DDRPKE_DISABLED 0x00000000
+#define MX6DQ_DS_48_OHM 0x00000028
+#define MX6DQ_DS_40_OHM 0x00000030
+#define MX6DQ_DS_GRP 0x00000000
+#define MX6DQ_INPUT_DIFFERENTIAL 0x00020000
+
+static const struct mx6dq_iomux_ddr_regs mx6dq_ddr_ioregs = {
+	.dram_sdclk_0 = MX6DQ_DS_48_OHM,
+	.dram_sdclk_1 = MX6DQ_DS_48_OHM,
+	.dram_cas = MX6DQ_DS_48_OHM,
+	.dram_ras = MX6DQ_DS_48_OHM,
+	.dram_reset = MX6DQ_DS_48_OHM,
+	.dram_sdba2 = MX6DQ_DS_GRP,
+	.dram_sdcke0 = 0x00003000, // reserved bits
+	.dram_sdcke1 = 0x00003000, // reserved bits
+	.dram_sdodt0 = MX6DQ_DS_48_OHM,
+	.dram_sdodt1 = MX6DQ_DS_48_OHM,
+	.dram_sdqs0 = MX6DQ_DS_48_OHM,
+	.dram_sdqs1 = MX6DQ_DS_48_OHM,
+	.dram_sdqs2 = MX6DQ_DS_48_OHM,
+	.dram_sdqs3 = MX6DQ_DS_48_OHM,
+	.dram_sdqs4 = MX6DQ_DS_48_OHM,
+	.dram_sdqs5 = MX6DQ_DS_48_OHM,
+	.dram_sdqs6 = MX6DQ_DS_48_OHM,
+	.dram_sdqs7 = MX6DQ_DS_48_OHM,
+	.dram_dqm0 = MX6DQ_DS_48_OHM,
+	.dram_dqm1 = MX6DQ_DS_48_OHM,
+	.dram_dqm2 = MX6DQ_DS_48_OHM,
+	.dram_dqm3 = MX6DQ_DS_48_OHM,
+	.dram_dqm4 = MX6DQ_DS_48_OHM,
+	.dram_dqm5 = MX6DQ_DS_48_OHM,
+	.dram_dqm6 = MX6DQ_DS_48_OHM,
+	.dram_dqm7 = MX6DQ_DS_48_OHM,
+};
+
+static const struct mx6dq_iomux_grp_regs mx6dq_grp_ioregs = {
+	.grp_ddr_type = MX6DQ_DDR_TYPE_DD3,
+	.grp_ddrpke = MX6DQ_DDRPKE_DISABLED,
+	.grp_addds = MX6DQ_DS_48_OHM,
+	.grp_ctlds = MX6DQ_DS_48_OHM,
+	.grp_ddrmode_ctl = MX6DQ_INPUT_DIFFERENTIAL,
+	.grp_ddrmode = MX6DQ_INPUT_DIFFERENTIAL,
+	.grp_b0ds = MX6DQ_DS_48_OHM,
+	.grp_b1ds = MX6DQ_DS_48_OHM,
+	.grp_b2ds = MX6DQ_DS_48_OHM,
+	.grp_b3ds = MX6DQ_DS_48_OHM,
+	.grp_b4ds = MX6DQ_DS_48_OHM,
+	.grp_b5ds = MX6DQ_DS_48_OHM,
+	.grp_b6ds = MX6DQ_DS_48_OHM,
+	.grp_b7ds = MX6DQ_DS_48_OHM,
+};
+
+static const struct mx6_mmdc_calibration mx6dq_calib_NT5CC256M16EP_EK = {
+	.p0_mpwldectrl0 =  0x001E001D,
+	.p0_mpwldectrl1 =  0x001E0019,
+	.p1_mpwldectrl0 =  0x000F0024,
+	.p1_mpwldectrl1 =  0x000D001F,
+	.p0_mpdgctrl0 =  0x03100324,
+	.p0_mpdgctrl1 =  0x030C0304,
+	.p1_mpdgctrl0 =  0x03100320,
+	.p1_mpdgctrl1 =  0x030C0258,
+	.p0_mprddlctl =  0x4A3A4244,
+	.p1_mprddlctl =  0x3E3E364C,
+	.p0_mpwrdlctl =  0x3A3E4440,
+	.p1_mpwrdlctl =  0x4432463A,
+};
+
+static const struct mx6_ddr3_cfg mem_ddr_NT5CC256M16EP_EK = {
+	.mem_speed = 1600,
+	.density = 4,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+	/*.SRT = 1,*/
+};
+
+static struct mx6_ddr_sysinfo sysinfo = {
+	/* width of data bus:0=16,1=32,2=64 */
+	.dsize = 2,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density = 32, /* 32Gb per CS */
+	/* single chip select */
+	.ncs = 1,
+	.cs1_mirror = 0,
+	.rtt_wr = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Wr = RZQ/4 */
+#ifdef RTT_NOM_120OHM
+	.rtt_nom = 2 /*DDR3_RTT_120_OHM*/,	/* RTT_Nom = RZQ/2 */
+#else
+	.rtt_nom = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Nom = RZQ/4 */
+#endif
+	.walat = 1,	/* Write additional latency */
+	.ralat = 5,	/* Read additional latency */
+	.mif3_mode = 3,	/* Command prediction working mode */
+	.bi_on = 1,	/* Bank interleaving enabled */
+	.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+	.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	.ddr_type = DDR_TYPE_DDR3,
+	.refsel = 1,	/* Refresh cycles at 32KHz */
+	.refr = 7,	/* 8 refresh commands per refresh cycle */
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FF03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF00000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000C3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+}
+
+static void spl_dram_init(void)
+{
+	mx6dq_dram_iocfg(64, &mx6dq_ddr_ioregs, &mx6dq_grp_ioregs);
+	mx6_dram_cfg(&sysinfo, &mx6dq_calib_NT5CC256M16EP_EK, &mem_ddr_NT5CC256M16EP_EK);
+}
+
+int board_early_init_f(void)
+{
+	SETUP_IOMUX_PADS(uart5_pads);
+
+	return 0;
+}
+
+void board_init_f(ulong dummy)
+{
+	arch_cpu_init();
+	ccgr_init();
+	gpr_init();
+
+#ifdef CONFIG_SPL_WATCHDOG_SUPPORT
+	void hw_watchdog_init(void);
+	hw_watchdog_init();
+#endif
+
+	board_early_init_f();
+
+	// setup GP timer
+	timer_init();
+
+	// Setup console
+	preloader_console_init();
+
+	// Set DRAM config
+	spl_dram_init();
+}
diff --git a/board/datarespons/vdt6010/vdt6010.c b/board/datarespons/vdt6010/vdt6010.c
new file mode 100644
index 0000000000..d3c88fe478
--- /dev/null
+++ b/board/datarespons/vdt6010/vdt6010.c
@@ -0,0 +1,398 @@
+// #define CONFIG_PANIC_HANG
+// CONFIG_SPL_NOR_SUPPORT
+// SPL_SPI_FLASH_SUPPORT
+// SPL_SPI_LOAD
+// CONFIG_SPL_POWER_SUPPORT
+/*
+ * Copyright (C) 2019 Data Respons Solutions AB
+ *
+ * Author: Mikko Salomäki <ms@datarespons.se>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/mach-imx/spi.h>
+#include <linux/errno.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include <environment.h>
+#include <usb.h>
+#include <pwm.h>
+#include <version.h>
+#include <watchdog.h>
+
+#include <asm/mach-imx/hab.h>
+#include <vsprintf.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#include "../common/mx6_common_defs.h"
+#include "../common/dev/pfuze100.h"
+#include "vdt6010_pins.h"
+#include "vdt6010_gpio.h"
+
+/*
+ *
+ * board_early_init_f
+ *
+ */
+
+int board_early_init_f(void)
+{
+	SETUP_IOMUX_PADS(uart1_pads);
+	SETUP_IOMUX_PADS(spi_nor_pads);
+	SETUP_IOMUX_PADS(pwm_pads);
+	SETUP_IOMUX_PADS(gpio_pads);
+	SETUP_IOMUX_PADS(other_pads);
+
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dq_i2c_pad_info0);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dq_i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dq_i2c_pad_info2);
+
+	return 0;
+}
+
+/*
+ *
+ * checkboard
+ *
+ */
+
+static const char* BOARD = "VDT6010";
+static const char* VENDOR = "Data Respons Solutions AB";
+
+static const char* hw_string[8] = {
+	"REVA",
+	"REVB",
+	"REVC",
+	"REVD",
+	"REVE",
+	"FUTURE",
+	"FUTURE",
+	"FUTURE",
+};
+
+static int get_version(void)
+{
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("Vendor: %s\n", VENDOR);
+	printf("Board: %s\n", BOARD);
+	printf("HW version: %s\n", hw_string[get_version()]);
+
+	return 0;
+}
+
+/*
+ *
+ * dram_init
+ *
+ */
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+	return 0;
+}
+
+/*
+ *
+ * board_init
+ *
+ * Setup chipselects
+ *
+ */
+
+
+int board_init(void)
+{
+	// address of boot parameters
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	return 0;
+}
+
+/*
+ *
+ * power_init_board
+ *
+ */
+
+struct _pmic_setup {
+	pf100_regs	reg;
+	int			mV;
+} pmic_setup[] = {
+		{SW1AB, 1425},	// VDDCORE
+		{SW1C, 1425},	// VDDSOC
+		{SW3AB, 1350},	// DDR_1V5
+		{0, 0}
+};
+
+int power_init_board(void)
+{
+	const int i2c = POWER_PFUZE100_I2C;
+	const int addr = CONFIG_POWER_PFUZE100_I2C_ADDR;
+	int ret = 0;
+
+	ret = pfuze100_setup(i2c, addr);
+	if (ret) {
+		printf("%s: no pmic: i2c: %d: addr: %d\n", __func__, i2c, addr);
+		return ret;
+	}
+
+	for (int i = 0; pmic_setup[i].reg; ++i) {
+		printf("Setting PMIC register %s to %d mV\n", pf100_reg_str(pmic_setup[i].reg), pmic_setup[i].mV);
+		ret = pfuze100_set(i2c, addr, pmic_setup[i].reg, pmic_setup[i].mV);
+		if (ret) {
+			printf("%s: pfuze100_set: %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	udelay(10000);
+
+	return 0;
+}
+
+
+/*
+ *
+ * mmc
+ *
+ */
+
+
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD);
+		break;
+
+	case USDHC4_BASE_ADDR:
+		ret = 1;
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+
+	SETUP_IOMUX_PADS(usdhc2_pads);
+	gpio_direction_input(USDHC2_CD);
+	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+	ret = fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+	if (ret) {
+		return ret;
+	}
+
+	SETUP_IOMUX_PADS(usdhc4_pads);
+	usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+	ret = fsl_esdhc_initialize(bis, &usdhc_cfg[1]);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ *
+ * board_late_init
+ *
+ */
+
+#define USBNC_USB_OTG_CTRL 		(USB_BASE_ADDR + 0x800)
+#define USBNC_CTRL_OVER_CUR_POL	(1 << 8) // Polarity of OC pin
+#define USBNC_CTRL_PWR_POL		(1 << 9) // Polarity of pwr pin
+
+//FIXME:
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1) {
+		return -EINVAL;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USBNC_USB_OTG_CTRL + port * 4);
+	// FIXME: POWER ANC OC POLARITY?
+	setbits_le32(usbnc_usb_ctrl, USBNC_CTRL_PWR_POL | USBNC_CTRL_OVER_CUR_POL);
+
+	return 0;
+}
+/*
+int board_usb_phy_mode(int port)
+{
+	unsigned int bmode = readl(&src_base->sbmr2);
+
+	switch(port) {
+	case 0:
+		if (((bmode >> 24) & 0x03) == 0x01)	{
+			printf("USB OTG in serial download mode\n");
+			return USB_INIT_DEVICE;
+		}
+
+		return USB_INIT_HOST;
+
+	case 1:
+		return USB_INIT_HOST;
+
+	default:
+		return USB_INIT_DEVICE;
+	}
+}
+*/
+
+static void setup_usb(void)
+{
+	SETUP_IOMUX_PADS(usb_otg_pads);
+	SETUP_IOMUX_PADS(usb_host_pads);
+
+	// Set daisy chain - USB_OTG_ID to GPIO_1
+	if (is_mx6dq()) {
+		imx_iomux_set_gpr_register(1, IOMUXC_GPR1_ENET_CLK_SEL_MASK, 1, 0);
+	}
+
+	// Reset USB hub and devices
+	gpio_direction_output(USB_HUB_RST, 0);
+	gpio_direction_output(USB_PWR_EN1, 0);
+	gpio_direction_output(USB_PWR_EN2, 0);
+	mdelay(10);
+	gpio_set_value(USB_HUB_RST, 1);
+	gpio_set_value(USB_PWR_EN1, 1);
+	gpio_set_value(USB_PWR_EN2, 1);
+}
+
+/**
+ * board_ehci_power - enables/disables usb vbus voltage
+ * @port:      usb otg port
+ * @on:        on/off vbus voltage
+ *
+ * Enables/disables supply vbus voltage for usb otg port.
+ * Machine board file overrides board_ehci_power
+ *
+ * Return: 0 Success
+ */
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static char * const usbcmd[] = {"usb", "start"};
+
+int board_late_init(void)
+{
+	int rep;
+	ulong ticks;
+
+	//FIXME: Move setup_usb() to
+	setup_usb();
+
+	cmd_process(0, 2, usbcmd, &rep, &ticks);
+
+	env_set("fdt_file", "/boot/datarespons-vdt6010-revA.dtb");
+
+	if (imx_hab_is_enabled())
+	{
+		printf("HAB enabled, setting up secure bootscript\n");
+		env_set("bootscript", BOOTSCRIPT_SECURE);
+		env_set("zimage", ZIMAGE_SECURE);
+		env_set("initrd_file", "/boot/initrd-ivt_signed");
+#ifdef CONFIG_BOOT_USB_INITRD
+		env_set("bootscript_usb", BOOTSCRIPT_USB_SECURE);
+#else
+		env_set("bootscript_usb", BOOTSCRIPT_SECURE);
+#endif
+		//env_set("bootdelay", "0");
+	}
+	else
+	{
+		printf("HAB disabled, setting up regular bootscript\n");
+		env_set("bootscript", BOOTSCRIPT_NOSECURE);
+		env_set("bootscript_usb", BOOTSCRIPT_NOSECURE);
+	}
+
+	return 0;
+}
+
+/*
+ *
+ * enet
+ *
+ */
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+static void setup_iomux_enet(void)
+{
+	SETUP_IOMUX_PADS(enet_pads);
+
+	// Set LAN8710 PHY reset
+	gpio_direction_output(LAN8710_RST , 0);
+
+	// Set GPR1[21] to enable ENET_REF_CLK output.
+	imx_iomux_set_gpr_register(1, IOMUXC_GPR1_ENET_CLK_SEL_MASK, 1, 1);
+
+	// Route anatop 50MHz to ENET_REF_CLK
+	enable_fec_anatop_clock(0, ENET_50MHZ);
+
+	udelay(500);
+
+	// Release LAN8710 PHY reset
+	gpio_direction_output(LAN8710_RST , 1);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	return cpu_eth_init(bis);
+}
diff --git a/board/datarespons/vdt6010/vdt6010_gpio.h b/board/datarespons/vdt6010/vdt6010_gpio.h
new file mode 100644
index 0000000000..a180e0f5cc
--- /dev/null
+++ b/board/datarespons/vdt6010/vdt6010_gpio.h
@@ -0,0 +1,40 @@
+#ifndef __VDT6010_GPIO_H__
+#define __VDT6010_GPIO_H__
+
+#include <asm/gpio.h>
+
+#define USDHC2_CD		IMX_GPIO_NR(1, 4)
+#define SPI_NOR_CS		IMX_GPIO_NR(5, 5)
+
+#define UART1_RS485EN2	IMX_GPIO_NR(4, 11)
+#define UART1_RS422EN2	IMX_GPIO_NR(4, 10)
+#define UART1_RS232EN2	IMX_GPIO_NR(4, 9)
+
+#define GPIO_1			IMX_GPIO_NR(4, 30)
+#define GPIO_2			IMX_GPIO_NR(4, 31)
+#define GPIO_3			IMX_GPIO_NR(5, 5)
+#define GPIO_4			IMX_GPIO_NR(5, 6)
+#define GPIO_5			IMX_GPIO_NR(5, 7)
+#define GPIO_6			IMX_GPIO_NR(5, 8)
+#define GPIO_7			IMX_GPIO_NR(5, 9)
+#define GPIO_8			IMX_GPIO_NR(5, 10)
+
+#define LAN8710_RST		IMX_GPIO_NR(6, 14)
+
+#define USB_PWR_EN1		IMX_GPIO_NR(5, 15)
+#define USB_PWR_EN2		IMX_GPIO_NR(5, 16)
+#define USB_HUB_RST		IMX_GPIO_NR(5, 17)
+
+#define PCIE_RST		IMX_GPIO_NR(4, 8)
+
+#define GPIO_MCU		IMX_GPIO_NR(1, 0)
+#define LED_VCC_EN		IMX_GPIO_NR(1, 5)
+#define LCD_VDD_EN		IMX_GPIO_NR(1, 6)
+#define CABC_EN			IMX_GPIO_NR(1, 7)
+#define BIST			IMX_GPIO_NR(1, 8)
+#define DEBUG_LED		IMX_GPIO_NR(7, 8)
+#define RTC_IRQ			IMX_GPIO_NR(1, 3)
+#define PMIC_INT		IMX_GPIO_NR(7, 13)
+#define LED_EN			IMX_GPIO_NR(7, 12)
+
+#endif /* __VDT6010_GPIO_H__ */
diff --git a/board/datarespons/vdt6010/vdt6010_pins.h b/board/datarespons/vdt6010/vdt6010_pins.h
new file mode 100644
index 0000000000..25651b2858
--- /dev/null
+++ b/board/datarespons/vdt6010/vdt6010_pins.h
@@ -0,0 +1,157 @@
+#ifndef __VDT6010_PINS_H__
+#define __VDT6010_PINS_H__
+
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+
+//#include "../dr-common/mx6_common_defs.h"
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	IOMUX_PADS(PAD_EIM_D24__UART1_DTR_B | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT6__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D20__UART1_CTS_B | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_EB3__UART1_RI_B | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT7__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D25__UART1_DSR_B | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D19__UART1_RTS_B | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D23__UART1_DCD_B | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_KEY_ROW2__GPIO4_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL)), // UART1_RS485EN2
+	IOMUX_PADS(PAD_KEY_COL2__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL)), // UART1_RS422EN2
+	IOMUX_PADS(PAD_KEY_ROW1__GPIO4_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL)), // UART1_RS232EN2
+};
+
+static iomux_v3_cfg_t const uart5_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT14__UART5_TX_DATA	| MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT15__UART5_RX_DATA	| MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const gpio_pads[] = {
+	IOMUX_PADS(PAD_DISP0_DAT9__GPIO4_IO30 | MUX_PAD_CTRL(NO_PAD_CTRL)), //GPIO1
+	IOMUX_PADS(PAD_DISP0_DAT10__GPIO4_IO31 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO2
+	IOMUX_PADS(PAD_DISP0_DAT11__GPIO5_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO3
+	IOMUX_PADS(PAD_DISP0_DAT12__GPIO5_IO06 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO4
+	IOMUX_PADS(PAD_DISP0_DAT13__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO5
+	IOMUX_PADS(PAD_DISP0_DAT14__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO6
+	IOMUX_PADS(PAD_DISP0_DAT15__GPIO5_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO7
+	IOMUX_PADS(PAD_DISP0_DAT16__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO8
+};
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	/* schematic says CRS_DV but no such define in mx6q_pins.h? */
+	IOMUX_PADS(PAD_ENET_CRS_DV__ENET_RX_EN	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_RX_ER__ENET_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_TX_EN__ENET_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_RXD0__ENET_RX_DATA0	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_RXD1__ENET_RX_DATA1	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_TXD0__ENET_TX_DATA0	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_TXD1__ENET_TX_DATA1	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_CS1__GPIO6_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL)),	// LAN8710 nRST
+	IOMUX_PADS(PAD_GPIO_9__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL)),		// LAN8710 IRQ#
+	IOMUX_PADS(PAD_GPIO_16__ENET_REF_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	IOMUX_PADS(PAD_SD4_CLK__SD4_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_CMD__SD4_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_ALE__SD4_RESET | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	IOMUX_PADS(PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_GPIO_4__GPIO1_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL)), //USDHC_PAD_CTRL?
+	IOMUX_PADS(PAD_GPIO_2__SD2_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL)), //USDHC_PAD_CTRL?
+};
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	IOMUX_PADS(PAD_KEY_COL4__USB_OTG_OC	| MUX_PAD_CTRL(WEAK_PULLUP)),
+	IOMUX_PADS(PAD_KEY_ROW4__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_GPIO_1__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usb_host_pads[] = {
+	IOMUX_PADS(PAD_DISP0_DAT21__GPIO5_IO15 | MUX_PAD_CTRL(NO_PAD_CTRL)), // USB_PWR_EN1
+	IOMUX_PADS(PAD_DISP0_DAT22__GPIO5_IO16 | MUX_PAD_CTRL(NO_PAD_CTRL)), // USB_PWR_EN2
+	IOMUX_PADS(PAD_DISP0_DAT23__GPIO5_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL)), // USB_HUB_RST
+};
+
+static iomux_v3_cfg_t const spi_nor_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT8__ECSPI2_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT9__ECSPI2_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT10__ECSPI2_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_DISP0_DAT11__GPIO5_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)), // cs
+};
+
+static iomux_v3_cfg_t const pwm_pads[] = {
+	IOMUX_PADS(PAD_SD1_DAT3__PWM1_OUT | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const other_pads[] = {
+	IOMUX_PADS(PAD_GPIO_0__GPIO1_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL)), // GPIO_MCU
+	IOMUX_PADS(PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)), // LED_VCC_EN
+	IOMUX_PADS(PAD_SD3_RST__GPIO7_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL)), // DEBUG_LED
+	IOMUX_PADS(PAD_GPIO_3__GPIO1_IO03 | MUX_PAD_CTRL(NO_PAD_CTRL)), // RTC_IRQ
+	IOMUX_PADS(PAD_GPIO_18__GPIO7_IO13 | MUX_PAD_CTRL(NO_PAD_CTRL)), // PMIC_INT
+	IOMUX_PADS(PAD_GPIO_6__GPIO1_IO06 | MUX_PAD_CTRL(NO_PAD_CTRL)), // LCD_VDD_EN
+	IOMUX_PADS(PAD_GPIO_7__GPIO1_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL)), // CABC_EN
+	IOMUX_PADS(PAD_GPIO_8__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL)), // BIST
+	IOMUX_PADS(PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL)), // LED_EN
+	IOMUX_PADS(PAD_KEY_COL1__GPIO4_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL)), // PCIE_RST_B
+};
+
+static struct i2c_pads_info mx6dq_i2c_pad_info0 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_EIM_D21__I2C1_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_EIM_D21__GPIO3_IO21 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 21)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_EIM_D28__I2C1_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_EIM_D28__GPIO3_IO28 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 28)
+	}
+};
+
+static struct i2c_pads_info mx6dq_i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_KEY_COL3__I2C2_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO4_IO12 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_KEY_ROW3__I2C2_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO4_IO13 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+static struct i2c_pads_info mx6dq_i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_EIM_D17__I2C3_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_EIM_D17__GPIO3_IO17 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 17)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_EIM_D18__I2C3_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_EIM_D18__GPIO3_IO18 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 18)
+	}
+};
+
+#endif
diff --git a/configs/vdt6010_defconfig b/configs/vdt6010_defconfig
new file mode 100644
index 0000000000..1ec08273e9
--- /dev/null
+++ b/configs/vdt6010_defconfig
@@ -0,0 +1,59 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SYS_TEXT_BASE=0x17800000
+CONFIG_TARGET_VDT6010=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/datarespons/vdt6010/mx6.cfg,MX6QDL,SECURE_BOOT"
+CONFIG_BOOTDELAY=0
+CONFIG_AUTOBOOT_NOABORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="DR"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
+CONFIG_DEFAULT_FDT_FILE	"/boot/datarespons-vdt6010-revC-dl.dtb"
+CONFIG_MX6_DDRCAL=y
+CONFIG_CMD_PART=y
+CONFIG_PARTITIONS=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_UUIDS=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_MMC_HW_PARTITIONING=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_FSL_CAAM=y
+CONFIG_BOOT_USB_INITRD=y
+CONFIG_SHA256=y
+CONFIG_SPL=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SPL_OS_BOOT=n
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
diff --git a/include/configs/vdt6010.h b/include/configs/vdt6010.h
new file mode 100644
index 0000000000..5e5f28249e
--- /dev/null
+++ b/include/configs/vdt6010.h
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __VDT6010_CONFIG_H
+#define __VDT6010_CONFIG_H
+
+/*
+#ifndef CONFIG_SPL_BUILD
+#define DEBUG
+#endif
+*/
+
+#define CONFIG_SYS_FSL_SEC_COMPAT 4
+
+#ifdef CONFIG_SPL
+
+#include "imx6_spl.h"
+#undef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 512
+#endif
+
+#define CONFIG_MXC_UART_BASE	UART5_BASE
+#define CONSOLE_DEV		"ttymxc4"
+#define CONFIG_IMX_WATCHDOG
+#undef CONFIG_IMX_WATCHDOG_USE_WD2
+
+#define CONFIG_MMCROOT			"/dev/mmcblk0p1"
+
+/* This defines always booting from eMMC, rework mmc code
+ * to support booting from usb -> sd -> mmc?
+ */
+#define MMC_DEV "1"
+
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#include "mx6_common.h"
+
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+#define CONFIG_IMX_THERMAL
+
+/*#define CONFIG_SYS_GENERIC_BOARD*/
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * SZ_1M)
+
+#define CONFIG_MXC_UART
+
+#if defined(CONFIG_CMD_FUSE) || defined(CONFIG_IMX6_THERMAL)
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR   USDHC4_BASE_ADDR
+
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		0
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_SMSC
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX              1
+#define CONFIG_BAUDRATE                        115200
+
+#ifndef CONFIG_LOGLEVEL
+#define CONFIG_LOGLEVEL 4
+#endif
+
+#define CONFIG_LOADADDR                0x12000000
+
+#define CONFIG_MACH_TYPE	0xffffffff	/* Needed for newer kernels */
+
+#define xstr(a) str(a)
+#define str(a) #a
+
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_SPL)
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME 100
+#endif
+
+#define ZIMAGE_SECURE "/boot/zImage-ivt_signed"
+#define BOOTSCRIPT_SECURE \
+	"run setargs; " \
+	"if run load_ivt_info; then " \
+		"echo IVT starts at ${ivt_offset}; " \
+		"if run loadimage; then " \
+			"if hab_auth_img ${loadaddr} ${filesize} ${ivt_offset}; then " \
+				"echo Authenticated kernel; " \
+				"run loadfdt; bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"echo Failed to authenticate kernel; " \
+			"fi; " \
+		"else " \
+			"echo Failed to load image ${zimage}; " \
+		"fi; " \
+	"else " \
+		"echo No IVT information; " \
+	"fi;"
+
+#define BOOTSCRIPT_USB_SECURE \
+	"echo running secure USB boot; run setargs;" \
+	"if run validate_image; then " \
+		"if run validate_initrd; then " \
+			"run loadfdt; bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; " \
+		"fi; " \
+	"fi;"
+
+#define ZIMAGE "/boot/zImage"
+
+#define VALIDATE_ZIMAGE \
+	"if run load_ivt_info; then " \
+		"echo kernel IVT starts at ${ivt_offset}; " \
+		"if run loadimage; then " \
+			"if hab_auth_img ${loadaddr} ${filesize} ${ivt_offset}; then " \
+				"echo Authenticated kernel; " \
+			"else " \
+				"echo Failed to authenticate kernel && false;" \
+			"fi; " \
+		"else " \
+			"echo Failed to load image ${zimage} && false; " \
+		"fi; " \
+	"else " \
+		"echo No IVT information && false; " \
+	"fi;"
+
+#define VALIDATE_INITRD \
+	"if run load_initrd_ivt_info; then " \
+		"echo INITRD IVT loaded at ${initrd_addr} offset is ${ivt_offset}; " \
+		"if run loadinitrd; then " \
+			"if hab_auth_img ${initrd_addr} ${filesize} ${ivt_offset}; then " \
+				"echo Authenticated initrd; " \
+			"else " \
+				"echo Failed to authenticate initrd && false; " \
+			"fi; " \
+		"else " \
+			"echo Failed to load image ${initrd_file} && false; " \
+		"fi; " \
+	"else " \
+		"echo No IVT information && false; " \
+	"fi;"
+
+#define BOOTSCRIPT_NOSECURE \
+	"run setargs; if run loadimage loadfdt; then bootz ${loadaddr} - ${fdt_addr}; else echo ERROR: Could not load prescribed config; fi;"
+
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"zimage=" ZIMAGE "\0" \
+	"fdt_addr=0x11000000\0" \
+	"ip_dyn=try\0" \
+	"console=" CONSOLE_DEV ",115200\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_file_def=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"initrd_file=/boot/initrd\0" \
+	"loglevel="xstr(CONFIG_LOGLEVEL)"\0" \
+	"consoleblank=0\0" \
+	"showtty=console=ttymxc0,115200 console=tty1\0" \
+	"setargs=setenv bootargs console=${console} root=${rootdev} rootwait ro rootfstype=ext4 consoleblank=${consoleblank} loglevel=${loglevel} ${showtty}\0" \
+	"bootdev=0\0" \
+	"bootpart=1\0" \
+	"bootfrom=mmc\0" \
+	"mmc_root=" CONFIG_MMCROOT "\0" \
+	"usb_root=/dev/sda1\0" \
+	"loadbootscript=if ext4load mmc 0:4 ${loadaddr} /boot/boot.txt; then env import -t ${loadaddr} ${filesize}; fi; \0" \
+	"ivt_offset=0\0" \
+	"load_ivt_info=if ext4load ${bootfrom} ${bootdev}:${bootpart} 11F00000 /boot/zImage-padded-size; then env import -t 11F00000 ${filesize}; fi; \0" \
+	"load_initrd_ivt_info=if ext4load ${bootfrom} ${bootdev}:${bootpart} 11F00000 /boot/initrd-padded-size; then env import -t 11F00000 ${filesize}; fi; \0" \
+	"setmmc=setenv bootfrom mmc; setenv bootdev "MMC_DEV" ; setenv rootdev ${mmc_root}; \0 " \
+	"setusb=setenv bootfrom usb; setenv bootdev 0; setenv bootpart 1; setenv rootdev ${usb_root}; echo Setting boot to usb; \0 " \
+	"loadimage=ext4load ${bootfrom} ${bootdev}:${bootpart} ${loadaddr} ${zimage}; \0" \
+	"loadinitrd=ext4load ${bootfrom} ${bootdev}:${bootpart} ${initrd_addr} ${initrd_file}; \0" \
+	"loadfdt=ext4load ${bootfrom} ${bootdev}:${bootpart} ${fdt_addr} ${fdt_file}; \0" \
+	"loadfdtdef=ext4load ${bootfrom} ${bootdev}:${bootpart} ${fdt_addr} ${fdt_file_def}; \0" \
+	"bootscript_secure=" BOOTSCRIPT_SECURE " \0" \
+	"bootscript_nosecure=" BOOTSCRIPT_NOSECURE " \0" \
+	"bootscript_usb=" BOOTSCRIPT_NOSECURE " \0" \
+	"validate_image=" VALIDATE_ZIMAGE " \0" \
+	"validate_initrd=" VALIDATE_INITRD " \0" \
+	"check_usb_boot=if usb storage; then run setusb; fi;\0" \
+	"initrd_addr=0x12C00000\0" \
+	"initrd_high=0xffffffff\0" \
+	"factory_args=setenv bootargs console=${console} rdinit=/linuxrc enable_wait_mode=off \0" \
+	"install_args=setenv bootargs console=${console} rdinit=/install_script enable_wait_mode=off \0" \
+	"factory_boot=run factory_args; bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; \0" \
+	"testfact=run loadfdt loadimage loadinitrd factory_boot; \0" \
+	"habtest=run load_ivt_info loadimage; hab_auth_img ${loadaddr} ${filesize} ${ivt_offset}; \0" \
+	"install_boot=run install_args loadfdt loadimage loadinitrd; bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; \0"
+#ifdef CONFIG_FACTORY_BOOT
+#define CONFIG_BOOTCOMMAND \
+	"mmc partconf 0 0 1 0;" \
+	"run factory_boot;"
+#else
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev "MMC_DEV"; mmc rescan; " \
+	"if run check_usb_boot; then " \
+		"echo booting from USB ...;" \
+		"run bootscript_usb;" \
+		"echo USB boot failed, revert to MMC;" \
+	"fi; " \
+	"run loadbootscript;" \
+	"run setmmc;" \
+	"echo boot from MMC p${bootpart};" \
+	"run bootscript;" \
+	"echo boot from ${bootpart} failed, swapping;" \
+	"if test ${bootpart} = 2; then " \
+		"setenv bootpart 1; setenv mmc_root /dev/mmcblk0p1;" \
+	"else " \
+		"setenv bootpart 2; setenv mmc_root /dev/mmcblk0p2;" \
+	"fi; " \
+	"run setmmc;" \
+	"run bootscript;"
+#endif
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_ENV_OVERWRITE
+
+
+#define CONFIG_ENV_SIZE			(64 * 1024)
+
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK	66000000
+#define CONFIG_SYS_I2C_MXC_I2C1
+#define CONFIG_SYS_I2C_MXC_I2C2
+#define CONFIG_SYS_I2C_MXC_I2C3
+/*#define CONFIG_SYS_I2C_MXC_I2C4*/
+
+#define CMD_CRC32
+
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#if 0
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
+#endif
+#endif
+
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		  100000
+
+/* PMIC */
+/*
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+*/
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+#define POWER_PFUZE100_I2C 1
+
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2 /* Enabled USB controller number */
+#define CONFIG_USBD_HS
+
+#endif /* __VDT6010_CONFIG_H */
